<small>
  
## Книга "Java полное руководство - Герберт Шилдт, 12-е издание, 2022г."

<small>

#### Оглавление

<details ГЛАВА 1><summary>ГЛАВА 1. "История и эволюция языка Java"</summary>
<blockquote>
  
<details><summary>Создание языка Java</summary>
  
Главной движущей силой стала потребность в **независимом от платформы** (т.е. архитектурно-нейтральном) языке, который можно было бы использовать для построения программного обеспечении, встраиваемого в разнообразные бытовые электронные устройства, такие как микроволновые печи и пульты дистанционного управления.
Второй движущей силой стала Всемирная паутина (она же веб-сеть) т.к. веб-сеть тоже нуждалась в переносимых программах.
</details>

<details><summary> Апплет в Java</summary>

**Апплет** — это Java-приложение, которое запускается внутри веб-браузера с помощью Java-плагина. Апплеты были популярными в 1990-х и начале 2000-х годов как способ предоставления интерактивных графических приложений на веб-страницах. Они позволяли разработчикам создавать множество интересных веб-приложений, включая игры, графические редакторы и интерактивные диаграммы.

По существу, апплет позволяет переместить определенную функциональность из серверной стороны на клиентскую сторону. Напротив, апплет представляет собой динамическую самостоятельно запускающуюся программу. Такая программа является активным агентом на клиентском компьютере, но инициируется сервером.

Основные характеристики Java апплетов включают: 
- Платформонезависимость: Java апплеты могли выполняться на разных операционных системах и архитектурах благодаря тому, что они компилировались в байт-код Java и выполнялись на виртуальной машине Java (JVM). 
- Безопасность: Апплеты были ограничены в своих возможностях для обеспечения безопасности. Они могли выполняться в песочнице (sandbox), что ограничивало их доступ к ресурсам компьютера.
- Графический интерфейс: Java апплеты могли создавать графический пользовательский интерфейс с использованием библиотеки AWT (Abstract Window Toolkit) или Swing.

Связь Java-кода с браузером осуществлялась с помощью Java апплетов. Вот как это происходило: 
1. Написание Java-кода: Разработчик создавал Java-код, который выполнял определенные задачи и визуализацию интерфейса, если это требовалось.
2. Компиляция в байт-код Java: Java-код затем компилировался в байт-код Java с использованием компилятора Java. Байт-код был независим от конкретной аппаратной платформы.
3. Создание HTML-страницы: Разработчик создавал HTML-страницу, которая включала тег `<applet>`. В этом теге указывалось имя класса Java-апплета и другие параметры, такие как размеры окна, параметры безопасности и т. д. 
   Пример тега `<applet>`:
   ```html
   <applet code="MyApplet.class" width="300" height="200"></applet>
</details>

<details><summary>Магия Java: байт-код</summary>
Компилятор Java генерирует не исполняемый код, а байт-код. Байт-код представляет собой оптимизированный набор инструкций, предназначенных для выполнения так называемой виртуальной машиной Java (Java Virtual Machine - JVM), которая является частью исполняющей среды Java (Java Runtime Environment - JRE).
  
**Java Virtual Machine (JVM)** — это виртуальная машина, которая выполняет байт-код Java, созданный компилятором Java из исходного Java-кода. JVM обеспечивает платформонезависимость Java, позволяя Java-приложениям выполняться на разных операционных системах без изменений в их исходном коде.

Вот как работает JVM: 
1. Компиляция в байт-код: Исходный Java-код компилируется в байт-код Java с помощью Java-компилятора (javac). Байт-код представляет собой набор инструкций, которые являются абстрактными и не зависят от конкретной аппаратной платформы. 
2. Загрузка классов: JVM загружает байт-код Java в память по мере необходимости. Классы могут быть загружены с локального класспаса (classpath) или из удаленных источников, таких как удаленные серверы или интернет.
3. Верификация: перед выполнением классы проходят процесс верификации, в ходе которого проверяется их правильность и безопасность. Это важный этап, который защищает систему от вредоносного кода.
4. Исполнение: когда класс загружен и верифицирован, JVM начинает выполнение байт-кода Java. Виртуальная машина интерпретирует байт-код или может использовать Just-In-Time (JIT) компиляцию для перевода байт-кода в нативный машинный код для конкретной аппаратной платформы, что может улучшить производительность приложения.
5.	Управление памятью: JVM управляет памятью, выделяя и освобождая память для объектов, создаваемых во время выполнения приложения. Это включает в себя управление кучей (heap) для объектов и стеком вызовов (call stack) для управления вызовами методов и локальными переменными.
6.	Сборка мусора: JVM автоматически отслеживает объекты, которые больше не используются, и периодически освобождает память, занимаемую этими объектами, с помощью сборщика мусора (garbage collector).
7.	Управление исключениями: JVM обрабатывает исключения, которые могут возникнуть во время выполнения приложения, и предоставляет механизмы для их обработки и управления.
8.	Многозадачность: JVM обеспечивает поддержку многозадачности, позволяя выполнять несколько потоков (threads) одновременно в рамках одного процесса Java-приложения.
9.	Библиотеки Java: JVM включает в себя стандартные библиотеки Java (Java Standard Library), которые предоставляют множество классов и методов для работы с различными аспектами программирования, такими как работа с файлами, сетевое взаимодействие, графика и многое другое.

**Just-In-Time (JIT) компиляция** — это техника оптимизации выполнения кода виртуальной машины (VM) или интерпретатора, которая используется, чтобы улучшить производительность при выполнении программы. JIT компиляция предназначена для ускорения работы приложения путем преобразования некоторых частей кода, представленного в байт-коде или другом промежуточном формате, в нативный машинный код, который выполняется непосредственно на целевой аппаратной платформе. 
Вот как работает JIT компиляция: 
1.  Интерпретация и компиляция: изначально, при запуске программы, код выполняется в интерпретируемом режиме. Это означает, что инструкции байт-кода (или другого промежуточного кода) интерпретируются виртуальной машиной, что может быть медленным в сравнении с нативным машинным кодом. 
2.	Профилирование кода: во время интерпретации виртуальная машина отслеживает, какие части кода выполняются наиболее часто. Это называется профилированием кода. 
3.	Компиляция в нативный код: когда определенный фрагмент кода выполняется достаточно часто, JIT-компилятор анализирует этот код и транслирует его в нативный машинный код для конкретной аппаратной платформы. Это происходит во время выполнения программы, и только для тех участков кода, которые действительно нуждаются в оптимизации. 
4.	Кеширование: Сгенерированный нативный код кешируется, чтобы он мог быть использован при последующих вызовах того же фрагмента кода без повторной компиляции.

**Нативный машинный код** — это низкоуровневый исполняемый код, который представляет собой инструкции, понятные конкретному процессору или архитектуре компьютера. Этот код является непосредственно понятным и выполняемым процессором, без дополнительной обработки или интерпретации.

**Байт-код** представляет собой абстрактную форму кода, которая является промежуточным уровнем между исходным кодом и нативным машинным кодом. Он не зависит от конкретной аппаратной платформы, так как он представлен в виде набора инструкций и операций, которые понимает виртуальная машина (например, JVM для Java или CLR для C#). Виртуальная машина интерпретирует байт-код или компилирует его в нативный машинный код во время выполнения, адаптируя его под текущую платформу. Таким образом, байт-код обеспечивает переносимость между разными архитектурами и операционными системами.

Как все взаимосвязано:
1.	Байт-код Java: когда вы компилируете исходный Java-код с помощью компилятора Java, он создает байт-код Java. Этот байт-код представляет собой инструкции, которые не зависят от конкретной аппаратной платформы, и это делает его переносимым. 
2.	JVM — это программное обеспечение, которое является частью среды выполнения Java (Java Runtime Environment, JRE). JVM интерпретирует или JIT-компилирует байт-код Java в нативный машинный код, который может выполняться на конкретной аппаратной платформе. Это ключевой момент, который обеспечивает переносимость Java-приложений. 
3.	Изоляция нативного кода: Нативный код, который генерирует JVM, ассоциирован с аппаратной платформой и операционной системой, на которой JVM работает. Однако этот нативный код находится внутри JVM и изолирован от самой Java-программы. Java-приложение взаимодействует с нативным кодом через API, которые предоставляются JVM, и эти API переносимы и абстрагируют код Java от деталей аппаратной платформы. 
4.	Платформонезависимость: поскольку байт-код Java является переносимым и может быть выполнен на любой платформе, на которой установлена совместимая JVM, Java-приложения могут быть написаны один раз и выполняться на разных операционных системах и аппаратных платформах, где существует JVM. Это обеспечивает платформонезависимость Java.

API (Application Programming Interface) — это набор определенных правил и протоколов, которые позволяют разным программным компонентам взаимодействовать друг с другом. API определяет, какие функции и методы доступны для использования внешними приложениями, и как эти приложения могут взаимодействовать с системой, библиотекой, сервисом или операционной системой.
Примерами API могут быть следующие:
- API операционной системы, которое позволяет приложениям управлять файлами, сетевыми соединениями и другими аспектами ОС.
- API социальных сетей, которые позволяют разработчикам создавать приложения, интегрированные с социальными платформами. 
-	API библиотеки, предоставляющей математические функции для приложения. 
-	API веб-сервисов, позволяющие приложениям обмениваться данными через интернет.

Взаимодействие Java-приложения с нативным кодом происходит через Java Native Interface (JNI), который представляет собой API, предоставляющее возможность вызывать функции, написанные на нативных языках (как правило, на C или C++), из Java-приложения. Это позволяет Java-приложениям использовать библиотеки и функциональность, которая не доступна непосредственно на языке Java.

</details>

<details><summary>Сервлеты: Java на серверный стороне</summary>

  **Сервлеты** представляют собой Java-классы, которые используются для разработки динамических веб-приложений на платформе Java. Они работают на серверной стороне и предназначены для обработки HTTP-запросов и генерации HTTP-ответов. Сервлеты широко используются в веб-приложениях для создания веб-страниц, взаимодействия с базами данных, обработки форм, аутентификации и других веб-связанных задач. 

  Вот основные характеристики сервлетов: 
  1. 	Java-классы: Сервлеты представляют собой обычные классы на языке Java, которые расширяют классы или реализуют интерфейсы из Java Servlet API. Обычно, для создания сервлета, нужно создать Java-класс и переопределить методы, такие как doGet() или doPost(), для обработки HTTP-запросов. 
  2.	Жизненный цикл: у сервлетов есть жизненный цикл, который включает в себя инициализацию, обработку запросов и завершение работы. Сервлет может быть создан один раз и использоваться для обслуживания нескольких запросов, что позволяет сэкономить ресурсы сервера. 
  3.	Обработка HTTP-запросов: Главная задача сервлетов - обработка HTTP-запросов от клиентов (например, браузеров). Они могут анализировать параметры запроса, читать и записывать HTTP-заголовки, работать с сессиями пользователей и так далее. 
  4.	Генерация HTTP-ответов: Сервлеты также генерируют HTTP-ответы, которые включают в себя HTML-страницы, JSON-данные, изображения и другие ресурсы. Ответы отправляются клиентам (браузерам) в форме HTTP-сообщений. 
  5.	Поддержка многопоточности: Сервлеты автоматически поддерживают многопоточность. Они могут одновременно обслуживать несколько запросов от разных клиентов, и каждый запрос выполняется в отдельном потоке. 
  6.	Конфигурация через web.xml или аннотации: Сервлеты могут быть настроены с использованием файлов конфигурации web.xml или с помощью аннотаций (в более современных версиях Java Servlet API). Это позволяет определить URL-пути, по которым сервлеты будут доступны, а также другие параметры.

Сервлеты являются важной частью технологии Java EE (Java Platform, Enterprise Edition) и используются для создания множества веб-приложений, включая корпоративные приложения, интернет-магазины, порталы и другие веб-ресурсы. Они предоставляют программистам мощный инструмент для создания динамических и интерактивных веб-приложений, работающих на сервере Java.
  
</details>

<details><summary>Терминология языка Java</summary>
• простота; • безопасность; • переносимость; • объектная ориентация; • надежность; • многопоточность; • нейтральность к архитектуре; • интерпретируемость; • высокая производительность; • распределенность; • динамичность.

_Надежность._
Java – строго типизированный язык.
  
**Строго типизированный язык** (или сильно типизированный язык) — это язык программирования, который строго следует правилам и ограничениям, касающимся типов данных. В строго типизированных языках каждая переменная и выражение имеют строго определенный тип данных, и их использование ограничено в соответствии с этим типом.
  
Чтобы лучше понять, как обеспечивается надежность в Java, рассмотрим две главных причины отказа программ: просчеты в управлении памятью и неправильно обработанные исключительные ситуации (т.е. ошибки времени выполнения).  
Скажем, в С/С++ программист будет часто вручную выделять и освобождать динамическую память. Подход подобного рода иногда приводит к возникновению проблем, потому что программисты будут либо забывать об освобождении ранее выделенной памяти, либо, что хуже, пытаться освободить память, которая все еще задействована в другой части кода. Java практически устраняет указанные проблемы, самостоятельно управляя выделением и освобождением памяти. (На самом деле освобождение выполняется полностью автоматически, поскольку Java обеспечивает сборку мусора для неиспользуемых объектов.)
Условия для исключений в традиционных средах часто возникают в ситуациях вроде деления на ноль или отсутствия нужного файла, и справляться с ними приходится с помощью неуклюжих и трудных для чтения конструкций. Java помогает и этой области, предлагая объектно-ориентированную обработку исключений. В хорошо написанной программе на Java все ошибки времени выполнения могут - и должны - обрабатываться вашей программой.

_Интерпретируемость и высокая производительность._
Байт-код Java был тщательно спроектирован, чтобы легко транслироваться прямо в машинный код для достижения очень высокой производительности с использованием оперативного компилятора.

</details>

</blockquote>
</details>

<details ГЛАВА 2><summary>ГЛАВА 2. "Краткий обзор языка Java"</summary>
<blockquote>
  
<details><summary>Объектно-ориентированное программирование. Две парадигмы</summary>
Все компьютерные программы состоят из двух элементов: **кода и данных**. Кроме того, программа может быть **концептуально организована вокруг своего кода или своих данных**. Иными словами, одни программы пишутся исходя из того, "что происходит”; а другие - исходя из того, "что затронуто”.
  
Существуют две парадигмы, определяющие то, как строится программа:
  1. Модель, ориентированная на процессы – последовательность линейных шагов (т.е. кода), код, воздействующий на данные. При использовании этого подхода начинают возникать проблемы.
  2.	Объектно-ориентированное программирование. Позволяет организовать программу вокруг ее данных (т.е. объектов) и набора четко определенных интерфейсов к таким данным. Это данные, управляющие доступом к коду

**Абстракция** – принцип, который позволяет скрыть детали реализации объекта и выделить только самую важную информацию или функциональность.

Скажем, в состав аудиосистемы может входить радиоприемник, проигрыватель компакт-дисков и/или проигрыватель МРЗ. Суть в том, что вы управляете сложностью автомобиля (или любой другой сложной системы) за счет использования иерархических абстракций.

**Суть ООП:** Последовательность шагов процесса может стать совокупностью сообщений, передаваемых между этими объектами. Таким образом, каждый объект описывает свое уникальное поведение. Вы можете воспринимать такие объекты как конкретные сущности, которые реагируют на сообщения, указывающие им о необходимости делать что-то. 

</details>

<details><summary>Три принципа ООП</summary>
  
## Инкапсуляция 
Инкапсуляция представляет собой механизм, который связывает вместе код и обрабатываемые им данные, а также защищает их от внешнего вмешательства и неправильного использования. Инкапсуляцию можно считать защитной оболочкой, которая предотвращает произвольный доступ к коду и данным из другого кода, определенного вне оболочки. Доступ к коду и данным, находящимся внутри оболочки, строго контролируется через четко определенный интерфейс.
  
**Сила инкапсулированного кода** в том, что каждый знает, как пол учить к нему доступ, и потому может использовать его независимо от деталей реализации и без каких-либо опасений столкнуться с неожиданными побочными эффектами.

**Основой инкапсуляции** в Java является класс.
Класс определяет структуру и поведение (данные и код), которые будут общими для набора объектов. Каждый объект заданного класса содержит структуру и поведение, определенные классом, как если бы он был "отлит" в форме класса. Поэтому **объект** – экземпляр класса.

Таким образом, класс представляет собой логическую конструкцию, а объект имеет физическую реальность.

В правильно написанных программах на Java методы определяют способ использования переменных-членов, т.е. поведение и интерфейс класса определяются методами, которые работают с данными его экземпляра. 

**Целью класса** является инкапсуляция сложности.

## Наследование 
Наследование представляет собой процесс, посредством которого один объект приобретает свойства другого объекта. Оно важно, т.к. поддерживает концепцию иерархической классификации.

**Суперкласс** — это класс, который предоставляет общие свойства и методы, которые могут быть унаследованы подклассами. Суперкласс определяет базовую структуру и поведение, которые могут быть общими для нескольких классов. Это позволяет избегать дублирования кода и обеспечивает более легкое управление и сопровождение кода.

Наследование также взаимодействует с инкапсуляцией. Когда подкласс наследует суперкласс, он наследует не только его методы и свойства, но также и инкапсулированную структуру и данные.

## Полиморфизм  
_(от греческого "много форм")_

Представляет собой средство, которое позволяет использовать один интерфейс для общего класса действий.

В языке, не являющемся объектно-ориентированным, вам придется создать три разных набора стековых процедур с отличающимися именами. Но благодаря полиморфизму в Java вы можете указать общий набор стековых процедур с одинаковыми имен.

</details>

<details><summary>Компиляция программы</summary>
Файл с исходным кодом в Java официально называется единицей компиляции. По соглашению имя главного класса должно совпадать с именем файла, содержащего программу.
  
В Java исходный код программы обычно разбивается на несколько классов, каждый из которых может быть размещен в отдельном файле. Каждый файл с исходным кодом Java обычно имеет расширение .java. Однако при компиляции этого исходного кода каждый класс превращается в отдельный файл байт-кода с расширением .class. Этот байт-код является исполняемым для Java виртуальной машины (JVM). 
  
Для того чтобы JVM могла найти и выполнить нужный класс при запуске программы, следует придерживаться следующей конвенции:
1.	Имя файла с исходным кодом (.java) должно совпадать с именем класса, который он содержит.
2.	Когда вы запускаете программу Java, вы указываете имя класса, который должен быть запущен. JVM автоматически ищет соответствующий файл с расширением .class.    
</details>

<details><summary>Подробный анализ первого примера программы</summary>
  
```html 
  public srtatic void main(String[] args){ }
```
Данная строка начинает метод main(). Как объяснялось в предыдущем комментарии, с этой строки программа начнет выполняться. Обычно программа на Java начинает выполнение с вызова main(). Полностью осознать смысл каждой части строки пока невозможно, т.к. для этого нужно хорошо понимать подход Java к инкапсуляци.

Ключевое слово puЫic представляет собой модификатор доступа, который позволяет программисту управлять видимостью чл енов класса. Когда член класса предварен ключевым словом puЫic, доступ к нему может быть получен из кода за пределами класса, где он объявлен. В данном случае метод main() должен быть объявлен как puЫic, потому что при запуске программы его потребуется вызывать в коде за пределами класса.

Ключевое слово static позволяет вызывать main() без создания конкретного экземпляра класса. Причина в том, что main() вызывается машиной JVM до создания каких-либо объектов, т.к. метод main принадлежит не конкретному экземпляру класса, а самому классу.

Ключевое слово void просто сообщает компилятору, что main() не возвращает значение.

Параметры метода – args, который получает любые аргументы командной строки, присутствующие при выполнении программы.

```html 
  System.out.printl("Hello, world!");
```
System — это класс в стандартной библиотеке Java, который предоставляет доступ к системным ресурсам и переменным окружения.

out — это объект типа PrintStream, который представляет стандартный вывод (обычно консоль). Он предоставляет методы для вывода данных. 

println — это метод объекта PrintStream, который используется для вывода текста или значения и добавляет перевод строки (новую строку) в конце вывода. Это означает, что следующий вывод будет на новой строке.

Если за место текста указать переменную, то на самом деле ее значение сначала преобразуется из целочисленного (или другой тип данных) в эквивалентное строковое и затем объединяется с предшествующей ему строкой.

</details>

<details><summary>Доп.</summary>
  
**Операции инкремента и декремента** — это арифметические операции, которые увеличивают (инкремент) или уменьшают (декремент) значение переменной на 1.
  
Блок кода создан, то становится логической единицей, которую можно применять в любом месте, где разрешено использовать одиночный оператор. Главная причина их существования - создание логически неразрывных единиц кода.

В Java **литералы** — это константные значения, которые представляют данные определенных типов.

</details>

</blockquote>
</details>

<details ГЛАВА 3><summary>ГЛАВА 3. "Типы данных, переменные и массивы"</summary>
<blockquote>
  
<details><summary>Типы данных</summary>
  
<details><summary>Целые числа</summary>

Во многих других языках программирования поддерживаются как целые числа со знаком(signed), так и целые числа без знак(unsigned), но разработчики Java решили, что целые числа без знака не нужны. В частности, они считали, что понятие без знака использовалось в основном для указания поведения старшего бита, который определяет знак целочисленного значения. В главе 4 вы увидите, что Java подругому управляет смыслом старшего бита, добавляя специальную операцию **"беззнакового сдвига вправо"**: таким образом, необходимость в целочисленном типе без знака попросту отпала.

**Беззнаковый сдвиг вправо** (unsigned right shift) - это операция, которая позволяет сдвигать биты числа вправо без учета его знака. В Java, этот механизм предоставляется оператором ">>>" и применяется к целым числам (int и long). Он используется для выполнения арифметических сдвигов битов числа, при которых самый старший бит (знаковый бит) не учитывается, и новые биты заполняются нулями.

Пример: 
```html 
int number = -8; // Бинарное представление: 11111111111111111111111111111000
int result = number >>> 1; // Сдвиг на 1 позицию вправо 
```

**Знаковый сдвиг вправо** (signed right shift) для целочисленных типов данных. Этот оператор выполняет сдвиг битов числа вправо на заданное количество позиций, при этом заполняет левую сторону (старшие биты) копией самого левого бита (знакового бита) перед сдвигом.

Пример: 
```html 
int x = -10; // Например, число -10 в двоичной системе: 11111111111111111111111111110110
x = x >> 2; // Знаковый сдвиг вправо на 2 позиции, получим 11111111111111111111111111111101
```

Ширина (или разрядность) целочисленного типа не должна трактоваться как объем потребляемой им памяти, а скорее как поведение, которое он определяет для переменных и выражений данного типа. 

Переменные типа byte особенно удобны при работе с потоком данных из сети или файла. Они также полезны, коrда приходится иметь дело с низкоуровневыми двоичными данными, которые моrут быть несовместимыми напрямую с другими встроенными типами Java.
</details>

<details><summary>Типы с плавающей точкой </summary>

В Java реализован стандартный (IEEE-754) набор типов и операций с плавающей точкой. Существуют две разновидности типов с плавающей точкой.

Тип float определяет значение одинарной точности.
Значение двойной точности.

</details>

<details><summary>Символы</summary>

Для хранения символов в Java используется тип данных char. Важно понять один ключевой момент: для представления символов в Java применяется Unicode. Кодировка Unicode определяет полностью международный набор 
символов, с помощью которого можно представить все символы, встречающиеся во всех естественных языках. Он объединяет десятки наборов символов, таких как романский, греческий, арабский, кириллический, иврит, катакана, ханrул и многие другие. Во время создания Java для Unicode требовалось 16 бит. Таким образом, в Java тип char является 16-битным с диапазоном значений от О до 65 535. Отрицат ельных значений char не бывает. Стандартный набор символов, известный как ASCII, по-прежнему находится в диапазоне от О до 127, а расширенный 8-битный набор символов, ISO-Latin-1 - в диапазоне от О до 255. Поскольку язык Java предназначен для написания программ, используемых по всему миру, при представлении символов имеет смысл применять Unicode. Конечно, использование Unicode несколько неэффективно для таких языков, как английский, немецкий, испанский или французский, символы которых могу т легко умещаться в пределах 8 бит. Но такова цена, которую приходится платить за глобальную переносимость.

 Дополнительную информацию о Unicode можно найти на веб-сайте http://www.unicode.org. 

[Chapter03/TypeChar - Работа с типом данных char](https://github.com/Vladlena2/BookJava/blob/main/Chapter3/TypeChar.java "Посмотреть пример Java")

Обратите внимание, что переменной chl присвоено значение 88, которое является кодом ASCII (и Unicode), соответствующим букве Х. Как уже упоминалось, набор символов ASCII занимает первые 127 значений в наборе символов Unicode. По этой причине все "старые уловки'; которые вы могли использовать с символами в других языках, будут работать и в Java.

</details>

Отличие литералов от обычных переменных заключается в том, что литералы представляют фиксированные, неизменяемые значения, заданные непосредственно в исходном коде программы, в то время как переменные представляют хранимые значения, которые могут изменяться в процессе выполнения программы.

<details><summary>Целочисленные литералы</summary>

Любое целочисленное значение является целочисленным литералом. 

В Java, присвоение литеральных значений переменным типов byte и short, находящимся в пределах допустимого диапазона для этих типов, не вызывает ошибку компиляции. Это связано с тем, что литералы, которые входят в допустимый диапазон для byte или short, могут быть неявно преобразованы в эти типы без необходимости явного приведения.

Что касается литералов типа long, то в Java литералы long должны быть явно помечены суффиксом L или l (буква "эль" в верхнем или нижнем регистре), чтобы компилятор понимал, что это именно литерал типа long. Например: 
```html 
long myLong = 9223372036854775807L; // Явно указан литерал типа long с суффиксом "L"
```
Без суффикса L, компилятор может рассматривать литерал как int, и если значение литерала выходит за пределы допустимого диапазона для int, то это вызовет ошибку компиляции. Добавление суффикса L явно указывает компилятору, что литерал относится к типу long.

Указывать целочисленные литералы можно также в двоичной форме, добавляя к значению префикс ОЬ или 0В. Скажем, вот как з адать десятичное значение 10 с помощью двои чного литерала:
```html 
int х = ОЫОlО; 
```
Помимо прочего, добавление двои чных литералов упрощает ввод значений, применяемых в качестве битовых масок. Десяти чное (или шестнадцатери чное) представление значения визуально не передает смысл битовой маски, а двои чный литерал его передает

</details>

<details><summary>Литералы с плавающей точкой</summary>

В научной форме записи числа с плавающей точкой используется стандартный формат, который включает само число и степень, на которую это число умножается. Это формат, который широко используется в научных и инженерных расчетах для представления очень больших или очень маленьких чисел.

Этот формат выглядит следующим образом:
```html 
Число * 10^Показатель_степени
```
- Число - это само число с плавающей точкой, которое вы хотите представить.
- 10 - основание, которое всегда остается неизменным и равно 10, так как мы используем десятичную систему счисления.
- Показатель_степени - это степень 10, на которую число умножается. Этот показатель обозначается буквой "E" или "е", за которой следует целое число. Если это число положительное, то оно указывает на количество десятичных разрядов, на которое нужно сдвинуть десятичную точку вправо. Если число отрицательное, то десятичная точка сдвигается влево на соответствующее количество разрядов.

Примеры:
- 6.022E23 (6.022 * 10^23) - это означает, что число 6.022 умножается на 10 в 23 степени.
- 3.14159E-5 (3.14159 * 10^-5) - это означает, что число 3.14159 умножается на 10 в -5 степени, что эквивалентно делению на 10^5.
- 2e+100 (2 * 10^100) - это означает, что число 2 умножается на 10 в 100 степени.

Литералы с плавающей точкой в Java по умолчанию имеют тип douЫe. 
Для указания литерала типа float к константе необходимо добавить букву F 
или f. Можно также явно указывать литерал douЫe, добавляя букву О или d, 
хотя поступать так излишне. Назначаемый по умолчанию тип douЫe занимает 64 бита памяти, а меньший тип float требует только 32 бита.

Шестнадцатеричные литералы с плавающей точкой в Java записываются с использованием буквы "P" или "p", и они представляют числа в форме, похожей на научную нотацию, но с учетом степени двойки. Важно отметить, что это специфичный формат, который не так часто используется.
Пример:
```html 
0x12.2p2 представляет шестнадцатеричный литерал с плавающей точкой.
```

Разберем этот пример:

- 0x12.2 - это шестнадцатеричное число, которое представляет значение в шестнадцатеричной системе счисления. Здесь 0x указывает, что число записано в шестнадцатеричной форме. 0x12.2 представляет значение, которое равно 18.125 в десятичной системе.
- p2 - это обозначение двоичного показателя степени, где "2" указывает, что число умножается на 2 во второй степени, то есть на 4.

Итак, 0x12.2p2 означает, что значение 18.125 (из шестнадцатеричного числа) умножается на 4 (из двоичного показателя степени), и итоговое значение равно 72.5 в десятичной системе счисления.

</details>

<details><summary>Булевские литералы</summary>
  
Значение типа boolean может иметь только 
два логических значения: true и false. Значения true и false не преобразуются в какое-то числовое представление. Литерал true в Java не равен 1, а литерал false не равен О, т.к. разные типы данных.
  
</details>

<details><summary>Символьные литералы</summary>

В Java можно представить символы в восьмеричной или шестнадцатеричной форме с использованием обратной косой черты (\). Это предоставляет возможность вставлять специальные символы или символы, которые не могут быть набраны с клавиатуры, непосредственно в строковые литералы. Вот как это работает:

Восьмеричная форма записи:
- Для представления символа в восьмеричной форме используйте обратную косую черту (\), за которой следует трехзначное восьмеричное число (от 000 до 377).
Например, '\\141' представляет букву 'а', где 141 - это восьмеричное представление символа 'а'.
Шестнадцатеричная форма записи:
- Для представления символа в шестнадцатеричной форме используйте обратную косую черту и букву 'u' (\u), за которой следуют четыре шестнадцатеричных символа.
Например, '\u0061' представляет символ 'а' из набора символов ISO-Latin-1, где 0061 - это шестнадцатеричное представление символа 'а'.

**Управляющие последовательности символов**

|Управляющая последовательность|Описание|
|:-----------------------------|:-------|
|\ddd|Восьмеричный символ ( ddd) |
|\uxxxx|Шестнадцатеричный символ в Юникоде (.хххх)|
|\'|Одинарная кавычка|
|\"|Двойная кавычка|
|'\'|Обратная косая черта|
|\r|Возврат каретки|
|\n|Новая строка (или перевод строки)|
|\f|Подача страницы|
|\t|Табуляция|
|\b|Возврат на одну позицию ("забой")|

</details>

<details><summary>Строковые литералы</summary>

Как вам может быть известно, в некоторых других языках строки реализуются в виде 
массивов символов. Тем не менее, в Java ситуация иная. Строки на самом деле являются объектными типами. Как вы увидите далее в книге, по причине реализации строк как объектов 
Java обладает обширными возможностями обработки строк, которые характеризуются мощью и простотой использования.
  
</details>
</details>

<details><summary>Переменные</summary>
Переменная служит базовой единицей хранения в программе на Java.

Область видимости, определяемая методом, начинается с его открывающей фигурной скобки. Однако если у метода есть параметры, то они тоже входят в область видимости метода. Область видимости метода заканчивается 
закрывающей фигурной скобкой. Такой блок кода называется телом метода. 

Необходимо запомнить еще один важный момент: переменные создаются 
при входе в их область видимости и уничтожаются при выходе из их области 
видимости. Другими словами, переменная не будет хранить свое значение 
после того, как покинет пределы области видимости. Следовательно, переменные, объявленные в методе, не сохраняют свои значения между вызовами 
этого метода. Кроме того, переменная, объявленная внутри блока, утратит 
свое значение при выходе из блока. Таким образом, время жизни переменной 
ограничено ее областью видимости. 

Когда значение одного типа присваивается переменной другого типа, **автоматическое преобразование** типов происходит в случае удовлетворения следующих двух условий: 
• два типа совместимы; 
• целевой тип больше исходного типа.

**Сужающее преобразование:** требует явного указания, когда тип данных менее широкий, чем целевой тип. Например, преобразование int в byte:
```html 
int x = 300;
byte y = (byte) x; // Сужающее преобразование с явным указанием.
```
Если значение выходит за пределы диапазона целевого типа, оно усекается (по модулю диапазона).

**Усечение при преобразовании с плавающей точкой**: При преобразовании из числа с плавающей точкой в целое число дробная часть усекается.

В следующей программе демонстрируется несколько преобразований типов, требующих приведений:
[Chapter03/Conversion - Преобразования](https://github.com/Vladlena2/BookJava/blob/main/Chapter3/Conversion.java "Посмотреть пример Java")

Вот вывод, генерируемый программой: 
```html 
Преобразование i nt в byte. 
i и Ь: 257 1 
Преобразование douЫe в int . 
d и i: 32 3.142 323 
Преобра зова ние douЬle в byte . 
d и Ь: 32 3.142 67 
```
Давайте обсудим каждое преобразование. Когда значение 257 приводится к типу byte, результатом будет остаток от деления 2 57 на 256 (диапазон 
byte), который в данном случае равен 1. Когда значение переменной d преобразуется в тип int, его дробная часть утрачивается. Когда значение переменной d преобразуется в тип byte, его дробная часть теряется, а значение 
уменьшается по модулю 256, что в этом случае дает 67. 

В Java происходит автоматическое приведение типов, когда операнды арифметических выражений повышаются до определенного уровня (целевого типа), чтобы обеспечить точность и предотвратить потерю данных в результате вычислений. Этот процесс называется преобразованием типов при выполнении (widening, promotion). Он обеспечивает сохранность данных и правильное выполнение арифметических операций.

При выполнении арифметических операций, например, умножения (*), операнды автоматически повышаются до целевого типа. По умолчанию, в Java целевым типом для целых чисел является int. Это означает, что если вы выполняете арифметическую операцию между byte и int, byte будет повышен до int, и результат также будет иметь тип int. Даже если результат выражения может уместиться в byte, он все равно будет иметь тип int.
```html 
byte a = 50;
byte b = 2;
byte result = a * b; // Ошибка компиляции, так как a и b автоматически повышаются до int, и результат также имеет тип int.
```
В данном примере, результат выражения a * b имеет тип int, и поэтому его нельзя присвоить переменной byte без явного приведения (сужения типа).

Это сделано для обеспечения точности и предотвращения потери данных в процессе вычислений. Если вам нужно сохранить результат в переменной типа byte, вы можете явно выполнить приведение типа:
```html 
byte result = (byte) (a * b); // Приведение типа к byte.
```

В Java определено несколько правил повышения типов, которые применяются к выражениям. Вот как они выглядят. Первым делом все значения byte, 
short и char повышаются до int, как только что было описано. Если один 
операнд имеет тип long, то все выражение повышается до long. Если один 
операнд имеет тип float, тогда все выражение повышается до float. Если 
какой-либо из операндов имеет тип douЫe, то результат будет иметь тип 
double. 
</details>

<details><summary>Массивы</summary>
  
**Массив** - это группа переменных одного типа, к которой можно обращаться по общему имени. Можно создавать массивы любого типа с одним или большим количеством измерений.

<details><summary>Одномерные массивы</summary>
Одномерный массив по существу представляет собой список переменных одного типа. 

```html 
переменная-типа-массива = new тип [размер]; 
```
new - это специальная операция, которая выделяет память. 

Здесь тип указывает тип размещаемых в памяти данных, размер устанавливает количество элементов в массиве, а переменная-типа-массива представляет собой переменную, связанную с массивом. То есть, чтобы использовать 
new для размещения массива, вы должны указать тип и количество элементов в 
массиве. 

```html 
month_days = new int [12]; 
```
После выполнения этого оператора month_days будет ссылаться на массив 
из 12 целых чисел. Вдобавок все элементы в массиве будут инициализированы нулем. Имеет смысл повторить: получение массива - двухэтапный процесс. Во-первых, вы обязаны объявить переменную нужного типа массива. Во-вторых, вы должны выделить память, в которой будет храниться массив, с применением операции new и назначить ее переменной типа массива. Таким образом, в Java все массивы размещаются в памяти динамически

[Chapter03/Array - Продемонстрировать применение одномерного массива](https://github.com/Vladlena2/BookJava/blob/main/Chapter3/Array.java "Посмотреть пример Java")

[Chapter03/CountDayArray - Усовершенствованная версия предыдущей программы](https://github.com/Vladlena2/BookJava/blob/main/Chapter3/CountDayArray.java "Посмотреть пример Java")


</details>

<details><summary>Многомерные массивы</summary>
Многомерные массивы в Java реализованы как массивы массивов.

[Chapter03/DuoArray - Пример двумерного массива](https://github.com/Vladlena2/BookJava/blob/main/Chapter3/DuoArray.java "Посмотреть пример Java")

[Chapter03/ThreeArray - Пример трехмерного массива](https://github.com/Vladlena2/BookJava/blob/main/Chapter3/ThreeArray.java "Посмотреть пример Java")
  
Хотя в такой ситуации индивидуальное размещение массивов второго измерения не дает каких-то преимуществ, в других случаях такие преимущества 
могут быть. Скажем, при выделении памяти под измерения по отдельности 
вам не нужно размещать одинаковое количество элементов для каждого измерения. Как утверждалось ранее, поскольку многомерные массивы на самом 
деле являются массивами массивов, длина каждого массива находится под 
вашим контролем. Например, в следующей программе создается двумерный 
массив, в котором размеры массивов во втором измерении не равны:

[Chapter03/TwoDAgain - Резервирование памяти вручную для массива с разной размерностью второго измерения]([https://github.com/Vladlena2/BookJava/blob/main/Chapter3/TwoDAgain.java "Посмотреть пример Java")

Ст упенчатые (или нерегулярные) многомерные массивы могут оказаться 
неподходящими для многих приложений, потому что они противоречат тому, 
что люди ожидают найти при встрече с многомерным массивом. Однако в некоторых ситуациях нереrу лярные массивы можно эффективно использовать. 
Скажем, если вам нужен очень большой разреженный двумерный массив (т.е. 
такой, rде задействованы не все элементы), тогда нерегулярный массив может стать идеальным решением

Также обратите внимание, что внутри инициализаторов массивов можно применять выражения и литеральные значения. 

Существует вторая форма объявления массива:
```html 
тип имя-переменной[ ];
char twodl[][] = new char[3][4] ;  
```
Эта альтернативная форма объявления обеспечивает удобство при преобразовании кода из С/С++ в Java. Кроме того, она позволяет объявлять в одном операторе объявления и переменные с типами массивов, и переменные 
с типами, отличающимися от массивов. В настоящее время альтернативная 
форма используется реже, но знать ее по-прежнему важно, поскольку в Java 
разрешены обе формы объявления массивов. 

</details>
</details>

<details><summary>Знакомство с выведением типов локальных переменных</summary>
  
В Java, начиная с версии 10, была внедрена возможность автоматического выведения типов локальных переменных. Это означает, что в некоторых случаях компилятор может определить тип переменной на основе значения, которое ей присваивается. Это упрощает объявление переменных и делает код более читаемым и компактным.

```html 
var variableName = assignedValue;
```
- var: ключевое слово, которое заменяет объявление типа переменной.
- variableName: имя переменной.
- assignedValue: значение, которое присваивается переменной.

Примеры использования:

1. Инференция типа с примитивами
```html 
var number = 10; // number имеет тип int.
var pi = 3.14159; // pi имеет тип double.
```
2. Инференция типа с объектами
```html 
var message = "Hello, World!"; // message имеет тип String.
var list = new ArrayList<Integer>(); // list имеет тип ArrayList<Integer>.
```
3. Инференция типа в циклах
```html 
var numbers = new int[] { 1, 2, 3, 4, 5 };
for (var number : numbers) {
    // number имеет тип int внутри цикла.
}
```
4. Смешанное использование с объявлением типа
```html 
var x = 5; // x имеет тип int.
int y = 10;
var result = x + y; // result имеет тип int.
``` 
5. Инференция типа с массивами
```html 
var numbers = new int[] { 1, 2, 3, 4, 5 }; // numbers имеет тип int[].
var names = new String[] { "Alice", "Bob", "Charlie" }; // names имеет тип String[].
``` 
6. Смешанное использование инференции типа и объявления типа
```html 
var scores = new int[] { 90, 85, 78 };
int[] grades = { 88, 92, 76 };
```

**Ограничения.** Можно 
объявлять только одну переменную за раз, для переменной нельзя использовать null в качестве инициализатора и объявляемая переменная не может 
присутствовать в выражении инициализатора. Хотя с применением var можно объявить тип массива, ключевое слово var нельзя использовать с инициализатором массива. 
Как отмечалось ранее, ключевое слово var не разрешено применять для 
имени класса. Его также не допускается использовать в качестве имени других ссылочных типов, включая интерфейс, перечисление или аннотацию, 
либо в качестве имени параметра обобщенного типа. Выведение типов локальных переменных нельзя применять для объявления типа исключения, перехваченного оператором 
catch. Кроме того, ни лямбда-выражения, ни ссылки на методы не разрешено использовать в качестве инициализаторов.
</details>

</blockquote>
</details>

<details ГЛАВА 4><summary>ГЛАВА 4. "Операции"</summary>
<blockquote>

<details><summary>Арифметические операции</summary>

Основные арифметические операции - сложение, вычитание, умножение 
и деление - ведут себя так, как и следовало ожидать для всех числовых типов. Унарный минус инвертирует свой единственный операнд. Унарный плюс 
просто возвращает значение своего операнда. Помните, что когда операция 
деления применяется к целочисленному типу, дробная часть к результату не 
присоединяется.

[Chapter04/BasicMath - Продемонстрировать основные арифметические операции](https://github.com/Vladlena2/BookJava/blob/main/Chapter4/BasicMath.java "Посмотреть пример Java")

[Chapter04/Modulus - Операция деления по модулю "%" (возвращает остаток от деления)](https://github.com/Vladlena2/BookJava/blob/main/Chapter4/Modulus.java "Посмотреть пример Java")

Составные операции присваивания обеспечивают два преимущества. Во-первых, они уменьшают объем набираемоrо кода, потому что являются "сокращенной формой" для своих длинных эквивалентов. Во-вторых, в некоторых случаях они более эффективны, чем их длинные эквиваленты. По указанным причинам составные операции присваивания часто используются в профессионально написанных программах на Java. 

[Chapter04/OpEquals - Составные операции с присваиванием](https://github.com/Vladlena2/BookJava/blob/main/Chapter4/OpEquals.java "Посмотреть пример Java")

Операции инкремента и декремента. Приведенные операции уникальны тем, что могут встречаться и в постфиксной форме, когда они следуют за операндом, как было только что показано, и в префиксной форме, когда они предшествуют операнду. В предшествующих примерах никаких отличий между префиксной и постфиксной формами 
не было. Однако когда операторы инкремента и/или декремента входят в состав более крупного выражения, то между этими двумя формами проявляется тонкая, но важная разница. В префиксной форме операнд инкрементируется или декрементируется перед получением значения для использования 
в выражении. В постфиксной форме предыдущее значение извлекается для 
применения в выражении, после чего модифицируется операнд. Например:

```html 
х = 42; 
у = ++х;
равно
х = х + 1; 
у = х; 
```

```html 
х = 42; 
у = х++; 
равно
у = х; 
х = х + 1;
```
</details>

<details><summary>Побитовые операции</summary>

**Поразрядные операции в Java**
```  
"~"    - Поразрядная унарная операция НЕ  
"&"    - Поразрядная логическая операция И  
"|"    - Поразрядная логическая операция ИЛИ  
"^"    - Поразрядная логическая операция исключающее ИЛИ  
">>"   - Сдвиг вправо  
">>>"  - Сдвиг вправо с заполнением нулями  
"<<"   - Сдвиг влево  
"&="   - Поразрядная логическая операция И с присваиванием  
"|="   - Поразрядная логическая операция ИЛИ с присваиванием  
"^="   - Поразрядная логическая операция исключающее ИЛИ с присваиванием  
">>="  - Сдвиг вправо с присваиванием  
">>>=" - Сдвиг вправо с заполнением нулями и присваиванием  
"<<="  - Сдвиг влево с присваиванием  
```

В Java используется кодировка, известная как доnоанение до двух или 
доnоАнumеАьный код, которая предусматривает представление отрицательных 
чисел путем инвертирования (замены единиц на нули и наоборот) всех битов в значении и последующего добавления единицы к результату. Например, 
для представления -42 инвертируются все биты в 42, или 00101010, что дает 
1 1010101, после чего к результату добавляется 1, давая в итоге 1 1010110, или 
-42. Чтобы декодировать отрицательное число, необходимо инвертировать 
все биты и добавить 1. Например, -42, или 1 10101 10, в результате инвертирования дает 00101001, или 41, а после добавления 1 получается 42

Особенности представления нуля и отрицательных чисел для значений типа byte (и других целочисленных типов).

Для представления нуля в дополнительном коде, инвертируете все биты, и в результате получаете "11111111". Это инвертированное представление нуля, которое обычно не используется в целочисленной арифметике.

Для решения этой проблемы и представления отрицательных значений используется дополнение до двух. Когда к инвертированному значению добавляется 1, возникает следующее:

"11111111" (инвертированное значение) + 1 = "100000000"
Однако, восьмой бит (самый левый бит) в byte не умещается, и он обрезается. Таким образом, "100000000" на самом деле становится "00000000" в byte, что является представлением нуля в дополнительном коде до двух. Это "ноль" совпадает с нулем, и весьма удобно для работы в целочисленной арифметике.

Этот метод представления нуля и отрицательных чисел позволяет правильно работать с арифметикой и легко определять граничные случаи.

Во избежание неприятных сюрпризов 
просто помните, что старший бит определяет знак целого числа независимо 
от того, как он был установлен. 

[Chapter04/BitLogic - Продемонстрировать применение поразрядных логических операций](https://github.com/Vladlena2/BookJava/blob/main/Chapter4/BitLogic.java "Посмотреть пример Java")

**Сдвиг влево**

Здесь число устанавливает количество позиций для сдвига влево значения. 
То есть операция << перемещает все биты в указанном значении влево на 
количество битовых позиций, заданное в числе. При каждом сдвиге влево 
старший бит смещается (и утрачивается), а справа вставляется ноль. Это означает, что когда к операнду int применяется сдвиг влево, биты теряются, 
как только они сдвигаются за битовую позицию 31. В случае операнда типа 
long биты утрачиваются после битовой позиции 63. 
При сдвиге значений byte и short автоматическое повышение типов в 
Java приводит к неожиданным результатам. Как вы знаете, во время вычисления выражения значения byte и short повышаются до int. Кроме того, результат такого выражения тоже имеет тип int. Это означает, что результатом 
сдвига влево значения byte или short будет значение int, а биты, сдвинутые 
влево, не будут утрачены до тех пор, пока они не сместятся за битовую позицию 31. Вдобавок отрицательное значение byte или short при повышении до 
int будет расширено знаком. Таким образом, старшие биты будут заполнены 
единицами. По указанным причинам выполнение сдвига влево значения byte 
или short подразумевает необходимость отбрасывания старших байтов из 
результата типа int. Например, при сдвиге влево значения byte оно сначала 
повышается до int, после чего сдвигается. Если нужно получить результат 
сдвинутого значения byte, то придется отбросить три старших байта результата. Самый простой способ решить задачу - преобразовать результат обратно в byte.

**Сдвиг вправо**

При выполнении сдвига вправо старшие (крайние слева) биты, открытые 
сдвигом, заполняются предыдущим содержимым старшего бита. Это называется расширением знака и служит для сохранения знака отрицательных чисел 
при их сдвиге вправо. Например, -8 >> 1 равно -4, что в двоичном виде выглядит так: 

```html 
1111 1000 -8 
>> 1 
11111 100 -4 
```

Интересно отметить, что в случае сдвига вправо значения -1 результат 
всегда остается -1, т.к. расширение знака будет приводить к большему количеству единиц в старших битах. 
Иногда расширять знаки значений при сдвиге вправо нежелательно. 

Скажем, в приведенной далее программе значение byte преобразуется в 
шестнадцатеричное строковое представление. Обратите внимание, что сдвинутое значение маскируется с помощью операции И с 0x0f для отбрасывания 
любых битов, дополненных знаком, чтобы значение можно было использовать в качестве индекса в массиве шестнадцатеричных символов. 

[Chapter04/HexByte - Маскирование двоичных разрядов расширения знака](https://github.com/Vladlena2/BookJava/blob/main/Chapter4/HexByte.java "Посмотреть пример Java")

**Беззнаковый сдвиг вправо**
Как только что объяснялось, операция >> автоматически заполняет старший бит его предыдущим содержимым каждый раз, когда происходит сдвиг, 
сохраняя знак значения. Тем не менее, иногда это нежелательно. Например, 
при выполнении сдвига чего-то, что не представляет собой числовое значение, расширение знака может оказаться ненужным. Такая ситуация часто встречается при работе с пиксельными значениями и графикой. В ситуациях 
подобного рода обычно требуется помещать в старший бит ноль вне зависимости от того, каким было его начальное значение. Прием известен как беззнаковый сдвиг и предусматривает применение операции беззнакового сдвига 
вправо, >>>, которая всегда задвигает нули в старший бит. 
аво, >>>, которая всегда задвигает нули в старший бит. 

В следующем фрагменте кода демонстрируется работа операции >>>. 
Здесь значение а устанавливается в -1, что приводит к установке всех 32 бит 
в 1. Затем значение сдвигается вправо на 24 позиции с заполнением старших 
24 бит нулями и игнорированием расширения знака. В итоге а устанавливается в 255. 

```html 
int a = -1; 
а = а >>> 24;
```

Ниже показана та же самая операция в двоичной форме с целью дополнительной иллюстрации того, что происходит:
```html 
11111111 11111111 11111111 11111111 -1 в двоичном виде
>>24 
00000000 00000000 00000000 11111111 255 в двоичном виде
```
Операция >>> часто не настолько полезна, как хотелось бы, поскольку 
она имеет смысл только для 32- и 64-битных значений. Вспомните, что при 
вычислении выражений меньшие значения автоматически повышаются до 
int. В итоге происходит расширение знака, и сдвиг будет выполняться над 
32-битным, а не 8- или 16-битным значением. То есть можно ожидать, что 
беззнаковый сдвиг вправо значения byte заполнит нулями, начиная с бита 7. 
Но это не так, поскольку на самом деле сдвигается 32-битное значение. 
Эффект демонстрируется в следующей программе:


[Chapter04/ByteUShift - Сдвиг влево значения типа byte](https://github.com/Vladlena2/BookJava/blob/main/Chapter4/ByteUShift.java "Посмотреть пример Java")

В показанном ниже выводе программы видно, что при работе с байтами 
операция >>> ничего не делает. Для данной демонстрации переменной Ь присваивается произвольное отрицательное значение типа byte. Затем переменной с присваивается значение Ь типа byte, сдвинутое вправо на четыре позиции, которое равно Oxff из-за ожидаемого расширения знака. Далее 
переменной d присваивается значение Ь типа byte с беззнаковым сдвигом 
вправо на четыре позиции, которым вопреки ожидаемому OxOf будет Oxff 
по причине расширения знака, происшедшего при повышении Ь до int перед сдвигом. Последнее выражение устанавливает переменную е в значение 
Ь типа byte, маскированное до 8 бит с помощью операции И, после чего 
сдвинутое вправо на четыре позиции, что дает ожидаемое значение OxOf. 
Обратите внимание, что операция беззнакового сдвига вправо не использовался для переменной d, т.к. состояние знакового бита после операции И 
было известно. 

Сравнение знакового и беззнакового сдвига:

```html 
int value = -8;  // Значение -8
int result = value >> 1;  // Знаковый сдвиг вправо на 1 бит
System.out.println("Результат: " + result);
```
В этом примере, value равно -8, а value >> 1 сдвигает значение на 1 бит вправо. Ожидается, что результат будет -4, потому что знаковый сдвиг сохраняет знак (в данном случае, отрицательный).

```html 
int value = -8;  // Значение -8
int result = value >>> 1;  // Беззнаковый сдвиг вправо на 1 бит
System.out.println("Результат: " + result);
```
Результат беззнакового сдвига >>> будет положительным числом 2147483644, что произошло из-за того, что знаковый бит был сброшен. Это демонстрирует разницу между знаковым и беззнаковым сдвигами. В контексте данного вопроса о беззнаковых сдвигах, можно сказать, что они "избегают влияния знакового бита".

</details>

<details><summary>Операции отношения</summary>

**Операции отношения(сравнения)**
```
"=="   - Равно  
"!="   - Не равно  
">"    - Больше
"<"    - Меньше  
">="   - Больше или равно  
"<="   - Меньше или равно
```

Результатом этих операций является значение boolean. Операции отношения чаще всего используются в выражениях, управляющих оператором i f и 
различными операторами циклов. 

Как уже упоминалось, результатом операции отношения будет значение 
boolean. Например, следующий фрагмент кода совершенно корректен:

```html 
int а= 4; 
int Ь = 1; 
boolean с = а < Ь;
```
В данном случае в переменной с сохраняется результат выполнения а<Ь 
(равный false). 

Если ранее вы работали с С/С++, то обратите внимание, что в программах 
на С/С++ весьма распространены следующие виды операторов:

```html 
int done; 
// ... 
if ( ! done ) // Допустимо в С/ С++ ,  
if ( done) // но не в Java
```

В коде Java такие операторы должны быть записаны так, как показано ниже: 

```html 
if ( done == О ) // Стиль Java . 
if (done != О) 
```
Причина в том, что истинное и ложное значения в Java определены не так, 
как в С/С++. В языках С и С++ истинным является любое ненулевое значение, а ложным - ноль. В Java true и false представляют собой нечисловые значения, которые никак не связаны с нулем или ненулевым значением. 
Следовательно, для проверки на предмет равенства или неравенства нулю 
должна явно применяться одна или несколько операций отношения. 

**Логические операции**
```
&  - Логическая операция И  
|  - Логическая операция ИЛИ  
^  - Логическая операция исключающее ИЛИ  
|| - Укороченная логическая операция ИЛИ  
&& - Укороченная логическая операция И  
!  - Логическая унарная операция НЕ  
&= - Логическая операция И с присваиванием  
|= - Логическая операция ИЛИ с присваиванием  
^= - Логическая операция исключающее ИЛИ с присваиванием  
== - Равенство  
!= - Неравенство  
?: - Тернарная условная операция типа если"., то"., иначе".
```

В языке Java померживаются две интересные булевские операции, отсутствующие в ряде других языков программирования. Речь идет о вспомогательных версиях булевских операций И и ИЛИ, широко известные как 
короткозамкнутые логические операции. В табл. легко заметить, что результатом операции ИЛИ будет true, когда А имеет значение t rue вне зависимости от значения В. Аналогично операция И дает результат false, когда 
А равно false безотносительно к тому, какое значение имеет В. В случае применения форм || и && вместо форм | и & указанных операций Java правый 
операнд не будет вычисляться в ситуации, когда результат выражения может 
быть определен только левым операндом. Это очень полезно, когда правильное функционирование предусматривает зависимость правого операнда от 
левого. В приведенном ниже фрагменте кода показано, как можно использовать в своих интересах короткозамкнутое логическое вычисление, чтобы 
убедиться в допустимости операции деления до ее выполнения:

```html 
if (denom 1 = О && num / denom > 10)
```

Поскольку применяется короткозамкнутая форма операции И (&&), нет 
риска вызвать исключение во время выполнения, когда переменная denom 
равна нулю. Если бы данная строка кода была написана с использованием 
односимвольной версии операции &, то вычислялись бы обе стороны выражения, приводя к исключению во время выполнения, когда значение denom 
равно нулю. 
Стандартная практика предусматривает применение короткозамкнутых 
форм И и ИЛИ в случаях, связанных с булевской логикой, оставляя односимвольные версии исключительно для побитовых операций. Однако из этого правила есть исключения. Например, взгляните на оператор следующего 
вида: 

```html 
if (c==1 & е++ < 100) d = 100;
```
 
Здесь использование версии & гарантирует, что операция инкремента будет применена к е независимо от того, имеет переменная с значение 1 или нет.

## Операция ?

В Java предусмотрена специальная тернарная операция, которая способна 
з аменить определенные виды операторов "если-то-иначе': Она обозначается 
с помощью знака ?.

Вот общий вид операции ?: 

```html 
выражение1 ? выражение2 : выражениеЗ
```

десь выражение1 может быть л юбым выражением, результатом которого является значение boolean. Если результатом выражения1 является true, 
тогда вычисляется выражение2, а иначе выражениеЗ. Результатом операции ? 
будет результат вычисленного выражения. Типы результатов выражения2 и 
выражениеЗ должны быть одинаковыми (или совместимыми) и не могут быть 
void. Ниже показан пример применения операции ?: 

```html 
ratio = denom == О ? О : num / denom; 
```

При вычислении этого выражения присваивания сначала просматривается 
выражение слева от вопросительного знака. Если значение denom равно нулю, 
тогда вычисляется выражение между вопросительным знаком и двоеточием 
и используется в качестве значения всего выражения ?. Если значение denom 
не равно нулю, то вычисляется выражение после двоеточия и становится значением всего выражения ?. Затем результат операции ? присваивается переменной ratio. 

[Chapter04/Ternary - Продемонстрировать применение тернарной операции "?"](https://github.com/Vladlena2/BookJava/blob/main/Chapter4/Ternary.java "Посмотреть пример Java")

## Старшинство операций

Вот некоторые основные операторы Java, упорядоченные по приоритету (от более высокого приоритета к более низкому):

1. Постфиксные операторы: expr++, expr-- (например, инкремент и декремент).
2. Префиксные операторы: ++expr, --expr, +expr, -expr, !expr, ~expr (например, инкремент, декремент, унарный плюс, унарный минус и т. д.).
3. Умножение и деление: *, /, % (умножение, деление и остаток от деления).
4. Сложение и вычитание: +, -.
5. Сдвиги: <<, >>, >>> (побитовые сдвиги влево и вправо).
6. Отношения: <, >, <=, >=, instanceof.
7. Равенство: ==, !=.
8. Побитовое "И": &.
9. Побитовое "ИЛИ": |.
10. Побитовое "Исключительное ИЛИ": ^.
11. Логическое "И" (AND): &&.
12. Логическое "ИЛИ" (OR): ||.
13. Условный оператор: ? :.
14. Присваивание: =, +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=, >>>=.
15. Выражение запятой: , (для последовательного выполнения выражений).

Если операции имеют одинаковый приоритет, то их выполнение определяется ассоциативностью (слева направо или справа налево). Например, операции сложения и вычитания выполняются слева направо, поэтому a + b - c будет интерпретировано как (a + b) - c.

И еще один момент: круглые скобки (избыточные или нет) не ухудшают 
производительность программы. Таким образом, добавление круглых скобок 
для уменьшения неоднозначности не повлияет отрицательно на вашу программу.

</details>

</blockquote>
</details>

<details ГЛАВА 5><summary>ГЛАВА 5. "Управляющие операторы"</summary>
<blockquote>

<details><summary>Операторы выбора</summary>

## Оператор switch 

Как функционирует традиционный оператор switch: з начение 
выражения сравнивается с каждым значением в операторах case. Если совпадение найдено, то выполняется кодовая последовательность, следующая 
за оператором case. Если ни одна из констант не соответствует значению 
выражения, тогда выполняется оператор default. Однако оператор default 
необязателен. Если ни один из операторов case не дает совпадения, а оператор default отсутствует, то дальнейшие действия не предпринимаются.

Иногда желательно иметь несколько case без операторов break 
между ними. 

[Chapter05/MissingBreak - Продемонстрировать применение case без операторов break ].(https://github.com/Vladlena2/BookJava/blob/main/Chapter5/MissingBreak.java "Посмотреть пример Java")

Ниже демонстрируется его более реалистичное использование в 
переработанной программе определения принадлежности месяца к временам 
года. Теперь в нем применяется оператор switch для обеспечения более эффективной реализации. 

[Chapter05/Switch - Продемонстрировать более реалистичное использование case без операторов break ].(https://github.com/Vladlena2/BookJava/blob/main/Chapter5/Switch.java "Посмотреть пример Java")

Возможность применения строк в операторе switch упрощает код во многих ситуациях. Скажем, использовать switch на основе строк эффективнее 
по сравнению с эквивалентной последовательностью операторов if/еlsе. 
Тем не менее, выполнение оператора switch по строкам может оказаться более затратным, чем по целым числам. Таким образом, лучше всего применять 
switch на основе строк только в тех случаях, когда управляющие данные уже 
представлены в строковой форме. Другими словами, не используйте строки в 
switch без настоятельной необходимости. 

Вы можете применять switch как часть последовательности операторов 
внешнего switch. Он называется вложенным оператором switch. Поскольку 
оператор swi tch определяет собственный блок, между константами case 
во внутреннем switch и во внешнем switch конфликты не возникают. 

Подводя итоги, важно отметить три особенности оператора switch. 

• Оператор switch отличается от if тем, что он может проверять только 
на предмет равенства, тогда как оператор if способен оценивать логическое выражение любого вида. То есть switch ищет только совпадение 
значения выражения с одной из констант в операторах case. 

• Никакие две константы case в одном switch не могут иметь одинаковые значения. Разумеется, один оператор switch и включающий его 
внешний switch могут иметь общие константы case. 

• Оператор switch обычно более эффективен, чем набор вложенных операторов i f. 
Последний пункт особенно интересен, потому что он дает представление о 
том, как работает компилятор Java. При компиляции оператора switch компилятор Java проверит каждую константу case и создаст "таблицу переходов'; 
которую будет использовать для выбора пути выполнения в зависимости от 
значения выражения. Следовательно, есл и вам нужно делать выбор среди 
большой группы значений, то оператор switch будет работать намного быстрее, чем эквивалентная логика, реализованная с применением последовательности if-else. Компилятор способен добиться этого, т.к. ему известно, 
что все константы case имеют один и тот же тип и просто должны сравниваться на равенство с выражением switch. Что касается подобного знания 
длинного списка выражений if, то компилятор им не располагает.

</details> 

<details><summary>Операторы выбора</summary>

## Цикл while 

Тело цикла while (или любого дpyroro цикла Java) может быть пустым. 
Дело в том, что в Java синтаксически допустим пустой оператор (состоящий 
только из точки с запятой). Взгляните на следующую программу: 

[Chapter05/NoBody - Продемонстрировать пустой while].(https://github.com/Vladlena2/BookJava/blob/main/Chapter5/NoBody.java "Посмотреть пример Java")

Рассмотрим, как работает этот цикл while. Значение i инкрементируется, 
а значение j декрементируется. Затем значения i и j сравниваются друг с 
другом. Если новое з начение i все еще меньше нового значения j, тогда цикл 
повторяется. Если значение i больше или равно значения j, то цикл останавливается. После выхода из цикла переменная i будет хранить значение, которое находится посередине между исходными значениями i и j. (Конечно, такая процедура работает только тогда, когда i меньше j .) Понятно, что здесь 
нет необходимости иметь тело цикла; все действие происходит внутри самого условного выражения. В профессионал ьно написанном коде на Java короткие циклы часто кодируются без тел, коrда управляющее выражение способно самостоятельно обрабатывать все детали. 

Как вы только что видели, если условное выражение, управляющее циклом 
while, изначально ложно, то тело цикла вообще не будет выполнено. Однако 
иногда тело цикла желател ьно выполнить хотя бы один раз, даже если изначально условное выражение ложно. Другими словами, бывают случаи, когда 
вы хотели бы проверять выражение завершения в конце цикла, а не в ero начале. К счастью, в Java есть цикл, который делает именно это: do-while.

## Цикл for 

Рассмотрим работу цикла for. При первом запуске цикла выполняется 
часть инициализация цикла. В общем случае она представляет собой выражение, которое устанавливает значение переменной управления циклом, которая действует в качестве счетчика, управляющего циклом. Важно понимать, 
что инициализирующее выражение выполняется только один раз. Затем вычисляется условие, которое должно быть булевским выражением. Как правило, оно сравнивает переменную управления циклом с целевым значением. 
Есл и условие истинно, тогда выполняется тело цикла, а если ложно, то цикл 
завершается. Далее выполняется часть итерация цикла, которая обычно является выражением, инкрементирующим или декрементирующим перенную управления циклом. После этого цикл повторяется, при каждом проходе 
вычисляя условное выражение, выполняя тело цикла и вычисляя выражение 
итерации. Такой процесс происходит до тех пор, пока управляющее выражение не станет ложным. 


При объявлении переменной внутри цикла for следует помнить об одном 
важном аспекте: область видимости этой переменной ограни чена циклом 
for. За пределами цикла for переменная перестает существовать. Если переменную управления циклом необходимо применять в другом месте программы, тогда объявлять ее внутри оператора for нельзя.

Чтобы позволить двум и более переменным управлять циклом for, в части инициализация и итерация цикла for разрешено 
включать несколько операторов, разделяя их запятыми. 

Есть еще одна интересная разновидность цикла for, в которой может отсутствовать либо часть инициализация, либо часть итерация, либо то и другое, как демонстрируется в следующей программе

## Цикл for-each

Общая форма версии "for-each" цикла for выглядит следующим образом: 
for ( тип переменная-итерации : коллекция) блок-операторов 
Здесь тип указывает тип, а переменная-итерации - имя переменной 
итерации, которая будет получать элементы из коллекции по одному за 
раз, от начала до конца. Коллекция, по которой проходит цикл, указывается в коллекции. Существуют различные типы коллекций, которые можно использовать с for, но в настоящей главе применяется только массив.
На каждой итерации цикла из коллекции из влекается очередной элемент и сохраняется в 
переменной-итерации. Цикл повторяется до тех пор, пока не будут получены 
все элементы коллекции. 
Поскольку переменная итерации получает з начения из коллекции, тип 
обязан совпадать или быть совместимым с типом элементов, хранящихся в коллекции. Таким образом, при проходе по массивам тип должен быть совместимым с типом элементов массива.

Чтобы понять мотивы создания цикла в стиле "for-each'; рассмотрим тип 
цикла for, который он призван заменить. В следующем фрагменте кода для 
вычисления суммы значений в массиве применяется традиционный цикл for:
```html 
int [] nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 1 0 } ; 
int sum = О; 
for ( int i=0 ; i < 10 ; i++ ) sum += nums [i]; 
```

Стиль "for-each" цикла for позволяет автоматизировать предыдущий цикл. 
В частности, он избавляет от необходимости устанавливать счетчик циклов, 
указывать начальное и конечное значение и вручную индексировать массив. 
Взамен он автоматически проходит по всему массиву, получая по одному элементу за раз, последовательно, от начала до конца. Например, вот предыдущий фрагмент, переписанный с применением версии цикла for в стиле "for-each": 
```html 
int [] nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 } ; 
int sum = О; 
for ( int х: nums ) sum += х;
```

При каждом проходе цикла переменной х автоматически присваивается 
значение, равное очередному элементу в nums. Таким образом, на первой итерации х содержит 1, на второй - 2 и т.д. Синтаксис не только стал проще, но 
он также предотвращает возникновение ошибок выхода за границы массива.

Существует один аспект, касающийся цикла for в стиле "for-each'; который важно понимать. Его переменная итерации доступна только для чтения, 
хотя она связана с лежащим в основе массивом. Присваивание значения переменной итерации не влияет на лежащий в основе массив. Другими словами, 
изменить содержимое массива, присваивая переменной итерации новое значение, не удастся. 

Расширенная версия for работает также и с мноrомерными массивами. 
Но не забывайте о том, что мноrомерные массивы в Java представляют собой массивы массивов. (Например, двумерный массив - это массив одномерных массивов.) Данный факт важен при проходе по многомерному массиву, 
поскольку на каждой итерации получается очередной массив, а не индивидуальный элемент. Кроме тоrо, переменная итерации в цикле for должна быть 
совместимой с типом пол учаемоrо массива. Например, в случае двумерноrо 
массива переменная итерации должна быть ссылкой на одномерный массив.

```html 
for (int [] х : nums ) { 
for ( i nt у: х) { 
System.out.println ( " Знaчeниe : "+у); 
sum += у; 
System.out.println ( "Сумма : " + sum ) ; 
```

Обратите внимание на то, как объявлена переменная х. Она является 
ссылкой на одномерный массив целых чисел. Необходимость в таком объявлении связана с тем, что на каждой итерации цикла for получается очередной массив из nums, начиная с массива nums[0]. Затем во внутреннем цикле 
for производится проход по каждому из этих массивов с отображением значения каждого элемента. 

Выведение типов локальных 
переменных можно применять в цикле for при объявлении и инициализации 
переменной управления циклом внутри традиционноrо цикла for или при 
указании переменной итерации в цикле for в стиле "for-each': В следующей 
проrрамме демонстрируются примеры каждою случая: 

[Chapter05/TypeInFerenceInFor - Продемонстрировать пустой while].(https://github.com/Vladlena2/BookJava/blob/main/Chapter5/TypeInFerenceInFor.java "Посмотреть пример Java")

</details> 

<details><summary>Операторы перехода</summary>

В Java поддерживаются три оператора перехода: break, continue и return. 

Помимо обсуждаемых здесь операторов перехода в Java есть еще один способ, с 
помощью котороrо можно изменить поток выполнения программы: через обработку 
исключений. Обработка исключений обеспечивает структурированный подход, с помощью 
которого программа может перехватывать и обрабатывать ошибки во время выполнения. 
Он поддерживается ключевыми словами try, catch, throw, throws и finally. По 
существу механизм обработки исключений позволяет программе выполнять нелокальный 
переход. Поскольку обработка исключений является обширной темой, она обсуждается 
отдельно в главе 1О. 

## Оператор break

Оператор break в языке Java применяется в трех ситуациях. Во-первых, 
как вы видели, он завершает последовательность операторов в операторе 
swi tch. Во-вторых, его можно использовать для выхода из цикла. В-третьих, 
его можно применять как "цивилизованную" форму перехода в стиле "goto'.

Однако будьте осторожны. Слишком большое количество операторов break 
способно деструктурировать код. Во-вторых, оператор break, завершающий 
switch, влияет только на этот оператор switch, но не на любые объемлющие 
циклы. 

Оператор break не задумывался как обычное средство завершения цикла. Для этой цели 
предназначено условное выражение цикла. Оператор break должен применяться для 
прекращения работы цикла только в случае возникновения какой-то особой ситуации. 

В дополнение к применению с оператором switch и циклами оператор 
break также может использоваться сам по себе, чтобы обеспечить "цивилизованную" форму перехода в стиле "goto': В языке Java нет оператора "goto'; т.к. 
он обеспечивает возможность ветвления произвольным и неструктурированным образом, что обычно затрудняет понимание и сопровождение кода, опирающегося на переходы в стиле "goto': Кроме того, "goto" препятствует некоторым оптимизациям со стороны компилятора. Тем не менее, есть несколько 
мест, где переходы в стиле "goto" будут ценной и законной конструкцией для 
управления потоком. Например, переход в стиле "goto" может быть полезен 
при выходе из глубоко вложенных циклов. Для обработки таких ситуаций в 
Java определена расширенная форма оператора break. С применением такой 
формы break можно, например, выходить из одного или нескольких блоков 
кода, которые не обязательно должны являться частью цикла или переключателя, а могут быть любыми. Более того, можно точно указывать, где будет 
возобновлено выполнение, т.к. расширенная форма оператора break работает с меткой. Как вы увидите, break обеспечивает преимущества перехода в 
стиле "goto" без присущих ему проблем. 

Чаще всего метка представляет собой имя маркера, идентифицирующего 
блок кода. Блок кода может быть как автономным, так и блоком, являющимся целью другого оператора. При выполнении расширенной формы оператора break поток управления покидает блок, указанный в break. Снабженный 
меткой блок должен охватывать оператор break, но не обязательно быть тем, 
который содержит в себе этот break непосредственно. Отсюда следует, на пример, что оператор break с меткой можно использовать для выхода из набора вложенных блоков. Но применять break для передачи управления из 
блока, который не охватывает данный оператор break, нельзя. 
Чтобы назначить блоку имя, необходимо поместить в его начало метку. 
Метка - это любой допустимый идентификатор Java, за которым следует 
двоеточие. После пометки блока метку можно использовать в качестве цели 
оператора break, что приведет к возобновлению выполнения после конца 
помеченного блока. Например, в показанной далее программе реализованы 
три вложенных блока, каждый со своей меткой. Оператор break передает 
управление вперед, за конец блока с меткой second, пропуская два оператора 
println(). 

[Chapter05/BreakLoop4 - Продемонстрировать пустой while].(https://github.com/Vladlena2/BookJava/blob/main/Chapter5/BreakLoop4.java "Посмотреть пример Java")

Имейте в виду, что использовать оператор break с меткой, которая определена не для охватывающего блока, не разрешено. Например, следующая 
программа содержит ошибку и компилироваться не будет: 

```html 
// Эта программа содержит ошибку . 
class BreakErr { 
public static void main(String[] args ) 
one: for (int i=O ; i<З ; i++ ) { 
System.out.print( " Пpoxoд " + i + "· " ) ; 
for (int j = O; j<lOO; j ++) { 
if (j == 10) break one ; // ОШИБКА 
System.out.print (j +" " ) ; 
}
}
}
```

Поскольку цикл, помеченный как one, не охватывает оператор break, передать управление из этого блока невозможно

## Оператор continue

Иногда необходимо обеспечить, чтобы итерация цикла выполнилась 
раньше, до достижения конца тела. То есть выполнение цикла должно продолжаться, но без обработки остатка кода в его теле для конкретной итерации. По сути, это переход в конец цикла. Такое действие реализует оператор 
continue. В циклах while и do-while оператор conti nue передает управление напрямую условному выражению, управляющему циклом. В цикле for 
управление передается сначала итерационной части оператора for, а затем 
условному выражению. Для всех трех циклов любой промежуточный код 
пропускается. 

Как и в случае с break, в операторе continue можно указывать метку для 
описания того, какой объемлющий цик л необходимо продолжить.

## Оператор return 

Последний управляющий оператор - return. Он применяется для явного 
возвращения из метода, т.е. управление программой передается обратно вызывающей стороне. Таким образом, return классифицируется как оператор 
перехода. Хотя подробное обсуждение оператора return следует отложить 
до обсуждения методов в главе 6, здесь представлен его краткий обзор. 
Оператор re turn можно использовать в любом месте метода, чтобы 
возвратить управление вызывающей стороне. Таким образом, оператор 
return немедленно завершает выполнение метода, в котором он находится. 


</details> 

</blockquote>
</details>

<details ГЛАВА 6><summary>ГЛАВА 6. "Введение в классы"</summary>
<blockquote>

Класс лежит в самом центре Java. Он представляет собой логическую конструкцию, на которой построен весь язык Java, потому что она определяет 
форму и природу объекта. Таким образом, класс формирует основу для объектно-ориентированного программирования (ООП) на Java. Любая концепция, которую вы хотите реализовать в программе на Java, должна быть инкапсулирована внутри класса
  
<details><summary>Основы классов</summary>

Вероятно, наиболее важная характеристика класса заключается в том, что 
он определяет новый тип данных. После определения новый тип можно применять для создания объектов такого типа. Следовательно, класс - это шаблон для объекта, а объект - это экземпляр класса. Так как объект является 
экземпляром класса, вы часто будете видеть, что слова объект и экземпляр 
используются взаимозаменяемо. 

При определении класса вы объявляете его точную форму и природу, для 
чего указываете данные, которые он содержит, и код, который работает с этими данными. Код класса определяет интерфейс к своим данным.

Данные, или переменные, определенные в классе, называются переменными 
экземпляра. Код содержится внутри методов. В совокупности методы и переменные, определенные в классе, называются членами класса. В большинстве 
классов переменные экземпляра обрабатываются и доступны с помощью методов, определенных для этого класса. Таким образом, как правило, именно 
методы определяют, как можно использовать данные класса. 

```html 
class Вох { 
douЫe width; 
douЫe height; 
douЫe depth; 
}
```

Как утверждалось выше, класс определяет новый тип данных. В рассматриваемом случае новый тип данных называется Вох. Имя класса будет использоваться для объявления объектов типа Вох. Важно помнить, что объявление класса создает только шаблон, но не фактический объект. Таким образом, предыдущий код не создает никаких объектов типа Вох. 
Чтобы действительно создать объект Вох, будет применяться оператор 
следующего вида: 

```html 
Вох mybox = new Вох ( ); // создать объект Вох по имени mybox
```

[Chapter06/BoxDemo - Программа, использующая класс Box].(https://github.com/Vladlena2/BookJava/blob/main/Chapter6/BoxDemo.java "Посмотреть пример Java")

</details> 

<details><summary>Объекты</summary>

Как только что объяснялось, создание класса означает создание нового типа данных, который можно применять для объявления объектов этого 
типа. Однако получение объектов класса представляет собой двухэтапный 
процесс. Во-первых, потребуется объявить переменную типа класса. Такая 
переменная не определяет объект, а просто может ссылаться на объект. Во-вторых, необходимо получить физическую копию объекта и присвоить ее 
этой переменной, для чего служит операция new. Операция new динамически (т.е. во время выполнения) выделяет память для объекта и возвращает 
ссылку на нее, которая по существу является адресом в памяти объекта, выделенной new. Затем ссылка сохраняется в переменной. Таким образом, в Java 
все объекты класса должны размещаться динамически. 

```html 
Вох mybox = new Вох ( ); // создать объект Вох по имени mybox
```

В первой строке переменная mybox объявляется как ссылка на объект типа 
Вох. Пока что mybox не ссылается на фактический объект. Во второй строке 
объекта размещается в памяти и ссылка на него присваивается mybox. После 
выполнения второй строки переменную mybox можно использовать, как если 
бы она была объектом Вох. Но на самом деле mybox просто содержит адрес 
памяти фактического объекта Вох. 

## Подробный анализ операции new 

Важно понимать, что операция new выделяет память для объекта во время 
выполнения. Преимущество этого подхода состоит в том, что ваша программа может создать столько объектов, сколько требуется во время ее выполнения. Однако поскольку память конечна, возможно, что new не сможет выделить память под объект из-за нехватки памяти. В такой ситуации возникает 
исключение времени выполнения. (Вы узнаете, как обрабатывать исключения, в главе 10.) В примерах программ, приводимых в книге, вам не придется 
беспокоиться о нехватке памяти, но нужно будет учитывать эту возможность 
в реальных программах, которые вы будете писать.

Давайте еще раз подчеркнем **различие между классом и объектом**. Класс создает новый тип данных, который можно применять для создания объектов. То есть класс создает логическую инфраструктуру, определяющую отношения между его членами. При объявлении объекта класса создается экземпляр этого класса. Таким образом, класс является логической конструкцией, 
а объект имеет физическую реальность (занимает место в памяти).

## Присваивание для переменных ссылок на объекты 

```html 
Вох b1 = new Вох(); 
Вох Ь2 = b1; 
```

После выполнения данного фрагмента кода переменные b1 и Ь2 будут 
ссылаться на тот же самый объект. Присваивание переменной Ь2 значения b1 
не привело к выделению памяти или копированию какой-либо части исходного объекта. Оно просто заставляет Ь2 ссылаться на тот же объект, что и b1. 
Таким образом, любые изменения, внесенные в объект через переменную Ь2, 
повлияют на объект, на который ссылается b1, поскольку это один и тот же объект.

Хотя переменные b1 и Ь2 относятся к тому же самому объекту, они никак 
не связаны друг с другом. Например, последующее присваивание переменной 
b1 значения nul b1 просто отсоединит Ы от исходного объекта, не затрагивая объект и переменную Ь2.

</details> 

<details><summary>Введение в методы</summary>

Хотя совершенно нормально создавать класс, содержащий только данные, 
такое случается редко. Большую часть времени вы будете использовать методы для доступа к переменным экземпляра, которые определены классом. В действительности методы определяют интерфейс для большинства классов, что позволяет разработчику класса скрыть конкретную реализацию внутренних структур данных за более привлекател ьными абстракциями методов. 

Когда доступ к переменной экземпляра осуществляется кодом, который не входит в состав класса, где определена данная переменная 
экземпляра, то его придется делать через объект с использованием операции 
точки. Тем не менее, когда к переменной экземпляра обращается код, который входит в состав того же класса, что и переменная экземпляра, то на переменную можно ссылаться напрямую. То же самое относится и к методам.

**Параметр** - это переменная, определенная методом, которая получает 
значение при вызове метода. Например, в методе square () параметром является i. 

**Аргумент** - это значение, которое передается методу при его вызове. Например, вызов square (1ОО) передает в качестве аргумента значение 100, которое получает параметр i внутри square(). 

Скажем, довольно легко забыть установить какой-то размер. Во-вторых, в хорошо спроектированных программах на Java доступ к переменным экземпляра должен осуществляться только через методы, определенные их классом

Таким образом, более эффективный подход к установке размеров коробки предусматривает создание метода, который принимает размеры коробки в своих параметрах и соответствующим образом устанавливает каждую переменную экземпляра. 

[Chapter06/BoxDemo3 - В этой программе применяется метод с параметрами].(https://github.com/Vladlena2/BookJava/blob/main/Chapter6/BoxDemo3.java "Посмотреть пример Java")

</details> 

<details><summary>Конструкторы</summary>

Конструктор инициализирует объект немедленно после создания. Причина в том, что неявным возвращаемым типом конструктора класса является сам класс. Задача конструктора - инициализировать внутреннее состояние объекта, чтобы код, создающий экземпляр, немедленно получил в свое распоряжение полностью инициализированный и пригодный для использования объект.

Теперь вы понимаете, зачем нужны скобки после имени класса. На самом 
деле происходит вызов конструктора класса. Таким образом, в следующей 
строке:

```html 
Вох myboxl = new Вох(); 
```

Фрагмент new Вох() вызывает конструктор Вох (). Если конструктор для 
класса не определяется явно, тогда компилятор Java создает стандартный конструктор. Вот почему предыдущая строка кода работала в более ранних 
версиях класса Вох, в которых конструктор не определялся. При использовании стандартного конструктора все неинициализированные переменные 
экземпляра будут иметь стандартные значения, которые для числовых типов, 
ссылочных типов и логических значений равны соответственно нулю, null и 
false. Стандартного конструктора часто оказывается достаточно для простых классов, но для более сложных классов он обычно не подходит. После 
определения собственного конструктора стандартный конструктор больше 
не применяется. 

[Chapter06/BoxDemo4 - В классе Box4 применяется параметрзованный конструктор].(https://github.com/Vladlena2/BookJava/blob/main/Chapter6/BoxDemo4.java "Посмотреть пример Java")

[Chapter06/BoxDemo5 - В этой программе применяется метод с параметрами].(https://github.com/Vladlena2/BookJava/blob/main/Chapter6/BoxDemo5.java "Посмотреть пример Java")

## Ключевое слово this

Иногда метод должен ссылаться на объект, на котором он вызывается. 
Для этого в Java определено ключевое слово this. Его можно использовать 
внутри любого метода для ссылки на текущий объект, т.е. this всегда будет 
ссылкой на объект, на котором был вызван метод. Ключевое слово this можно применять везде, где разрешена ссылка на объект типа текущего класса. 
Чтобы лучше понять, на что ссылается this, взгляните на приведенную 
ниже версию конструктора Вох(): 

```html 
// Избыточное исполь зование this. 
Box (double w, double h, double d){
this.width = w; 
this.height = h; 
this.depth = d;
}
```

## Сокрытие переменных экземпляра

Как вы з наете, в Java запрещено объявлять две локальные переменные с 
одинаковыми именами внутри той же самой или объемлющей облас ти видимости. Интересно отметить, что у вас могут быть локальные переменные, 
в том числе формальные параметры методов, имена которых совпадают с 
именами переменных экземпляра класса. Однако когда локальная переменная имеет такое же имя, как у переменной экземпляра, то локальная переменная скрывает переменную экземпляра. Вот почему width, height и depth не использовались в качестве имен параметров конструктора Вох() внутри класса Вох. Если бы они были выбраны, то имя width, например, ссылалось 
бы на формальный параметр, скрывая переменную экземпляра width. Хотя 
обычно проще применять отличающиеся имена, есть и другой выход из такой ситуации. Поскольку клю чевое слово this позволяет ссылаться прямо 
на объект, его можно использовать для устранения любых конфликтов имен, 
которые могут возникать между переменными экземпляра и локальными переменными. Например, вот еще одна версия конструктора Вох(), в которой 
имена width, height и depth применяются для параметров, а посредством 
this организуется доступ к переменным экземпляра с теми же именами: 

```html 
// Использование this для устранения конфликтов имен. 
Box (double width , double height , double depth) { 
this.width = width; 
this.height = height; 
this.depth = depth ;
}
```

Есть одно предостережение: использование this в таком контексте иногда 
может сбивать с толку. Некоторые программисты стараются не применять 
для локальных переменных и формальные параметров такие имена, которые 
приводят к сокрытию переменных экземпляра. Раз умеется, другие программисты уверены в обратном: они полагают, что использование тех же самых 
имен делает код яснее и применяют this для преодоления сокрытия переменных экземпляра. То, какой подход вы выберете - дело личного вкуса.

</details> 

<details><summary>Сборка мусора</summary>

Поскольку объекты динами чески размещаются в памяти с помощью операции new, вас может интересовать, каким образом такие объекты уни чтожаются, и занимаемая ими память освобождается с целью последующего выделения. В языках, подобных традиционному С++, динами чески размещенные объекты необходимо освобождать вру чную с помощью операци и delete. 
В Java используется другой подход; освобождение померживается автоматически. Методика, которая позволяет это делать, называется сборкой мусора. 
Она работает следующим образом: когда ссылок на объект не существует, то 
с читается, что такой объект больше не нужен, и занимаемая им память может 
быть освобождена. Нет необходимости явно уни чтожать объекты. Сборка 
мусора происходит нерегулярно (если вообще происходит) во время выполнения программы. Она не инициируется просто потому, что существует один или несколько объектов, которые больше не использ уются. Кроме того, в разных реализациях исполняющей среды Java будут применяться варьирующиеся подходы к сборке мусора, но по большей части вам не придется думать о ней при написании своих программ. 

</details> 

<details><summary>Класс Stack</summary>

Стек сохраняет данные по принципу "последний пришел - первым обслужен'; т.е. 
стек подобен стопке тарелок на столе: первая тарелка, поставленная на стол, 
используется последней. Стеки управляются с помощью двух операций, традиционно называемых помещением и извлечением. Чтобы сохранить элемент на верхушке стека, будет применяться помещение. Чтобы взять элемент из стека, будет использоваться извлечение. Как вы увидите, инкапсулировать полный механизм стека несложно.

[Chapter06/Stack - Реализация класса Stack].(https://github.com/Vladlena2/BookJava/blob/main/Chapter6/Stack.java "Посмотреть пример Java")

[Chapter06/TestStack - Применение класса Stack].(https://github.com/Vladlena2/BookJava/blob/main/Chapter6/TestStack.java "Посмотреть пример Java")

</details> 
  
</blockquote>
</details>

<details ГЛАВА 7><summary>ГЛАВА 7. "Подробный анализ методов и классов"</summary>
<blockquote>

<details><summary>Перегрузка методов</summary>
  
Язык Java разрешает определять в одном классе два и более метода, которые имеют одно и то же имя, если их объявления параметров отличаются. 
В таком случае говорят, что методы перегружены, а сам процесс называется 
перегрузкой методов. Перегрузка методов - один из способов помержки полиморфизма в Java.

При вызове перегруженноrо метода компилятор Java использует тип и/или 
количество аргументов в качестве ориентира, чтобы определить, какую версию переrруженноrо метода фактически вызывать. Таким образом, перегруженные методы должны отличаться типом и/или количеством параметров. 
Хотя перегруженные методы могут возвращать разные типы, одного типа 
возвращаемого значения недостаточно, чтобы различить две версии метода. 
Коrда компилятор Java встречает вызов переrруженноrо метода, он просто 
выполняет версию метода, параметры которой соответствуют аргументам, 
указанным в вызове.

Ниже приведен простой пример, иллюстрирующий перегрузку методов:

[Chapter07/OverloadDemo - Продемонстрировать перегрузку методов](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/OverloadDemo.java "Посмотреть пример Java")


</details> 
  
</blockquote>
</details>

