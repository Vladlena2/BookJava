       <small>
  
## Книга "Java полное руководство - Герберт Шилдт, 12-е издание, 2022г."

<small>

#### Оглавление

<details ГЛАВА 1><summary>ГЛАВА 1. "История и эволюция языка Java"</summary>
<blockquote>
  
<details><summary>Создание языка Java</summary>
  
Главной движущей силой стала потребность в **независимом от платформы** (т.е. архитектурно-нейтральном) языке, который можно было бы использовать для построения программного обеспечении, встраиваемого в разнообразные бытовые электронные устройства, такие как микроволновые печи и пульты дистанционного управления.
Второй движущей силой стала Всемирная паутина (она же веб-сеть) т.к. веб-сеть тоже нуждалась в переносимых программах.
</details>

<details><summary> Апплет в Java</summary>

**Апплет** — это Java-приложение, которое запускается внутри веб-браузера с помощью Java-плагина. Апплеты были популярными в 1990-х и начале 2000-х годов как способ предоставления интерактивных графических приложений на веб-страницах. Они позволяли разработчикам создавать множество интересных веб-приложений, включая игры, графические редакторы и интерактивные диаграммы.

По существу, апплет позволяет переместить определенную функциональность из серверной стороны на клиентскую сторону. Напротив, апплет представляет собой динамическую самостоятельно запускающуюся программу. Такая программа является активным агентом на клиентском компьютере, но инициируется сервером.

Основные характеристики Java апплетов включают: 
- Платформонезависимость: Java апплеты могли выполняться на разных операционных системах и архитектурах благодаря тому, что они компилировались в байт-код Java и выполнялись на виртуальной машине Java (JVM). 
- Безопасность: Апплеты были ограничены в своих возможностях для обеспечения безопасности. Они могли выполняться в песочнице (sandbox), что ограничивало их доступ к ресурсам компьютера.
- Графический интерфейс: Java апплеты могли создавать графический пользовательский интерфейс с использованием библиотеки AWT (Abstract Window Toolkit) или Swing.

Связь Java-кода с браузером осуществлялась с помощью Java апплетов. Вот как это происходило: 
1. Написание Java-кода: Разработчик создавал Java-код, который выполнял определенные задачи и визуализацию интерфейса, если это требовалось.
2. Компиляция в байт-код Java: Java-код затем компилировался в байт-код Java с использованием компилятора Java. Байт-код был независим от конкретной аппаратной платформы.
3. Создание HTML-страницы: Разработчик создавал HTML-страницу, которая включала тег `<applet>`. В этом теге указывалось имя класса Java-апплета и другие параметры, такие как размеры окна, параметры безопасности и т. д. 
   Пример тега `<applet>`:
   ```html
   <applet code="MyApplet.class" width="300" height="200"></applet>
</details>

<details><summary>Магия Java: байт-код</summary>
Компилятор Java генерирует не исполняемый код, а байт-код. Байт-код представляет собой оптимизированный набор инструкций, предназначенных для выполнения так называемой виртуальной машиной Java (Java Virtual Machine - JVM), которая является частью исполняющей среды Java (Java Runtime Environment - JRE).
  
**Java Virtual Machine (JVM)** — это виртуальная машина, которая выполняет байт-код Java, созданный компилятором Java из исходного Java-кода. JVM обеспечивает платформонезависимость Java, позволяя Java-приложениям выполняться на разных операционных системах без изменений в их исходном коде.

Вот как работает JVM: 
1. Компиляция в байт-код: Исходный Java-код компилируется в байт-код Java с помощью Java-компилятора (javac). Байт-код представляет собой набор инструкций, которые являются абстрактными и не зависят от конкретной аппаратной платформы. 
2. Загрузка классов: JVM загружает байт-код Java в память по мере необходимости. Классы могут быть загружены с локального класспаса (classpath) или из удаленных источников, таких как удаленные серверы или интернет.
3. Верификация: перед выполнением классы проходят процесс верификации, в ходе которого проверяется их правильность и безопасность. Это важный этап, который защищает систему от вредоносного кода.
4. Исполнение: когда класс загружен и верифицирован, JVM начинает выполнение байт-кода Java. Виртуальная машина интерпретирует байт-код или может использовать Just-In-Time (JIT) компиляцию для перевода байт-кода в нативный машинный код для конкретной аппаратной платформы, что может улучшить производительность приложения.
5.	Управление памятью: JVM управляет памятью, выделяя и освобождая память для объектов, создаваемых во время выполнения приложения. Это включает в себя управление кучей (heap) для объектов и стеком вызовов (call stack) для управления вызовами методов и локальными переменными.
6.	Сборка мусора: JVM автоматически отслеживает объекты, которые больше не используются, и периодически освобождает память, занимаемую этими объектами, с помощью сборщика мусора (garbage collector).
7.	Управление исключениями: JVM обрабатывает исключения, которые могут возникнуть во время выполнения приложения, и предоставляет механизмы для их обработки и управления.
8.	Многозадачность: JVM обеспечивает поддержку многозадачности, позволяя выполнять несколько потоков (threads) одновременно в рамках одного процесса Java-приложения.
9.	Библиотеки Java: JVM включает в себя стандартные библиотеки Java (Java Standard Library), которые предоставляют множество классов и методов для работы с различными аспектами программирования, такими как работа с файлами, сетевое взаимодействие, графика и многое другое.

**Just-In-Time (JIT) компиляция** — это техника оптимизации выполнения кода виртуальной машины (VM) или интерпретатора, которая используется, чтобы улучшить производительность при выполнении программы. JIT компиляция предназначена для ускорения работы приложения путем преобразования некоторых частей кода, представленного в байт-коде или другом промежуточном формате, в нативный машинный код, который выполняется непосредственно на целевой аппаратной платформе. 
Вот как работает JIT компиляция: 
1.  Интерпретация и компиляция: изначально, при запуске программы, код выполняется в интерпретируемом режиме. Это означает, что инструкции байт-кода (или другого промежуточного кода) интерпретируются виртуальной машиной, что может быть медленным в сравнении с нативным машинным кодом. 
2.	Профилирование кода: во время интерпретации виртуальная машина отслеживает, какие части кода выполняются наиболее часто. Это называется профилированием кода. 
3.	Компиляция в нативный код: когда определенный фрагмент кода выполняется достаточно часто, JIT-компилятор анализирует этот код и транслирует его в нативный машинный код для конкретной аппаратной платформы. Это происходит во время выполнения программы, и только для тех участков кода, которые действительно нуждаются в оптимизации. 
4.	Кеширование: Сгенерированный нативный код кешируется, чтобы он мог быть использован при последующих вызовах того же фрагмента кода без повторной компиляции.

**Нативный машинный код** — это низкоуровневый исполняемый код, который представляет собой инструкции, понятные конкретному процессору или архитектуре компьютера. Этот код является непосредственно понятным и выполняемым процессором, без дополнительной обработки или интерпретации.

**Байт-код** представляет собой абстрактную форму кода, которая является промежуточным уровнем между исходным кодом и нативным машинным кодом. Он не зависит от конкретной аппаратной платформы, так как он представлен в виде набора инструкций и операций, которые понимает виртуальная машина (например, JVM для Java или CLR для C#). Виртуальная машина интерпретирует байт-код или компилирует его в нативный машинный код во время выполнения, адаптируя его под текущую платформу. Таким образом, байт-код обеспечивает переносимость между разными архитектурами и операционными системами.

Как все взаимосвязано:
1.	Байт-код Java: когда вы компилируете исходный Java-код с помощью компилятора Java, он создает байт-код Java. Этот байт-код представляет собой инструкции, которые не зависят от конкретной аппаратной платформы, и это делает его переносимым. 
2.	JVM — это программное обеспечение, которое является частью среды выполнения Java (Java Runtime Environment, JRE). JVM интерпретирует или JIT-компилирует байт-код Java в нативный машинный код, который может выполняться на конкретной аппаратной платформе. Это ключевой момент, который обеспечивает переносимость Java-приложений. 
3.	Изоляция нативного кода: Нативный код, который генерирует JVM, ассоциирован с аппаратной платформой и операционной системой, на которой JVM работает. Однако этот нативный код находится внутри JVM и изолирован от самой Java-программы. Java-приложение взаимодействует с нативным кодом через API, которые предоставляются JVM, и эти API переносимы и абстрагируют код Java от деталей аппаратной платформы. 
4.	Платформонезависимость: поскольку байт-код Java является переносимым и может быть выполнен на любой платформе, на которой установлена совместимая JVM, Java-приложения могут быть написаны один раз и выполняться на разных операционных системах и аппаратных платформах, где существует JVM. Это обеспечивает платформонезависимость Java.

API (Application Programming Interface) — это набор определенных правил и протоколов, которые позволяют разным программным компонентам взаимодействовать друг с другом. API определяет, какие функции и методы доступны для использования внешними приложениями, и как эти приложения могут взаимодействовать с системой, библиотекой, сервисом или операционной системой.
Примерами API могут быть следующие:
- API операционной системы, которое позволяет приложениям управлять файлами, сетевыми соединениями и другими аспектами ОС.
- API социальных сетей, которые позволяют разработчикам создавать приложения, интегрированные с социальными платформами. 
-	API библиотеки, предоставляющей математические функции для приложения. 
-	API веб-сервисов, позволяющие приложениям обмениваться данными через интернет.

Взаимодействие Java-приложения с нативным кодом происходит через Java Native Interface (JNI), который представляет собой API, предоставляющее возможность вызывать функции, написанные на нативных языках (как правило, на C или C++), из Java-приложения. Это позволяет Java-приложениям использовать библиотеки и функциональность, которая не доступна непосредственно на языке Java.

</details>

<details><summary>Сервлеты: Java на серверный стороне</summary>

  **Сервлеты** представляют собой Java-классы, которые используются для разработки динамических веб-приложений на платформе Java. Они работают на серверной стороне и предназначены для обработки HTTP-запросов и генерации HTTP-ответов. Сервлеты широко используются в веб-приложениях для создания веб-страниц, взаимодействия с базами данных, обработки форм, аутентификации и других веб-связанных задач. 

  Вот основные характеристики сервлетов: 
  1. 	Java-классы: Сервлеты представляют собой обычные классы на языке Java, которые расширяют классы или реализуют интерфейсы из Java Servlet API. Обычно, для создания сервлета, нужно создать Java-класс и переопределить методы, такие как doGet() или doPost(), для обработки HTTP-запросов. 
  2.	Жизненный цикл: у сервлетов есть жизненный цикл, который включает в себя инициализацию, обработку запросов и завершение работы. Сервлет может быть создан один раз и использоваться для обслуживания нескольких запросов, что позволяет сэкономить ресурсы сервера. 
  3.	Обработка HTTP-запросов: Главная задача сервлетов - обработка HTTP-запросов от клиентов (например, браузеров). Они могут анализировать параметры запроса, читать и записывать HTTP-заголовки, работать с сессиями пользователей и так далее. 
  4.	Генерация HTTP-ответов: Сервлеты также генерируют HTTP-ответы, которые включают в себя HTML-страницы, JSON-данные, изображения и другие ресурсы. Ответы отправляются клиентам (браузерам) в форме HTTP-сообщений. 
  5.	Поддержка многопоточности: Сервлеты автоматически поддерживают многопоточность. Они могут одновременно обслуживать несколько запросов от разных клиентов, и каждый запрос выполняется в отдельном потоке. 
  6.	Конфигурация через web.xml или аннотации: Сервлеты могут быть настроены с использованием файлов конфигурации web.xml или с помощью аннотаций (в более современных версиях Java Servlet API). Это позволяет определить URL-пути, по которым сервлеты будут доступны, а также другие параметры.

Сервлеты являются важной частью технологии Java EE (Java Platform, Enterprise Edition) и используются для создания множества веб-приложений, включая корпоративные приложения, интернет-магазины, порталы и другие веб-ресурсы. Они предоставляют программистам мощный инструмент для создания динамических и интерактивных веб-приложений, работающих на сервере Java.
  
</details>

<details><summary>Терминология языка Java</summary>
• простота; • безопасность; • переносимость; • объектная ориентация; • надежность; • многопоточность; • нейтральность к архитектуре; • интерпретируемость; • высокая производительность; • распределенность; • динамичность.

_Надежность._
Java – строго типизированный язык.
  
**Строго типизированный язык** (или сильно типизированный язык) — это язык программирования, который строго следует правилам и ограничениям, касающимся типов данных. В строго типизированных языках каждая переменная и выражение имеют строго определенный тип данных, и их использование ограничено в соответствии с этим типом.
  
Чтобы лучше понять, как обеспечивается надежность в Java, рассмотрим две главных причины отказа программ: просчеты в управлении памятью и неправильно обработанные исключительные ситуации (т.е. ошибки времени выполнения).  
Скажем, в С/С++ программист будет часто вручную выделять и освобождать динамическую память. Подход подобного рода иногда приводит к возникновению проблем, потому что программисты будут либо забывать об освобождении ранее выделенной памяти, либо, что хуже, пытаться освободить память, которая все еще задействована в другой части кода. Java практически устраняет указанные проблемы, самостоятельно управляя выделением и освобождением памяти. (На самом деле освобождение выполняется полностью автоматически, поскольку Java обеспечивает сборку мусора для неиспользуемых объектов.)
Условия для исключений в традиционных средах часто возникают в ситуациях вроде деления на ноль или отсутствия нужного файла, и справляться с ними приходится с помощью неуклюжих и трудных для чтения конструкций. Java помогает и этой области, предлагая объектно-ориентированную обработку исключений. В хорошо написанной программе на Java все ошибки времени выполнения могут - и должны - обрабатываться вашей программой.

_Интерпретируемость и высокая производительность._
Байт-код Java был тщательно спроектирован, чтобы легко транслироваться прямо в машинный код для достижения очень высокой производительности с использованием оперативного компилятора.

</details>

</blockquote>
</details>

<details ГЛАВА 2><summary>ГЛАВА 2. "Краткий обзор языка Java"</summary>
<blockquote>
  
<details><summary>Объектно-ориентированное программирование. Две парадигмы</summary>
Все компьютерные программы состоят из двух элементов: **кода и данных**. Кроме того, программа может быть **концептуально организована вокруг своего кода или своих данных**. Иными словами, одни программы пишутся исходя из того, "что происходит”; а другие - исходя из того, "что затронуто”.
  
Существуют две парадигмы, определяющие то, как строится программа:
  1. Модель, ориентированная на процессы – последовательность линейных шагов (т.е. кода), код, воздействующий на данные. При использовании этого подхода начинают возникать проблемы.
  2.	Объектно-ориентированное программирование. Позволяет организовать программу вокруг ее данных (т.е. объектов) и набора четко определенных интерфейсов к таким данным. Это данные, управляющие доступом к коду

**Абстракция** – принцип, который позволяет скрыть детали реализации объекта и выделить только самую важную информацию или функциональность.

Скажем, в состав аудиосистемы может входить радиоприемник, проигрыватель компакт-дисков и/или проигрыватель МРЗ. Суть в том, что вы управляете сложностью автомобиля (или любой другой сложной системы) за счет использования иерархических абстракций.

**Суть ООП:** Последовательность шагов процесса может стать совокупностью сообщений, передаваемых между этими объектами. Таким образом, каждый объект описывает свое уникальное поведение. Вы можете воспринимать такие объекты как конкретные сущности, которые реагируют на сообщения, указывающие им о необходимости делать что-то. 

</details>

<details><summary>Три принципа ООП</summary>
  
## Инкапсуляция 
Инкапсуляция представляет собой механизм, который связывает вместе код и обрабатываемые им данные, а также защищает их от внешнего вмешательства и неправильного использования. Инкапсуляцию можно считать защитной оболочкой, которая предотвращает произвольный доступ к коду и данным из другого кода, определенного вне оболочки. Доступ к коду и данным, находящимся внутри оболочки, строго контролируется через четко определенный интерфейс.
  
**Сила инкапсулированного кода** в том, что каждый знает, как пол учить к нему доступ, и потому может использовать его независимо от деталей реализации и без каких-либо опасений столкнуться с неожиданными побочными эффектами.

**Основой инкапсуляции** в Java является класс.
Класс определяет структуру и поведение (данные и код), которые будут общими для набора объектов. Каждый объект заданного класса содержит структуру и поведение, определенные классом, как если бы он был "отлит" в форме класса. Поэтому **объект** – экземпляр класса.

Таким образом, класс представляет собой логическую конструкцию, а объект имеет физическую реальность.

В правильно написанных программах на Java методы определяют способ использования переменных-членов, т.е. поведение и интерфейс класса определяются методами, которые работают с данными его экземпляра. 

**Целью класса** является инкапсуляция сложности.

## Наследование 
Наследование представляет собой процесс, посредством которого один объект приобретает свойства другого объекта. Оно важно, т.к. поддерживает концепцию иерархической классификации.

**Суперкласс** — это класс, который предоставляет общие свойства и методы, которые могут быть унаследованы подклассами. Суперкласс определяет базовую структуру и поведение, которые могут быть общими для нескольких классов. Это позволяет избегать дублирования кода и обеспечивает более легкое управление и сопровождение кода.

Наследование также взаимодействует с инкапсуляцией. Когда подкласс наследует суперкласс, он наследует не только его методы и свойства, но также и инкапсулированную структуру и данные.

## Полиморфизм  
_(от греческого "много форм")_

Представляет собой средство, которое позволяет использовать один интерфейс для общего класса действий.

В языке, не являющемся объектно-ориентированным, вам придется создать три разных набора стековых процедур с отличающимися именами. Но благодаря полиморфизму в Java вы можете указать общий набор стековых процедур с одинаковыми имен.

</details>

<details><summary>Компиляция программы</summary>
Файл с исходным кодом в Java официально называется единицей компиляции. По соглашению имя главного класса должно совпадать с именем файла, содержащего программу.
  
В Java исходный код программы обычно разбивается на несколько классов, каждый из которых может быть размещен в отдельном файле. Каждый файл с исходным кодом Java обычно имеет расширение .java. Однако при компиляции этого исходного кода каждый класс превращается в отдельный файл байт-кода с расширением .class. Этот байт-код является исполняемым для Java виртуальной машины (JVM). 
  
Для того чтобы JVM могла найти и выполнить нужный класс при запуске программы, следует придерживаться следующей конвенции:
1.	Имя файла с исходным кодом (.java) должно совпадать с именем класса, который он содержит.
2.	Когда вы запускаете программу Java, вы указываете имя класса, который должен быть запущен. JVM автоматически ищет соответствующий файл с расширением .class.    
</details>

<details><summary>Подробный анализ первого примера программы</summary>
  
```html 
  public srtatic void main(String[] args){ }
```
Данная строка начинает метод main(). Как объяснялось в предыдущем комментарии, с этой строки программа начнет выполняться. Обычно программа на Java начинает выполнение с вызова main(). Полностью осознать смысл каждой части строки пока невозможно, т.к. для этого нужно хорошо понимать подход Java к инкапсуляци.

Ключевое слово puЫic представляет собой модификатор доступа, который позволяет программисту управлять видимостью чл енов класса. Когда член класса предварен ключевым словом puЫic, доступ к нему может быть получен из кода за пределами класса, где он объявлен. В данном случае метод main() должен быть объявлен как puЫic, потому что при запуске программы его потребуется вызывать в коде за пределами класса.

Ключевое слово static позволяет вызывать main() без создания конкретного экземпляра класса. Причина в том, что main() вызывается машиной JVM до создания каких-либо объектов, т.к. метод main принадлежит не конкретному экземпляру класса, а самому классу.

Ключевое слово void просто сообщает компилятору, что main() не возвращает значение.

Параметры метода – args, который получает любые аргументы командной строки, присутствующие при выполнении программы.

```html 
  System.out.printl("Hello, world!");
```
System — это класс в стандартной библиотеке Java, который предоставляет доступ к системным ресурсам и переменным окружения.

out — это объект типа PrintStream, который представляет стандартный вывод (обычно консоль). Он предоставляет методы для вывода данных. 

println — это метод объекта PrintStream, который используется для вывода текста или значения и добавляет перевод строки (новую строку) в конце вывода. Это означает, что следующий вывод будет на новой строке.

Если за место текста указать переменную, то на самом деле ее значение сначала преобразуется из целочисленного (или другой тип данных) в эквивалентное строковое и затем объединяется с предшествующей ему строкой.

</details>

<details><summary>Доп.</summary>
  
**Операции инкремента и декремента** — это арифметические операции, которые увеличивают (инкремент) или уменьшают (декремент) значение переменной на 1.
  
Блок кода создан, то становится логической единицей, которую можно применять в любом месте, где разрешено использовать одиночный оператор. Главная причина их существования - создание логически неразрывных единиц кода.

В Java **литералы** — это константные значения, которые представляют данные определенных типов.

</details>

</blockquote>
</details>

<details ГЛАВА 3><summary>ГЛАВА 3. "Типы данных, переменные и массивы"</summary>
<blockquote>
  
<details><summary>Типы данных</summary>
  
<details><summary>Целые числа</summary>

Во многих других языках программирования поддерживаются как целые числа со знаком(signed), так и целые числа без знак(unsigned), но разработчики Java решили, что целые числа без знака не нужны. В частности, они считали, что понятие без знака использовалось в основном для указания поведения старшего бита, который определяет знак целочисленного значения. В главе 4 вы увидите, что Java подругому управляет смыслом старшего бита, добавляя специальную операцию **"беззнакового сдвига вправо"**: таким образом, необходимость в целочисленном типе без знака попросту отпала.

**Беззнаковый сдвиг вправо** (unsigned right shift) - это операция, которая позволяет сдвигать биты числа вправо без учета его знака. В Java, этот механизм предоставляется оператором ">>>" и применяется к целым числам (int и long). Он используется для выполнения арифметических сдвигов битов числа, при которых самый старший бит (знаковый бит) не учитывается, и новые биты заполняются нулями.

Пример: 
```html 
int number = -8; // Бинарное представление: 11111111111111111111111111111000
int result = number >>> 1; // Сдвиг на 1 позицию вправо 
```

**Знаковый сдвиг вправо** (signed right shift) для целочисленных типов данных. Этот оператор выполняет сдвиг битов числа вправо на заданное количество позиций, при этом заполняет левую сторону (старшие биты) копией самого левого бита (знакового бита) перед сдвигом.

Пример: 
```html 
int x = -10; // Например, число -10 в двоичной системе: 11111111111111111111111111110110
x = x >> 2; // Знаковый сдвиг вправо на 2 позиции, получим 11111111111111111111111111111101
```

Ширина (или разрядность) целочисленного типа не должна трактоваться как объем потребляемой им памяти, а скорее как поведение, которое он определяет для переменных и выражений данного типа. 

Переменные типа byte особенно удобны при работе с потоком данных из сети или файла. Они также полезны, коrда приходится иметь дело с низкоуровневыми двоичными данными, которые моrут быть несовместимыми напрямую с другими встроенными типами Java.
</details>

<details><summary>Типы с плавающей точкой </summary>

В Java реализован стандартный (IEEE-754) набор типов и операций с плавающей точкой. Существуют две разновидности типов с плавающей точкой.

Тип float определяет значение одинарной точности.
Значение двойной точности.

</details>

<details><summary>Символы</summary>

Для хранения символов в Java используется тип данных char. Важно понять один ключевой момент: для представления символов в Java применяется Unicode. Кодировка Unicode определяет полностью международный набор 
символов, с помощью которого можно представить все символы, встречающиеся во всех естественных языках. Он объединяет десятки наборов символов, таких как романский, греческий, арабский, кириллический, иврит, катакана, ханrул и многие другие. Во время создания Java для Unicode требовалось 16 бит. Таким образом, в Java тип char является 16-битным с диапазоном значений от О до 65 535. Отрицат ельных значений char не бывает. Стандартный набор символов, известный как ASCII, по-прежнему находится в диапазоне от О до 127, а расширенный 8-битный набор символов, ISO-Latin-1 - в диапазоне от О до 255. Поскольку язык Java предназначен для написания программ, используемых по всему миру, при представлении символов имеет смысл применять Unicode. Конечно, использование Unicode несколько неэффективно для таких языков, как английский, немецкий, испанский или французский, символы которых могу т легко умещаться в пределах 8 бит. Но такова цена, которую приходится платить за глобальную переносимость.

 Дополнительную информацию о Unicode можно найти на веб-сайте http://www.unicode.org. 

[Chapter03/TypeChar - Работа с типом данных char](https://github.com/Vladlena2/BookJava/blob/main/Chapter3/TypeChar.java "Посмотреть пример Java")

Обратите внимание, что переменной chl присвоено значение 88, которое является кодом ASCII (и Unicode), соответствующим букве Х. Как уже упоминалось, набор символов ASCII занимает первые 127 значений в наборе символов Unicode. По этой причине все "старые уловки'; которые вы могли использовать с символами в других языках, будут работать и в Java.

</details>

Отличие литералов от обычных переменных заключается в том, что литералы представляют фиксированные, неизменяемые значения, заданные непосредственно в исходном коде программы, в то время как переменные представляют хранимые значения, которые могут изменяться в процессе выполнения программы.

<details><summary>Целочисленные литералы</summary>

Любое целочисленное значение является целочисленным литералом. 

В Java, присвоение литеральных значений переменным типов byte и short, находящимся в пределах допустимого диапазона для этих типов, не вызывает ошибку компиляции. Это связано с тем, что литералы, которые входят в допустимый диапазон для byte или short, могут быть неявно преобразованы в эти типы без необходимости явного приведения.

Что касается литералов типа long, то в Java литералы long должны быть явно помечены суффиксом L или l (буква "эль" в верхнем или нижнем регистре), чтобы компилятор понимал, что это именно литерал типа long. Например: 
```html 
long myLong = 9223372036854775807L; // Явно указан литерал типа long с суффиксом "L"
```
Без суффикса L, компилятор может рассматривать литерал как int, и если значение литерала выходит за пределы допустимого диапазона для int, то это вызовет ошибку компиляции. Добавление суффикса L явно указывает компилятору, что литерал относится к типу long.

Указывать целочисленные литералы можно также в двоичной форме, добавляя к значению префикс ОЬ или 0В. Скажем, вот как з адать десятичное значение 10 с помощью двои чного литерала:
```html 
int х = ОЫОlО; 
```
Помимо прочего, добавление двои чных литералов упрощает ввод значений, применяемых в качестве битовых масок. Десяти чное (или шестнадцатери чное) представление значения визуально не передает смысл битовой маски, а двои чный литерал его передает

</details>

<details><summary>Литералы с плавающей точкой</summary>

В научной форме записи числа с плавающей точкой используется стандартный формат, который включает само число и степень, на которую это число умножается. Это формат, который широко используется в научных и инженерных расчетах для представления очень больших или очень маленьких чисел.

Этот формат выглядит следующим образом:
```html 
Число * 10^Показатель_степени
```
- Число - это само число с плавающей точкой, которое вы хотите представить.
- 10 - основание, которое всегда остается неизменным и равно 10, так как мы используем десятичную систему счисления.
- Показатель_степени - это степень 10, на которую число умножается. Этот показатель обозначается буквой "E" или "е", за которой следует целое число. Если это число положительное, то оно указывает на количество десятичных разрядов, на которое нужно сдвинуть десятичную точку вправо. Если число отрицательное, то десятичная точка сдвигается влево на соответствующее количество разрядов.

Примеры:
- 6.022E23 (6.022 * 10^23) - это означает, что число 6.022 умножается на 10 в 23 степени.
- 3.14159E-5 (3.14159 * 10^-5) - это означает, что число 3.14159 умножается на 10 в -5 степени, что эквивалентно делению на 10^5.
- 2e+100 (2 * 10^100) - это означает, что число 2 умножается на 10 в 100 степени.

Литералы с плавающей точкой в Java по умолчанию имеют тип douЫe. 
Для указания литерала типа float к константе необходимо добавить букву F 
или f. Можно также явно указывать литерал douЫe, добавляя букву О или d, 
хотя поступать так излишне. Назначаемый по умолчанию тип douЫe занимает 64 бита памяти, а меньший тип float требует только 32 бита.

Шестнадцатеричные литералы с плавающей точкой в Java записываются с использованием буквы "P" или "p", и они представляют числа в форме, похожей на научную нотацию, но с учетом степени двойки. Важно отметить, что это специфичный формат, который не так часто используется.
Пример:
```html 
0x12.2p2 представляет шестнадцатеричный литерал с плавающей точкой.
```

Разберем этот пример:

- 0x12.2 - это шестнадцатеричное число, которое представляет значение в шестнадцатеричной системе счисления. Здесь 0x указывает, что число записано в шестнадцатеричной форме. 0x12.2 представляет значение, которое равно 18.125 в десятичной системе.
- p2 - это обозначение двоичного показателя степени, где "2" указывает, что число умножается на 2 во второй степени, то есть на 4.

Итак, 0x12.2p2 означает, что значение 18.125 (из шестнадцатеричного числа) умножается на 4 (из двоичного показателя степени), и итоговое значение равно 72.5 в десятичной системе счисления.

</details>

<details><summary>Булевские литералы</summary>
  
Значение типа boolean может иметь только 
два логических значения: true и false. Значения true и false не преобразуются в какое-то числовое представление. Литерал true в Java не равен 1, а литерал false не равен О, т.к. разные типы данных.
  
</details>

<details><summary>Символьные литералы</summary>

В Java можно представить символы в восьмеричной или шестнадцатеричной форме с использованием обратной косой черты (\). Это предоставляет возможность вставлять специальные символы или символы, которые не могут быть набраны с клавиатуры, непосредственно в строковые литералы. Вот как это работает:

Восьмеричная форма записи:
- Для представления символа в восьмеричной форме используйте обратную косую черту (\), за которой следует трехзначное восьмеричное число (от 000 до 377).
Например, '\\141' представляет букву 'а', где 141 - это восьмеричное представление символа 'а'.
Шестнадцатеричная форма записи:
- Для представления символа в шестнадцатеричной форме используйте обратную косую черту и букву 'u' (\u), за которой следуют четыре шестнадцатеричных символа.
Например, '\u0061' представляет символ 'а' из набора символов ISO-Latin-1, где 0061 - это шестнадцатеричное представление символа 'а'.

**Управляющие последовательности символов**

|Управляющая последовательность|Описание|
|:-----------------------------|:-------|
|\ddd|Восьмеричный символ ( ddd) |
|\uxxxx|Шестнадцатеричный символ в Юникоде (.хххх)|
|\'|Одинарная кавычка|
|\"|Двойная кавычка|
|'\'|Обратная косая черта|
|\r|Возврат каретки|
|\n|Новая строка (или перевод строки)|
|\f|Подача страницы|
|\t|Табуляция|
|\b|Возврат на одну позицию ("забой")|

</details>

<details><summary>Строковые литералы</summary>

Как вам может быть известно, в некоторых других языках строки реализуются в виде 
массивов символов. Тем не менее, в Java ситуация иная. Строки на самом деле являются объектными типами. Как вы увидите далее в книге, по причине реализации строк как объектов 
Java обладает обширными возможностями обработки строк, которые характеризуются мощью и простотой использования.
  
</details>
</details>

<details><summary>Переменные</summary>
Переменная служит базовой единицей хранения в программе на Java.

Область видимости, определяемая методом, начинается с его открывающей фигурной скобки. Однако если у метода есть параметры, то они тоже входят в область видимости метода. Область видимости метода заканчивается 
закрывающей фигурной скобкой. Такой блок кода называется телом метода. 

Необходимо запомнить еще один важный момент: переменные создаются 
при входе в их область видимости и уничтожаются при выходе из их области 
видимости. Другими словами, переменная не будет хранить свое значение 
после того, как покинет пределы области видимости. Следовательно, переменные, объявленные в методе, не сохраняют свои значения между вызовами 
этого метода. Кроме того, переменная, объявленная внутри блока, утратит 
свое значение при выходе из блока. Таким образом, время жизни переменной 
ограничено ее областью видимости. 

Когда значение одного типа присваивается переменной другого типа, **автоматическое преобразование** типов происходит в случае удовлетворения следующих двух условий: 
• два типа совместимы; 
• целевой тип больше исходного типа.

**Сужающее преобразование:** требует явного указания, когда тип данных менее широкий, чем целевой тип. Например, преобразование int в byte:
```html 
int x = 300;
byte y = (byte) x; // Сужающее преобразование с явным указанием.
```
Если значение выходит за пределы диапазона целевого типа, оно усекается (по модулю диапазона).

**Усечение при преобразовании с плавающей точкой**: При преобразовании из числа с плавающей точкой в целое число дробная часть усекается.

В следующей программе демонстрируется несколько преобразований типов, требующих приведений:
[Chapter03/Conversion - Преобразования](https://github.com/Vladlena2/BookJava/blob/main/Chapter3/Conversion.java "Посмотреть пример Java")

Вот вывод, генерируемый программой: 
```html 
Преобразование i nt в byte. 
i и Ь: 257 1 
Преобразование douЫe в int . 
d и i: 32 3.142 323 
Преобра зова ние douЬle в byte . 
d и Ь: 32 3.142 67 
```
Давайте обсудим каждое преобразование. Когда значение 257 приводится к типу byte, результатом будет остаток от деления 2 57 на 256 (диапазон 
byte), который в данном случае равен 1. Когда значение переменной d преобразуется в тип int, его дробная часть утрачивается. Когда значение переменной d преобразуется в тип byte, его дробная часть теряется, а значение 
уменьшается по модулю 256, что в этом случае дает 67. 

В Java происходит автоматическое приведение типов, когда операнды арифметических выражений повышаются до определенного уровня (целевого типа), чтобы обеспечить точность и предотвратить потерю данных в результате вычислений. Этот процесс называется преобразованием типов при выполнении (widening, promotion). Он обеспечивает сохранность данных и правильное выполнение арифметических операций.

При выполнении арифметических операций, например, умножения (*), операнды автоматически повышаются до целевого типа. По умолчанию, в Java целевым типом для целых чисел является int. Это означает, что если вы выполняете арифметическую операцию между byte и int, byte будет повышен до int, и результат также будет иметь тип int. Даже если результат выражения может уместиться в byte, он все равно будет иметь тип int.
```html 
byte a = 50;
byte b = 2;
byte result = a * b; // Ошибка компиляции, так как a и b автоматически повышаются до int, и результат также имеет тип int.
```
В данном примере, результат выражения a * b имеет тип int, и поэтому его нельзя присвоить переменной byte без явного приведения (сужения типа).

Это сделано для обеспечения точности и предотвращения потери данных в процессе вычислений. Если вам нужно сохранить результат в переменной типа byte, вы можете явно выполнить приведение типа:
```html 
byte result = (byte) (a * b); // Приведение типа к byte.
```

В Java определено несколько правил повышения типов, которые применяются к выражениям. Вот как они выглядят. Первым делом все значения byte, 
short и char повышаются до int, как только что было описано. Если один 
операнд имеет тип long, то все выражение повышается до long. Если один 
операнд имеет тип float, тогда все выражение повышается до float. Если 
какой-либо из операндов имеет тип douЫe, то результат будет иметь тип 
double. 
</details>

<details><summary>Массивы</summary>
  
**Массив** - это группа переменных одного типа, к которой можно обращаться по общему имени. Можно создавать массивы любого типа с одним или большим количеством измерений.

<details><summary>Одномерные массивы</summary>
Одномерный массив по существу представляет собой список переменных одного типа. 

```html 
переменная-типа-массива = new тип [размер]; 
```
new - это специальная операция, которая выделяет память. 

Здесь тип указывает тип размещаемых в памяти данных, размер устанавливает количество элементов в массиве, а переменная-типа-массива представляет собой переменную, связанную с массивом. То есть, чтобы использовать 
new для размещения массива, вы должны указать тип и количество элементов в 
массиве. 

```html 
month_days = new int [12]; 
```
После выполнения этого оператора month_days будет ссылаться на массив 
из 12 целых чисел. Вдобавок все элементы в массиве будут инициализированы нулем. Имеет смысл повторить: получение массива - двухэтапный процесс. Во-первых, вы обязаны объявить переменную нужного типа массива. Во-вторых, вы должны выделить память, в которой будет храниться массив, с применением операции new и назначить ее переменной типа массива. Таким образом, в Java все массивы размещаются в памяти динамически

[Chapter03/Array - Продемонстрировать применение одномерного массива](https://github.com/Vladlena2/BookJava/blob/main/Chapter3/Array.java "Посмотреть пример Java")

[Chapter03/CountDayArray - Усовершенствованная версия предыдущей программы](https://github.com/Vladlena2/BookJava/blob/main/Chapter3/CountDayArray.java "Посмотреть пример Java")


</details>

<details><summary>Многомерные массивы</summary>
Многомерные массивы в Java реализованы как массивы массивов.

[Chapter03/DuoArray - Пример двумерного массива](https://github.com/Vladlena2/BookJava/blob/main/Chapter3/DuoArray.java "Посмотреть пример Java")

[Chapter03/ThreeArray - Пример трехмерного массива](https://github.com/Vladlena2/BookJava/blob/main/Chapter3/ThreeArray.java "Посмотреть пример Java")
  
Хотя в такой ситуации индивидуальное размещение массивов второго измерения не дает каких-то преимуществ, в других случаях такие преимущества 
могут быть. Скажем, при выделении памяти под измерения по отдельности 
вам не нужно размещать одинаковое количество элементов для каждого измерения. Как утверждалось ранее, поскольку многомерные массивы на самом 
деле являются массивами массивов, длина каждого массива находится под 
вашим контролем. Например, в следующей программе создается двумерный 
массив, в котором размеры массивов во втором измерении не равны:

[Chapter03/TwoDAgain - Резервирование памяти вручную для массива с разной размерностью второго измерения]([https://github.com/Vladlena2/BookJava/blob/main/Chapter3/TwoDAgain.java "Посмотреть пример Java")

Ст упенчатые (или нерегулярные) многомерные массивы могут оказаться 
неподходящими для многих приложений, потому что они противоречат тому, 
что люди ожидают найти при встрече с многомерным массивом. Однако в некоторых ситуациях нереrу лярные массивы можно эффективно использовать. 
Скажем, если вам нужен очень большой разреженный двумерный массив (т.е. 
такой, rде задействованы не все элементы), тогда нерегулярный массив может стать идеальным решением

Также обратите внимание, что внутри инициализаторов массивов можно применять выражения и литеральные значения. 

Существует вторая форма объявления массива:
```html 
тип имя-переменной[ ];
char twodl[][] = new char[3][4] ;  
```
Эта альтернативная форма объявления обеспечивает удобство при преобразовании кода из С/С++ в Java. Кроме того, она позволяет объявлять в одном операторе объявления и переменные с типами массивов, и переменные 
с типами, отличающимися от массивов. В настоящее время альтернативная 
форма используется реже, но знать ее по-прежнему важно, поскольку в Java 
разрешены обе формы объявления массивов. 

</details>
</details>

<details><summary>Знакомство с выведением типов локальных переменных</summary>
  
В Java, начиная с версии 10, была внедрена возможность автоматического выведения типов локальных переменных. Это означает, что в некоторых случаях компилятор может определить тип переменной на основе значения, которое ей присваивается. Это упрощает объявление переменных и делает код более читаемым и компактным.

```html 
var variableName = assignedValue;
```
- var: ключевое слово, которое заменяет объявление типа переменной.
- variableName: имя переменной.
- assignedValue: значение, которое присваивается переменной.

Примеры использования:

1. Инференция типа с примитивами
```html 
var number = 10; // number имеет тип int.
var pi = 3.14159; // pi имеет тип double.
```
2. Инференция типа с объектами
```html 
var message = "Hello, World!"; // message имеет тип String.
var list = new ArrayList<Integer>(); // list имеет тип ArrayList<Integer>.
```
3. Инференция типа в циклах
```html 
var numbers = new int[] { 1, 2, 3, 4, 5 };
for (var number : numbers) {
    // number имеет тип int внутри цикла.
}
```
4. Смешанное использование с объявлением типа
```html 
var x = 5; // x имеет тип int.
int y = 10;
var result = x + y; // result имеет тип int.
``` 
5. Инференция типа с массивами
```html 
var numbers = new int[] { 1, 2, 3, 4, 5 }; // numbers имеет тип int[].
var names = new String[] { "Alice", "Bob", "Charlie" }; // names имеет тип String[].
``` 
6. Смешанное использование инференции типа и объявления типа
```html 
var scores = new int[] { 90, 85, 78 };
int[] grades = { 88, 92, 76 };
```

**Ограничения.** Можно 
объявлять только одну переменную за раз, для переменной нельзя использовать null в качестве инициализатора и объявляемая переменная не может 
присутствовать в выражении инициализатора. Хотя с применением var можно объявить тип массива, ключевое слово var нельзя использовать с инициализатором массива. 
Как отмечалось ранее, ключевое слово var не разрешено применять для 
имени класса. Его также не допускается использовать в качестве имени других ссылочных типов, включая интерфейс, перечисление или аннотацию, 
либо в качестве имени параметра обобщенного типа. Выведение типов локальных переменных нельзя применять для объявления типа исключения, перехваченного оператором 
catch. Кроме того, ни лямбда-выражения, ни ссылки на методы не разрешено использовать в качестве инициализаторов.
</details>

</blockquote>
</details>

<details ГЛАВА 4><summary>ГЛАВА 4. "Операции"</summary>
<blockquote>

<details><summary>Арифметические операции</summary>

Основные арифметические операции - сложение, вычитание, умножение 
и деление - ведут себя так, как и следовало ожидать для всех числовых типов. Унарный минус инвертирует свой единственный операнд. Унарный плюс 
просто возвращает значение своего операнда. Помните, что когда операция 
деления применяется к целочисленному типу, дробная часть к результату не 
присоединяется.

[Chapter04/BasicMath - Продемонстрировать основные арифметические операции](https://github.com/Vladlena2/BookJava/blob/main/Chapter4/BasicMath.java "Посмотреть пример Java")

[Chapter04/Modulus - Операция деления по модулю "%" (возвращает остаток от деления)](https://github.com/Vladlena2/BookJava/blob/main/Chapter4/Modulus.java "Посмотреть пример Java")

Составные операции присваивания обеспечивают два преимущества. Во-первых, они уменьшают объем набираемоrо кода, потому что являются "сокращенной формой" для своих длинных эквивалентов. Во-вторых, в некоторых случаях они более эффективны, чем их длинные эквиваленты. По указанным причинам составные операции присваивания часто используются в профессионально написанных программах на Java. 

[Chapter04/OpEquals - Составные операции с присваиванием](https://github.com/Vladlena2/BookJava/blob/main/Chapter4/OpEquals.java "Посмотреть пример Java")

Операции инкремента и декремента. Приведенные операции уникальны тем, что могут встречаться и в постфиксной форме, когда они следуют за операндом, как было только что показано, и в префиксной форме, когда они предшествуют операнду. В предшествующих примерах никаких отличий между префиксной и постфиксной формами 
не было. Однако когда операторы инкремента и/или декремента входят в состав более крупного выражения, то между этими двумя формами проявляется тонкая, но важная разница. В префиксной форме операнд инкрементируется или декрементируется перед получением значения для использования 
в выражении. В постфиксной форме предыдущее значение извлекается для 
применения в выражении, после чего модифицируется операнд. Например:

```html 
х = 42; 
у = ++х;
равно
х = х + 1; 
у = х; 
```

```html 
х = 42; 
у = х++; 
равно
у = х; 
х = х + 1;
```
</details>

<details><summary>Побитовые операции</summary>

**Поразрядные операции в Java**
```  
"~"    - Поразрядная унарная операция НЕ  
"&"    - Поразрядная логическая операция И  
"|"    - Поразрядная логическая операция ИЛИ  
"^"    - Поразрядная логическая операция исключающее ИЛИ  
">>"   - Сдвиг вправо  
">>>"  - Сдвиг вправо с заполнением нулями  
"<<"   - Сдвиг влево  
"&="   - Поразрядная логическая операция И с присваиванием  
"|="   - Поразрядная логическая операция ИЛИ с присваиванием  
"^="   - Поразрядная логическая операция исключающее ИЛИ с присваиванием  
">>="  - Сдвиг вправо с присваиванием  
">>>=" - Сдвиг вправо с заполнением нулями и присваиванием  
"<<="  - Сдвиг влево с присваиванием  
```

В Java используется кодировка, известная как доnоанение до двух или 
доnоАнumеАьный код, которая предусматривает представление отрицательных 
чисел путем инвертирования (замены единиц на нули и наоборот) всех битов в значении и последующего добавления единицы к результату. Например, 
для представления -42 инвертируются все биты в 42, или 00101010, что дает 
1 1010101, после чего к результату добавляется 1, давая в итоге 1 1010110, или 
-42. Чтобы декодировать отрицательное число, необходимо инвертировать 
все биты и добавить 1. Например, -42, или 1 10101 10, в результате инвертирования дает 00101001, или 41, а после добавления 1 получается 42

Особенности представления нуля и отрицательных чисел для значений типа byte (и других целочисленных типов).

Для представления нуля в дополнительном коде, инвертируете все биты, и в результате получаете "11111111". Это инвертированное представление нуля, которое обычно не используется в целочисленной арифметике.

Для решения этой проблемы и представления отрицательных значений используется дополнение до двух. Когда к инвертированному значению добавляется 1, возникает следующее:

"11111111" (инвертированное значение) + 1 = "100000000"
Однако, восьмой бит (самый левый бит) в byte не умещается, и он обрезается. Таким образом, "100000000" на самом деле становится "00000000" в byte, что является представлением нуля в дополнительном коде до двух. Это "ноль" совпадает с нулем, и весьма удобно для работы в целочисленной арифметике.

Этот метод представления нуля и отрицательных чисел позволяет правильно работать с арифметикой и легко определять граничные случаи.

Во избежание неприятных сюрпризов 
просто помните, что старший бит определяет знак целого числа независимо 
от того, как он был установлен. 

[Chapter04/BitLogic - Продемонстрировать применение поразрядных логических операций](https://github.com/Vladlena2/BookJava/blob/main/Chapter4/BitLogic.java "Посмотреть пример Java")

**Сдвиг влево**

Здесь число устанавливает количество позиций для сдвига влево значения. 
То есть операция << перемещает все биты в указанном значении влево на 
количество битовых позиций, заданное в числе. При каждом сдвиге влево 
старший бит смещается (и утрачивается), а справа вставляется ноль. Это означает, что когда к операнду int применяется сдвиг влево, биты теряются, 
как только они сдвигаются за битовую позицию 31. В случае операнда типа 
long биты утрачиваются после битовой позиции 63. 
При сдвиге значений byte и short автоматическое повышение типов в 
Java приводит к неожиданным результатам. Как вы знаете, во время вычисления выражения значения byte и short повышаются до int. Кроме того, результат такого выражения тоже имеет тип int. Это означает, что результатом 
сдвига влево значения byte или short будет значение int, а биты, сдвинутые 
влево, не будут утрачены до тех пор, пока они не сместятся за битовую позицию 31. Вдобавок отрицательное значение byte или short при повышении до 
int будет расширено знаком. Таким образом, старшие биты будут заполнены 
единицами. По указанным причинам выполнение сдвига влево значения byte 
или short подразумевает необходимость отбрасывания старших байтов из 
результата типа int. Например, при сдвиге влево значения byte оно сначала 
повышается до int, после чего сдвигается. Если нужно получить результат 
сдвинутого значения byte, то придется отбросить три старших байта результата. Самый простой способ решить задачу - преобразовать результат обратно в byte.

**Сдвиг вправо**

При выполнении сдвига вправо старшие (крайние слева) биты, открытые 
сдвигом, заполняются предыдущим содержимым старшего бита. Это называется расширением знака и служит для сохранения знака отрицательных чисел 
при их сдвиге вправо. Например, -8 >> 1 равно -4, что в двоичном виде выглядит так: 

```html 
1111 1000 -8 
>> 1 
11111 100 -4 
```

Интересно отметить, что в случае сдвига вправо значения -1 результат 
всегда остается -1, т.к. расширение знака будет приводить к большему количеству единиц в старших битах. 
Иногда расширять знаки значений при сдвиге вправо нежелательно. 

Скажем, в приведенной далее программе значение byte преобразуется в 
шестнадцатеричное строковое представление. Обратите внимание, что сдвинутое значение маскируется с помощью операции И с 0x0f для отбрасывания 
любых битов, дополненных знаком, чтобы значение можно было использовать в качестве индекса в массиве шестнадцатеричных символов. 

[Chapter04/HexByte - Маскирование двоичных разрядов расширения знака](https://github.com/Vladlena2/BookJava/blob/main/Chapter4/HexByte.java "Посмотреть пример Java")

**Беззнаковый сдвиг вправо**
Как только что объяснялось, операция >> автоматически заполняет старший бит его предыдущим содержимым каждый раз, когда происходит сдвиг, 
сохраняя знак значения. Тем не менее, иногда это нежелательно. Например, 
при выполнении сдвига чего-то, что не представляет собой числовое значение, расширение знака может оказаться ненужным. Такая ситуация часто встречается при работе с пиксельными значениями и графикой. В ситуациях 
подобного рода обычно требуется помещать в старший бит ноль вне зависимости от того, каким было его начальное значение. Прием известен как беззнаковый сдвиг и предусматривает применение операции беззнакового сдвига 
вправо, >>>, которая всегда задвигает нули в старший бит. 
аво, >>>, которая всегда задвигает нули в старший бит. 

В следующем фрагменте кода демонстрируется работа операции >>>. 
Здесь значение а устанавливается в -1, что приводит к установке всех 32 бит 
в 1. Затем значение сдвигается вправо на 24 позиции с заполнением старших 
24 бит нулями и игнорированием расширения знака. В итоге а устанавливается в 255. 

```html 
int a = -1; 
а = а >>> 24;
```

Ниже показана та же самая операция в двоичной форме с целью дополнительной иллюстрации того, что происходит:
```html 
11111111 11111111 11111111 11111111 -1 в двоичном виде
>>24 
00000000 00000000 00000000 11111111 255 в двоичном виде
```
Операция >>> часто не настолько полезна, как хотелось бы, поскольку 
она имеет смысл только для 32- и 64-битных значений. Вспомните, что при 
вычислении выражений меньшие значения автоматически повышаются до 
int. В итоге происходит расширение знака, и сдвиг будет выполняться над 
32-битным, а не 8- или 16-битным значением. То есть можно ожидать, что 
беззнаковый сдвиг вправо значения byte заполнит нулями, начиная с бита 7. 
Но это не так, поскольку на самом деле сдвигается 32-битное значение. 
Эффект демонстрируется в следующей программе:


[Chapter04/ByteUShift - Сдвиг влево значения типа byte](https://github.com/Vladlena2/BookJava/blob/main/Chapter4/ByteUShift.java "Посмотреть пример Java")

В показанном ниже выводе программы видно, что при работе с байтами 
операция >>> ничего не делает. Для данной демонстрации переменной Ь присваивается произвольное отрицательное значение типа byte. Затем переменной с присваивается значение Ь типа byte, сдвинутое вправо на четыре позиции, которое равно Oxff из-за ожидаемого расширения знака. Далее 
переменной d присваивается значение Ь типа byte с беззнаковым сдвигом 
вправо на четыре позиции, которым вопреки ожидаемому OxOf будет Oxff 
по причине расширения знака, происшедшего при повышении Ь до int перед сдвигом. Последнее выражение устанавливает переменную е в значение 
Ь типа byte, маскированное до 8 бит с помощью операции И, после чего 
сдвинутое вправо на четыре позиции, что дает ожидаемое значение OxOf. 
Обратите внимание, что операция беззнакового сдвига вправо не использовался для переменной d, т.к. состояние знакового бита после операции И 
было известно. 

Сравнение знакового и беззнакового сдвига:

```html 
int value = -8;  // Значение -8
int result = value >> 1;  // Знаковый сдвиг вправо на 1 бит
System.out.println("Результат: " + result);
```
В этом примере, value равно -8, а value >> 1 сдвигает значение на 1 бит вправо. Ожидается, что результат будет -4, потому что знаковый сдвиг сохраняет знак (в данном случае, отрицательный).

```html 
int value = -8;  // Значение -8
int result = value >>> 1;  // Беззнаковый сдвиг вправо на 1 бит
System.out.println("Результат: " + result);
```
Результат беззнакового сдвига >>> будет положительным числом 2147483644, что произошло из-за того, что знаковый бит был сброшен. Это демонстрирует разницу между знаковым и беззнаковым сдвигами. В контексте данного вопроса о беззнаковых сдвигах, можно сказать, что они "избегают влияния знакового бита".

</details>

<details><summary>Операции отношения</summary>

**Операции отношения(сравнения)**
```
"=="   - Равно  
"!="   - Не равно  
">"    - Больше
"<"    - Меньше  
">="   - Больше или равно  
"<="   - Меньше или равно
```

Результатом этих операций является значение boolean. Операции отношения чаще всего используются в выражениях, управляющих оператором i f и 
различными операторами циклов. 

Как уже упоминалось, результатом операции отношения будет значение 
boolean. Например, следующий фрагмент кода совершенно корректен:

```html 
int а= 4; 
int Ь = 1; 
boolean с = а < Ь;
```
В данном случае в переменной с сохраняется результат выполнения а<Ь 
(равный false). 

Если ранее вы работали с С/С++, то обратите внимание, что в программах 
на С/С++ весьма распространены следующие виды операторов:

```html 
int done; 
// ... 
if ( ! done ) // Допустимо в С/ С++ ,  
if ( done) // но не в Java
```

В коде Java такие операторы должны быть записаны так, как показано ниже: 

```html 
if ( done == О ) // Стиль Java . 
if (done != О) 
```
Причина в том, что истинное и ложное значения в Java определены не так, 
как в С/С++. В языках С и С++ истинным является любое ненулевое значение, а ложным - ноль. В Java true и false представляют собой нечисловые значения, которые никак не связаны с нулем или ненулевым значением. 
Следовательно, для проверки на предмет равенства или неравенства нулю 
должна явно применяться одна или несколько операций отношения. 

**Логические операции**
```
&  - Логическая операция И  
|  - Логическая операция ИЛИ  
^  - Логическая операция исключающее ИЛИ  
|| - Укороченная логическая операция ИЛИ  
&& - Укороченная логическая операция И  
!  - Логическая унарная операция НЕ  
&= - Логическая операция И с присваиванием  
|= - Логическая операция ИЛИ с присваиванием  
^= - Логическая операция исключающее ИЛИ с присваиванием  
== - Равенство  
!= - Неравенство  
?: - Тернарная условная операция типа если"., то"., иначе".
```

В языке Java померживаются две интересные булевские операции, отсутствующие в ряде других языков программирования. Речь идет о вспомогательных версиях булевских операций И и ИЛИ, широко известные как 
короткозамкнутые логические операции. В табл. легко заметить, что результатом операции ИЛИ будет true, когда А имеет значение t rue вне зависимости от значения В. Аналогично операция И дает результат false, когда 
А равно false безотносительно к тому, какое значение имеет В. В случае применения форм || и && вместо форм | и & указанных операций Java правый 
операнд не будет вычисляться в ситуации, когда результат выражения может 
быть определен только левым операндом. Это очень полезно, когда правильное функционирование предусматривает зависимость правого операнда от 
левого. В приведенном ниже фрагменте кода показано, как можно использовать в своих интересах короткозамкнутое логическое вычисление, чтобы 
убедиться в допустимости операции деления до ее выполнения:

```html 
if (denom 1 = О && num / denom > 10)
```

Поскольку применяется короткозамкнутая форма операции И (&&), нет 
риска вызвать исключение во время выполнения, когда переменная denom 
равна нулю. Если бы данная строка кода была написана с использованием 
односимвольной версии операции &, то вычислялись бы обе стороны выражения, приводя к исключению во время выполнения, когда значение denom 
равно нулю. 
Стандартная практика предусматривает применение короткозамкнутых 
форм И и ИЛИ в случаях, связанных с булевской логикой, оставляя односимвольные версии исключительно для побитовых операций. Однако из этого правила есть исключения. Например, взгляните на оператор следующего 
вида: 

```html 
if (c==1 & е++ < 100) d = 100;
```
 
Здесь использование версии & гарантирует, что операция инкремента будет применена к е независимо от того, имеет переменная с значение 1 или нет.

## Операция ?

В Java предусмотрена специальная тернарная операция, которая способна 
з аменить определенные виды операторов "если-то-иначе': Она обозначается 
с помощью знака ?.

Вот общий вид операции ?: 

```html 
выражение1 ? выражение2 : выражениеЗ
```

десь выражение1 может быть л юбым выражением, результатом которого является значение boolean. Если результатом выражения1 является true, 
тогда вычисляется выражение2, а иначе выражениеЗ. Результатом операции ? 
будет результат вычисленного выражения. Типы результатов выражения2 и 
выражениеЗ должны быть одинаковыми (или совместимыми) и не могут быть 
void. Ниже показан пример применения операции ?: 

```html 
ratio = denom == О ? О : num / denom; 
```

При вычислении этого выражения присваивания сначала просматривается 
выражение слева от вопросительного знака. Если значение denom равно нулю, 
тогда вычисляется выражение между вопросительным знаком и двоеточием 
и используется в качестве значения всего выражения ?. Если значение denom 
не равно нулю, то вычисляется выражение после двоеточия и становится значением всего выражения ?. Затем результат операции ? присваивается переменной ratio. 

[Chapter04/Ternary - Продемонстрировать применение тернарной операции "?"](https://github.com/Vladlena2/BookJava/blob/main/Chapter4/Ternary.java "Посмотреть пример Java")

## Старшинство операций

Вот некоторые основные операторы Java, упорядоченные по приоритету (от более высокого приоритета к более низкому):

1. Постфиксные операторы: expr++, expr-- (например, инкремент и декремент).
2. Префиксные операторы: ++expr, --expr, +expr, -expr, !expr, ~expr (например, инкремент, декремент, унарный плюс, унарный минус и т. д.).
3. Умножение и деление: *, /, % (умножение, деление и остаток от деления).
4. Сложение и вычитание: +, -.
5. Сдвиги: <<, >>, >>> (побитовые сдвиги влево и вправо).
6. Отношения: <, >, <=, >=, instanceof.
7. Равенство: ==, !=.
8. Побитовое "И": &.
9. Побитовое "ИЛИ": |.
10. Побитовое "Исключительное ИЛИ": ^.
11. Логическое "И" (AND): &&.
12. Логическое "ИЛИ" (OR): ||.
13. Условный оператор: ? :.
14. Присваивание: =, +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=, >>>=.
15. Выражение запятой: , (для последовательного выполнения выражений).

Если операции имеют одинаковый приоритет, то их выполнение определяется ассоциативностью (слева направо или справа налево). Например, операции сложения и вычитания выполняются слева направо, поэтому a + b - c будет интерпретировано как (a + b) - c.

И еще один момент: круглые скобки (избыточные или нет) не ухудшают 
производительность программы. Таким образом, добавление круглых скобок 
для уменьшения неоднозначности не повлияет отрицательно на вашу программу.

</details>

</blockquote>
</details>

<details ГЛАВА 5><summary>ГЛАВА 5. "Управляющие операторы"</summary>
<blockquote>

<details><summary>Операторы выбора</summary>

## Оператор switch 

Как функционирует традиционный оператор switch: з начение 
выражения сравнивается с каждым значением в операторах case. Если совпадение найдено, то выполняется кодовая последовательность, следующая 
за оператором case. Если ни одна из констант не соответствует значению 
выражения, тогда выполняется оператор default. Однако оператор default 
необязателен. Если ни один из операторов case не дает совпадения, а оператор default отсутствует, то дальнейшие действия не предпринимаются.

Иногда желательно иметь несколько case без операторов break 
между ними. 

[Chapter05/MissingBreak - Продемонстрировать применение case без операторов break ].(https://github.com/Vladlena2/BookJava/blob/main/Chapter5/MissingBreak.java "Посмотреть пример Java")

Ниже демонстрируется его более реалистичное использование в 
переработанной программе определения принадлежности месяца к временам 
года. Теперь в нем применяется оператор switch для обеспечения более эффективной реализации. 

[Chapter05/Switch - Продемонстрировать более реалистичное использование case без операторов break ].(https://github.com/Vladlena2/BookJava/blob/main/Chapter5/Switch.java "Посмотреть пример Java")

Возможность применения строк в операторе switch упрощает код во многих ситуациях. Скажем, использовать switch на основе строк эффективнее 
по сравнению с эквивалентной последовательностью операторов if/еlsе. 
Тем не менее, выполнение оператора switch по строкам может оказаться более затратным, чем по целым числам. Таким образом, лучше всего применять 
switch на основе строк только в тех случаях, когда управляющие данные уже 
представлены в строковой форме. Другими словами, не используйте строки в 
switch без настоятельной необходимости. 

Вы можете применять switch как часть последовательности операторов 
внешнего switch. Он называется вложенным оператором switch. Поскольку 
оператор swi tch определяет собственный блок, между константами case 
во внутреннем switch и во внешнем switch конфликты не возникают. 

Подводя итоги, важно отметить три особенности оператора switch. 

• Оператор switch отличается от if тем, что он может проверять только 
на предмет равенства, тогда как оператор if способен оценивать логическое выражение любого вида. То есть switch ищет только совпадение 
значения выражения с одной из констант в операторах case. 

• Никакие две константы case в одном switch не могут иметь одинаковые значения. Разумеется, один оператор switch и включающий его 
внешний switch могут иметь общие константы case. 

• Оператор switch обычно более эффективен, чем набор вложенных операторов i f. 
Последний пункт особенно интересен, потому что он дает представление о 
том, как работает компилятор Java. При компиляции оператора switch компилятор Java проверит каждую константу case и создаст "таблицу переходов'; 
которую будет использовать для выбора пути выполнения в зависимости от 
значения выражения. Следовательно, есл и вам нужно делать выбор среди 
большой группы значений, то оператор switch будет работать намного быстрее, чем эквивалентная логика, реализованная с применением последовательности if-else. Компилятор способен добиться этого, т.к. ему известно, 
что все константы case имеют один и тот же тип и просто должны сравниваться на равенство с выражением switch. Что касается подобного знания 
длинного списка выражений if, то компилятор им не располагает.

</details> 

<details><summary>Операторы выбора</summary>

## Цикл while 

Тело цикла while (или любого дpyroro цикла Java) может быть пустым. 
Дело в том, что в Java синтаксически допустим пустой оператор (состоящий 
только из точки с запятой). Взгляните на следующую программу: 

[Chapter05/NoBody - Продемонстрировать пустой while](https://github.com/Vladlena2/BookJava/blob/main/Chapter5/NoBody.java "Посмотреть пример Java")

Рассмотрим, как работает этот цикл while. Значение i инкрементируется, 
а значение j декрементируется. Затем значения i и j сравниваются друг с 
другом. Если новое з начение i все еще меньше нового значения j, тогда цикл 
повторяется. Если значение i больше или равно значения j, то цикл останавливается. После выхода из цикла переменная i будет хранить значение, которое находится посередине между исходными значениями i и j. (Конечно, такая процедура работает только тогда, когда i меньше j .) Понятно, что здесь 
нет необходимости иметь тело цикла; все действие происходит внутри самого условного выражения. В профессионал ьно написанном коде на Java короткие циклы часто кодируются без тел, коrда управляющее выражение способно самостоятельно обрабатывать все детали. 

Как вы только что видели, если условное выражение, управляющее циклом 
while, изначально ложно, то тело цикла вообще не будет выполнено. Однако 
иногда тело цикла желател ьно выполнить хотя бы один раз, даже если изначально условное выражение ложно. Другими словами, бывают случаи, когда 
вы хотели бы проверять выражение завершения в конце цикла, а не в ero начале. К счастью, в Java есть цикл, который делает именно это: do-while.

## Цикл for 

Рассмотрим работу цикла for. При первом запуске цикла выполняется 
часть инициализация цикла. В общем случае она представляет собой выражение, которое устанавливает значение переменной управления циклом, которая действует в качестве счетчика, управляющего циклом. Важно понимать, 
что инициализирующее выражение выполняется только один раз. Затем вычисляется условие, которое должно быть булевским выражением. Как правило, оно сравнивает переменную управления циклом с целевым значением. 
Есл и условие истинно, тогда выполняется тело цикла, а если ложно, то цикл 
завершается. Далее выполняется часть итерация цикла, которая обычно является выражением, инкрементирующим или декрементирующим перенную управления циклом. После этого цикл повторяется, при каждом проходе 
вычисляя условное выражение, выполняя тело цикла и вычисляя выражение 
итерации. Такой процесс происходит до тех пор, пока управляющее выражение не станет ложным. 


При объявлении переменной внутри цикла for следует помнить об одном 
важном аспекте: область видимости этой переменной ограни чена циклом 
for. За пределами цикла for переменная перестает существовать. Если переменную управления циклом необходимо применять в другом месте программы, тогда объявлять ее внутри оператора for нельзя.

Чтобы позволить двум и более переменным управлять циклом for, в части инициализация и итерация цикла for разрешено 
включать несколько операторов, разделяя их запятыми. 

Есть еще одна интересная разновидность цикла for, в которой может отсутствовать либо часть инициализация, либо часть итерация, либо то и другое, как демонстрируется в следующей программе

## Цикл for-each

Общая форма версии "for-each" цикла for выглядит следующим образом: 
for ( тип переменная-итерации : коллекция) блок-операторов 
Здесь тип указывает тип, а переменная-итерации - имя переменной 
итерации, которая будет получать элементы из коллекции по одному за 
раз, от начала до конца. Коллекция, по которой проходит цикл, указывается в коллекции. Существуют различные типы коллекций, которые можно использовать с for, но в настоящей главе применяется только массив.
На каждой итерации цикла из коллекции из влекается очередной элемент и сохраняется в 
переменной-итерации. Цикл повторяется до тех пор, пока не будут получены 
все элементы коллекции. 
Поскольку переменная итерации получает з начения из коллекции, тип 
обязан совпадать или быть совместимым с типом элементов, хранящихся в коллекции. Таким образом, при проходе по массивам тип должен быть совместимым с типом элементов массива.

Чтобы понять мотивы создания цикла в стиле "for-each'; рассмотрим тип 
цикла for, который он призван заменить. В следующем фрагменте кода для 
вычисления суммы значений в массиве применяется традиционный цикл for:
```html 
int [] nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 1 0 } ; 
int sum = О; 
for ( int i=0 ; i < 10 ; i++ ) sum += nums [i]; 
```

Стиль "for-each" цикла for позволяет автоматизировать предыдущий цикл. 
В частности, он избавляет от необходимости устанавливать счетчик циклов, 
указывать начальное и конечное значение и вручную индексировать массив. 
Взамен он автоматически проходит по всему массиву, получая по одному элементу за раз, последовательно, от начала до конца. Например, вот предыдущий фрагмент, переписанный с применением версии цикла for в стиле "for-each": 
```html 
int [] nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 } ; 
int sum = О; 
for ( int х: nums ) sum += х;
```

При каждом проходе цикла переменной х автоматически присваивается 
значение, равное очередному элементу в nums. Таким образом, на первой итерации х содержит 1, на второй - 2 и т.д. Синтаксис не только стал проще, но 
он также предотвращает возникновение ошибок выхода за границы массива.

Существует один аспект, касающийся цикла for в стиле "for-each'; который важно понимать. Его переменная итерации доступна только для чтения, 
хотя она связана с лежащим в основе массивом. Присваивание значения переменной итерации не влияет на лежащий в основе массив. Другими словами, 
изменить содержимое массива, присваивая переменной итерации новое значение, не удастся. 

Расширенная версия for работает также и с мноrомерными массивами. 
Но не забывайте о том, что мноrомерные массивы в Java представляют собой массивы массивов. (Например, двумерный массив - это массив одномерных массивов.) Данный факт важен при проходе по многомерному массиву, 
поскольку на каждой итерации получается очередной массив, а не индивидуальный элемент. Кроме тоrо, переменная итерации в цикле for должна быть 
совместимой с типом пол учаемоrо массива. Например, в случае двумерноrо 
массива переменная итерации должна быть ссылкой на одномерный массив.

```html 
for (int [] х : nums ) { 
for ( i nt у: х) { 
System.out.println ( " Знaчeниe : "+у); 
sum += у; 
System.out.println ( "Сумма : " + sum ) ; 
```

Обратите внимание на то, как объявлена переменная х. Она является 
ссылкой на одномерный массив целых чисел. Необходимость в таком объявлении связана с тем, что на каждой итерации цикла for получается очередной массив из nums, начиная с массива nums[0]. Затем во внутреннем цикле 
for производится проход по каждому из этих массивов с отображением значения каждого элемента. 

Выведение типов локальных 
переменных можно применять в цикле for при объявлении и инициализации 
переменной управления циклом внутри традиционноrо цикла for или при 
указании переменной итерации в цикле for в стиле "for-each': В следующей 
проrрамме демонстрируются примеры каждою случая: 

[Chapter05/TypeInFerenceInFor - Продемонстрировать пустой while](https://github.com/Vladlena2/BookJava/blob/main/Chapter5/TypeInFerenceInFor.java "Посмотреть пример Java")

</details> 

<details><summary>Операторы перехода</summary>

В Java поддерживаются три оператора перехода: break, continue и return. 

Помимо обсуждаемых здесь операторов перехода в Java есть еще один способ, с 
помощью котороrо можно изменить поток выполнения программы: через обработку 
исключений. Обработка исключений обеспечивает структурированный подход, с помощью 
которого программа может перехватывать и обрабатывать ошибки во время выполнения. 
Он поддерживается ключевыми словами try, catch, throw, throws и finally. По 
существу механизм обработки исключений позволяет программе выполнять нелокальный 
переход. Поскольку обработка исключений является обширной темой, она обсуждается 
отдельно в главе 1О. 

## Оператор break

Оператор break в языке Java применяется в трех ситуациях. Во-первых, 
как вы видели, он завершает последовательность операторов в операторе 
swi tch. Во-вторых, его можно использовать для выхода из цикла. В-третьих, 
его можно применять как "цивилизованную" форму перехода в стиле "goto'.

Однако будьте осторожны. Слишком большое количество операторов break 
способно деструктурировать код. Во-вторых, оператор break, завершающий 
switch, влияет только на этот оператор switch, но не на любые объемлющие 
циклы. 

Оператор break не задумывался как обычное средство завершения цикла. Для этой цели 
предназначено условное выражение цикла. Оператор break должен применяться для 
прекращения работы цикла только в случае возникновения какой-то особой ситуации. 

В дополнение к применению с оператором switch и циклами оператор 
break также может использоваться сам по себе, чтобы обеспечить "цивилизованную" форму перехода в стиле "goto': В языке Java нет оператора "goto'; т.к. 
он обеспечивает возможность ветвления произвольным и неструктурированным образом, что обычно затрудняет понимание и сопровождение кода, опирающегося на переходы в стиле "goto': Кроме того, "goto" препятствует некоторым оптимизациям со стороны компилятора. Тем не менее, есть несколько 
мест, где переходы в стиле "goto" будут ценной и законной конструкцией для 
управления потоком. Например, переход в стиле "goto" может быть полезен 
при выходе из глубоко вложенных циклов. Для обработки таких ситуаций в 
Java определена расширенная форма оператора break. С применением такой 
формы break можно, например, выходить из одного или нескольких блоков 
кода, которые не обязательно должны являться частью цикла или переключателя, а могут быть любыми. Более того, можно точно указывать, где будет 
возобновлено выполнение, т.к. расширенная форма оператора break работает с меткой. Как вы увидите, break обеспечивает преимущества перехода в 
стиле "goto" без присущих ему проблем. 

Чаще всего метка представляет собой имя маркера, идентифицирующего 
блок кода. Блок кода может быть как автономным, так и блоком, являющимся целью другого оператора. При выполнении расширенной формы оператора break поток управления покидает блок, указанный в break. Снабженный 
меткой блок должен охватывать оператор break, но не обязательно быть тем, 
который содержит в себе этот break непосредственно. Отсюда следует, на пример, что оператор break с меткой можно использовать для выхода из набора вложенных блоков. Но применять break для передачи управления из 
блока, который не охватывает данный оператор break, нельзя. 
Чтобы назначить блоку имя, необходимо поместить в его начало метку. 
Метка - это любой допустимый идентификатор Java, за которым следует 
двоеточие. После пометки блока метку можно использовать в качестве цели 
оператора break, что приведет к возобновлению выполнения после конца 
помеченного блока. Например, в показанной далее программе реализованы 
три вложенных блока, каждый со своей меткой. Оператор break передает 
управление вперед, за конец блока с меткой second, пропуская два оператора 
println(). 

[Chapter05/BreakLoop4 - Продемонстрировать пустой while](https://github.com/Vladlena2/BookJava/blob/main/Chapter5/BreakLoop4.java "Посмотреть пример Java")

Имейте в виду, что использовать оператор break с меткой, которая определена не для охватывающего блока, не разрешено. Например, следующая 
программа содержит ошибку и компилироваться не будет: 

```html 
// Эта программа содержит ошибку . 
class BreakErr { 
public static void main(String[] args ) 
one: for (int i=O ; i<З ; i++ ) { 
System.out.print( " Пpoxoд " + i + "· " ) ; 
for (int j = O; j<lOO; j ++) { 
if (j == 10) break one ; // ОШИБКА 
System.out.print (j +" " ) ; 
}
}
}
```

Поскольку цикл, помеченный как one, не охватывает оператор break, передать управление из этого блока невозможно

## Оператор continue

Иногда необходимо обеспечить, чтобы итерация цикла выполнилась 
раньше, до достижения конца тела. То есть выполнение цикла должно продолжаться, но без обработки остатка кода в его теле для конкретной итерации. По сути, это переход в конец цикла. Такое действие реализует оператор 
continue. В циклах while и do-while оператор conti nue передает управление напрямую условному выражению, управляющему циклом. В цикле for 
управление передается сначала итерационной части оператора for, а затем 
условному выражению. Для всех трех циклов любой промежуточный код 
пропускается. 

Как и в случае с break, в операторе continue можно указывать метку для 
описания того, какой объемлющий цик л необходимо продолжить.

## Оператор return 

Последний управляющий оператор - return. Он применяется для явного 
возвращения из метода, т.е. управление программой передается обратно вызывающей стороне. Таким образом, return классифицируется как оператор 
перехода. Хотя подробное обсуждение оператора return следует отложить 
до обсуждения методов в главе 6, здесь представлен его краткий обзор. 
Оператор re turn можно использовать в любом месте метода, чтобы 
возвратить управление вызывающей стороне. Таким образом, оператор 
return немедленно завершает выполнение метода, в котором он находится. 


</details> 

</blockquote>
</details>

<details ГЛАВА 6><summary>ГЛАВА 6. "Введение в классы"</summary>
<blockquote>

Класс лежит в самом центре Java. Он представляет собой логическую конструкцию, на которой построен весь язык Java, потому что она определяет 
форму и природу объекта. Таким образом, класс формирует основу для объектно-ориентированного программирования (ООП) на Java. Любая концепция, которую вы хотите реализовать в программе на Java, должна быть инкапсулирована внутри класса
  
<details><summary>Основы классов</summary>

Вероятно, наиболее важная характеристика класса заключается в том, что 
он определяет новый тип данных. После определения новый тип можно применять для создания объектов такого типа. Следовательно, класс - это шаблон для объекта, а объект - это экземпляр класса. Так как объект является 
экземпляром класса, вы часто будете видеть, что слова объект и экземпляр 
используются взаимозаменяемо. 

При определении класса вы объявляете его точную форму и природу, для 
чего указываете данные, которые он содержит, и код, который работает с этими данными. Код класса определяет интерфейс к своим данным.

Данные, или переменные, определенные в классе, называются переменными 
экземпляра. Код содержится внутри методов. В совокупности методы и переменные, определенные в классе, называются членами класса. В большинстве 
классов переменные экземпляра обрабатываются и доступны с помощью методов, определенных для этого класса. Таким образом, как правило, именно 
методы определяют, как можно использовать данные класса. 

```html 
class Вох { 
douЫe width; 
douЫe height; 
douЫe depth; 
}
```

Как утверждалось выше, класс определяет новый тип данных. В рассматриваемом случае новый тип данных называется Вох. Имя класса будет использоваться для объявления объектов типа Вох. Важно помнить, что объявление класса создает только шаблон, но не фактический объект. Таким образом, предыдущий код не создает никаких объектов типа Вох. 
Чтобы действительно создать объект Вох, будет применяться оператор 
следующего вида: 

```html 
Вох mybox = new Вох ( ); // создать объект Вох по имени mybox
```

[Chapter06/BoxDemo - Программа, использующая класс Box](https://github.com/Vladlena2/BookJava/blob/main/Chapter6/BoxDemo.java "Посмотреть пример Java")

</details> 

<details><summary>Объекты</summary>

Как только что объяснялось, создание класса означает создание нового типа данных, который можно применять для объявления объектов этого 
типа. Однако получение объектов класса представляет собой двухэтапный 
процесс. Во-первых, потребуется объявить переменную типа класса. Такая 
переменная не определяет объект, а просто может ссылаться на объект. Во-вторых, необходимо получить физическую копию объекта и присвоить ее 
этой переменной, для чего служит операция new. Операция new динамически (т.е. во время выполнения) выделяет память для объекта и возвращает 
ссылку на нее, которая по существу является адресом в памяти объекта, выделенной new. Затем ссылка сохраняется в переменной. Таким образом, в Java 
все объекты класса должны размещаться динамически. 

```html 
Вох mybox = new Вох ( ); // создать объект Вох по имени mybox
```

В первой строке переменная mybox объявляется как ссылка на объект типа 
Вох. Пока что mybox не ссылается на фактический объект. Во второй строке 
объекта размещается в памяти и ссылка на него присваивается mybox. После 
выполнения второй строки переменную mybox можно использовать, как если 
бы она была объектом Вох. Но на самом деле mybox просто содержит адрес 
памяти фактического объекта Вох. 

## Подробный анализ операции new 

Важно понимать, что операция new выделяет память для объекта во время 
выполнения. Преимущество этого подхода состоит в том, что ваша программа может создать столько объектов, сколько требуется во время ее выполнения. Однако поскольку память конечна, возможно, что new не сможет выделить память под объект из-за нехватки памяти. В такой ситуации возникает 
исключение времени выполнения. (Вы узнаете, как обрабатывать исключения, в главе 10.) В примерах программ, приводимых в книге, вам не придется 
беспокоиться о нехватке памяти, но нужно будет учитывать эту возможность 
в реальных программах, которые вы будете писать.

Давайте еще раз подчеркнем **различие между классом и объектом**. Класс создает новый тип данных, который можно применять для создания объектов. То есть класс создает логическую инфраструктуру, определяющую отношения между его членами. При объявлении объекта класса создается экземпляр этого класса. Таким образом, класс является логической конструкцией, 
а объект имеет физическую реальность (занимает место в памяти).

## Присваивание для переменных ссылок на объекты 

```html 
Вох b1 = new Вох(); 
Вох Ь2 = b1; 
```

После выполнения данного фрагмента кода переменные b1 и Ь2 будут 
ссылаться на тот же самый объект. Присваивание переменной Ь2 значения b1 
не привело к выделению памяти или копированию какой-либо части исходного объекта. Оно просто заставляет Ь2 ссылаться на тот же объект, что и b1. 
Таким образом, любые изменения, внесенные в объект через переменную Ь2, 
повлияют на объект, на который ссылается b1, поскольку это один и тот же объект.

Хотя переменные b1 и Ь2 относятся к тому же самому объекту, они никак 
не связаны друг с другом. Например, последующее присваивание переменной 
b1 значения nul b1 просто отсоединит Ы от исходного объекта, не затрагивая объект и переменную Ь2.

</details> 

<details><summary>Введение в методы</summary>

Хотя совершенно нормально создавать класс, содержащий только данные, 
такое случается редко. Большую часть времени вы будете использовать методы для доступа к переменным экземпляра, которые определены классом. В действительности методы определяют интерфейс для большинства классов, что позволяет разработчику класса скрыть конкретную реализацию внутренних структур данных за более привлекател ьными абстракциями методов. 

Когда доступ к переменной экземпляра осуществляется кодом, который не входит в состав класса, где определена данная переменная 
экземпляра, то его придется делать через объект с использованием операции 
точки. Тем не менее, когда к переменной экземпляра обращается код, который входит в состав того же класса, что и переменная экземпляра, то на переменную можно ссылаться напрямую. То же самое относится и к методам.

**Параметр** - это переменная, определенная методом, которая получает 
значение при вызове метода. Например, в методе square () параметром является i. 

**Аргумент** - это значение, которое передается методу при его вызове. Например, вызов square (1ОО) передает в качестве аргумента значение 100, которое получает параметр i внутри square(). 

Скажем, довольно легко забыть установить какой-то размер. Во-вторых, в хорошо спроектированных программах на Java доступ к переменным экземпляра должен осуществляться только через методы, определенные их классом

Таким образом, более эффективный подход к установке размеров коробки предусматривает создание метода, который принимает размеры коробки в своих параметрах и соответствующим образом устанавливает каждую переменную экземпляра. 

[Chapter06/BoxDemo3 - В этой программе применяется метод с параметрами](https://github.com/Vladlena2/BookJava/blob/main/Chapter6/BoxDemo3.java "Посмотреть пример Java")

</details> 

<details><summary>Конструкторы</summary>

Конструктор инициализирует объект немедленно после создания. Причина в том, что неявным возвращаемым типом конструктора класса является сам класс. Задача конструктора - инициализировать внутреннее состояние объекта, чтобы код, создающий экземпляр, немедленно получил в свое распоряжение полностью инициализированный и пригодный для использования объект.

Теперь вы понимаете, зачем нужны скобки после имени класса. На самом 
деле происходит вызов конструктора класса. Таким образом, в следующей 
строке:

```html 
Вох myboxl = new Вох(); 
```

Фрагмент new Вох() вызывает конструктор Вох (). Если конструктор для 
класса не определяется явно, тогда компилятор Java создает стандартный конструктор. Вот почему предыдущая строка кода работала в более ранних 
версиях класса Вох, в которых конструктор не определялся. При использовании стандартного конструктора все неинициализированные переменные 
экземпляра будут иметь стандартные значения, которые для числовых типов, 
ссылочных типов и логических значений равны соответственно нулю, null и 
false. Стандартного конструктора часто оказывается достаточно для простых классов, но для более сложных классов он обычно не подходит. После 
определения собственного конструктора стандартный конструктор больше 
не применяется. 

[Chapter06/BoxDemo4 - В классе Box4 применяется параметрзованный конструктор](https://github.com/Vladlena2/BookJava/blob/main/Chapter6/BoxDemo4.java "Посмотреть пример Java")

[Chapter06/BoxDemo5 - В этой программе применяется метод с параметрами](https://github.com/Vladlena2/BookJava/blob/main/Chapter6/BoxDemo5.java "Посмотреть пример Java")

## Ключевое слово this

Иногда метод должен ссылаться на объект, на котором он вызывается. 
Для этого в Java определено ключевое слово this. Его можно использовать 
внутри любого метода для ссылки на текущий объект, т.е. this всегда будет 
ссылкой на объект, на котором был вызван метод. Ключевое слово this можно применять везде, где разрешена ссылка на объект типа текущего класса. 
Чтобы лучше понять, на что ссылается this, взгляните на приведенную 
ниже версию конструктора Вох(): 

```html 
// Избыточное исполь зование this. 
Box (double w, double h, double d){
this.width = w; 
this.height = h; 
this.depth = d;
}
```

## Сокрытие переменных экземпляра

Как вы з наете, в Java запрещено объявлять две локальные переменные с 
одинаковыми именами внутри той же самой или объемлющей облас ти видимости. Интересно отметить, что у вас могут быть локальные переменные, 
в том числе формальные параметры методов, имена которых совпадают с 
именами переменных экземпляра класса. Однако когда локальная переменная имеет такое же имя, как у переменной экземпляра, то локальная переменная скрывает переменную экземпляра. Вот почему width, height и depth не использовались в качестве имен параметров конструктора Вох() внутри класса Вох. Если бы они были выбраны, то имя width, например, ссылалось 
бы на формальный параметр, скрывая переменную экземпляра width. Хотя 
обычно проще применять отличающиеся имена, есть и другой выход из такой ситуации. Поскольку клю чевое слово this позволяет ссылаться прямо 
на объект, его можно использовать для устранения любых конфликтов имен, 
которые могут возникать между переменными экземпляра и локальными переменными. Например, вот еще одна версия конструктора Вох(), в которой 
имена width, height и depth применяются для параметров, а посредством 
this организуется доступ к переменным экземпляра с теми же именами: 

```html 
// Использование this для устранения конфликтов имен. 
Box (double width , double height , double depth) { 
this.width = width; 
this.height = height; 
this.depth = depth ;
}
```

Есть одно предостережение: использование this в таком контексте иногда 
может сбивать с толку. Некоторые программисты стараются не применять 
для локальных переменных и формальные параметров такие имена, которые 
приводят к сокрытию переменных экземпляра. Раз умеется, другие программисты уверены в обратном: они полагают, что использование тех же самых 
имен делает код яснее и применяют this для преодоления сокрытия переменных экземпляра. То, какой подход вы выберете - дело личного вкуса.

</details> 

<details><summary>Сборка мусора</summary>

Поскольку объекты динами чески размещаются в памяти с помощью операции new, вас может интересовать, каким образом такие объекты уни чтожаются, и занимаемая ими память освобождается с целью последующего выделения. В языках, подобных традиционному С++, динами чески размещенные объекты необходимо освобождать вру чную с помощью операци и delete. 
В Java используется другой подход; освобождение померживается автоматически. Методика, которая позволяет это делать, называется сборкой мусора. 
Она работает следующим образом: когда ссылок на объект не существует, то 
с читается, что такой объект больше не нужен, и занимаемая им память может 
быть освобождена. Нет необходимости явно уни чтожать объекты. Сборка 
мусора происходит нерегулярно (если вообще происходит) во время выполнения программы. Она не инициируется просто потому, что существует один или несколько объектов, которые больше не использ уются. Кроме того, в разных реализациях исполняющей среды Java будут применяться варьирующиеся подходы к сборке мусора, но по большей части вам не придется думать о ней при написании своих программ. 

</details> 

<details><summary>Класс Stack</summary>

Стек сохраняет данные по принципу "последний пришел - первым обслужен'; т.е. 
стек подобен стопке тарелок на столе: первая тарелка, поставленная на стол, 
используется последней. Стеки управляются с помощью двух операций, традиционно называемых помещением и извлечением. Чтобы сохранить элемент на верхушке стека, будет применяться помещение. Чтобы взять элемент из стека, будет использоваться извлечение. Как вы увидите, инкапсулировать полный механизм стека несложно.

[Chapter06/Stack - Реализация класса Stack](https://github.com/Vladlena2/BookJava/blob/main/Chapter6/Stack.java "Посмотреть пример Java")

[Chapter06/TestStack - Применение класса Stack](https://github.com/Vladlena2/BookJava/blob/main/Chapter6/TestStack.java "Посмотреть пример Java")

</details> 
  
</blockquote>
</details>

<details ГЛАВА 7><summary>ГЛАВА 7. "Подробный анализ методов и классов"</summary>
<blockquote>

<details><summary>Перегрузка методов</summary>
  
Язык Java разрешает определять в одном классе два и более метода, которые имеют одно и то же имя, если их объявления параметров отличаются. 
В таком случае говорят, что методы перегружены, а сам процесс называется 
перегрузкой методов. Перегрузка методов - один из способов помержки полиморфизма в Java.

При вызове перегруженноrо метода компилятор Java использует тип и/или 
количество аргументов в качестве ориентира, чтобы определить, какую версию переrруженноrо метода фактически вызывать. Таким образом, перегруженные методы должны отличаться типом и/или количеством параметров. 
Хотя перегруженные методы могут возвращать разные типы, одного типа 
возвращаемого значения недостаточно, чтобы различить две версии метода. 
Коrда компилятор Java встречает вызов переrруженноrо метода, он просто 
выполняет версию метода, параметры которой соответствуют аргументам, 
указанным в вызове.

Ниже приведен простой пример, иллюстрирующий перегрузку методов:

[Chapter07/OverloadDemo - Продемонстрировать перегрузку методов](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/OverloadDemo.java "Посмотреть пример Java")

При вызове перегруженного метода компилятор Java ищет соответствие 
между аргументами, используемыми для вызова метода, и параметрами метода. Однако это совпадение не всегда должно быть точным. В некоторых случаях 
автоматическое преобразование типов в Java может играть роль в распознавании перегруженных методов. Например, взгляните на следующую программу: 

[Chapter07/OverloadDemo2 - Применить автоматическое преобразование типов к перегрузке](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/OverloadDemo2.java "Посмотреть пример Java")

Легко заметить, что в данной версии OverloadDemo метод test(int) не 
определен. Тогда при вызове test() с целочисленным аргументом внутри 
Overload подходящая версия метода не будет найдена. Тем не менее, компилятор Java способен автоматически преобразовывать целое число в число 
типа double, и такое преобразование можно использовать для распознавания 
вызова. Поэтому после того, как test(int) не найден, компилятор Java повышает i до double и затем вызывает test(douЬle) . Конечно, если бы версия 
test(int) была определена, то именно она была бы вызвана. Компилятор 
Java задействует свои автомати ческие преобразования типов только при отсутствии точного совпадения. 
Перегрузка методов поддерживает полиморфизм, т.к. он представляет собой один из способов, которым в Java реализуется парадигма "один интерфейс, несколько методов": Давайте выясним, каким образом. В языках, не 
поддерживающих перегрузку методов, каждому методу должно быть назначено уникальное имя. Однако часто вам потребуется реализовать по существу один и тот же метод для разных типов данных. Рассмотрим функцию для абсолютного значения. В языках, не померживающих перегрузку, обычно существует три или более версий такой функции, каждая из которых имеет 
слегка отличающееся имя. Например, в языке С функция abs() возвращает 
абсолютное значение целого числа, labs() - абсолютное значение длинного 
целого числа, а fabs() - абсолютное значение значения с плавающей точкой. Поскольку перегрузка в С не поддерживается, каждая функция имеет собственное имя, хотя все три функции выполняют, по сути, одну и ту же 
работу, что делает ситуацию концептуально более сложной, чем она есть на 
самом деле. Хотя базовая концепция каждой функции одна и та же, вам нужно запомнить все три имени. В языке Java ситуация подобного рода не возникает, потому что каждый метод для абсолютного значения может иметь одно и то же имя. Действительно, стандартная библиотека классов Java включает метод получения абсолютного значения, называемый abs(). Этот метод перегружен в классе Math для обработки всех числовых типов. Компилятор Java 
определяет, какую версию abs() вызывать, основываясь на типе аргумента. 

Ценность перегрузки обусловлена тем, что она позволяет получить доступ 
к связ анным методам с применением общего имени. Таким образом, имя abs 
представляет выполняемое общее действие. Выбор правильной конкретной 
версии в сложившихся обстоятельствах возлагается на компилятор. Вам как 
программисту достаточно лишь запомнить общую выполняемую операцию. 
Благодаря полиморфизму несколько имен были сведены в одно.

В случае перегрузки метода каждая его версия может выполнять любые 
желаемые действия. Нет правила, утверждающего о том, что перегруженные 
методы должны быть связаны друг с другом. Тем не менее, со стилистической точки зрения перегрузка методов подразумевает наличие взаимоотношения между ними. Таким образом, хотя и допускается использовать одно и то же имя для перегрузки несвяз анных методов, вы не должны поступать так. Скажем, вы можете выбрать имя sqr при создании методов, возвращающих 
квадрат целого числа и квадратный корень значения с плавающей запятой. 
Но эти две операции принципиально разные. Применение перегрузки метода 
в подобной манере противоречит его первоначальной цели. На практике следует перегружать только тесно связанные операции. 

</details> 

<details><summary>Перегрузка конструкторов</summary>

Наряду с перегрузкой обычных методов можно также выполнять перегрузку методов-конструкторов.
В качестве параметров объекты чаще всего употребляются в конструкторах. Нередко новый объект приходится создавать таким образом, чтобы он первоначально ничем не отличался от уже существующего объекта. Для этого придется определить конструктор, принимающий в качестве параметра объект своего класса. Например, очередная версия класса Вох позволяет инициализировать один объект другим.

[Chapter07/BoxDemo01 - В этой версии класса Вох один объект допускается инициализировать другим объектом](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/BoxDemo01.java "Посмотреть пример Java")

</details> 

<details><summary>Использование объектов в качестве параметров</summary>

До сих пор в качестве параметров методов применялись только простые 
типы. Однако передача объектов методам является правильной и распространенной практикой. Например, возьмем показанную далее короткую программу: 

[Chapter07/PassOb - Передача объектов методам](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/PassOb.java "Посмотреть пример Java")

Как видите, метод equalTo() внутри Test сравнивает два объекта на 
предмет равенства и возвращает результат, т.е. он сравнивает вызывающий 
объект с тем, который ему передается. Если они содержат одинаковые значения, тогда метод возвращает true. В противном случае возвращается false. 
Обратите внимание, что параметр о в equalTo() указывает Test в качестве 
своего типа. Хотя Test - тип класса, созданный программой, он используется точно так же, как и встроенные типы Java. 

Одно из наиболее распространенных применений параметров объекта 
связано с конструкторами. Часто требуется создать новый объект так, чтобы 
он изначально был таким же, как какой-то существующий объект. Для этого необходимо определить конструктор, который принимает объект своего 
класса в качестве параметра. Например, следующая версия Вох позволяет одному объекту инициализировать другой: 

[Chapter07/OverloadCons2 - Конструктор, который принимает объект своего 
класса в качестве параметра](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/OverloadCons2.java "Посмотреть пример Java")

</details> 

<details><summary>Подробный анализ передачи аргументов</summary>

Говоря в общем, в языках программирования существуют два способа, которыми можно передавать аргумент подпрограмме. Первый способ - вызов 
по значению, при котором в формальный параметр подпрограммы копируется 
значение аргумента, поэтому изменения, вносимые в параметр подпрограммы, не влияют на аргумент. Второй способ - вызов по ссылке. При таком подходе в параметр передается ссылка на аргумент(а не его значение). Внутри 
подпрограммы эта ссылка используется для доступа к фактическому аргументу, указанному в вызове, т.е. изменения, вносимые в параметр, повлияют на аргумент, который применялся при вызове подпрограммы. 

Когда методу передается примитивный тип, то происходит передача по 
значению. Таким образом, создается копия аргумента, и все то, что делается 
с параметром, получающим аргумент, не имеет никакого эффекта вне метода. 

[Chapter07/CallByValue - Первый способ - вызов 
по значению](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/CallByValue.java "Посмотреть пример Java")

Как видите, операции, выполняемые внутри meth(), не влияют на значения 
а и b, используемые в вызове; их значения здесь не изменились на 30 и 10. 

Когда методу передается объект, ситуация кардинально меняется, потому 
что объекты передаются посредством того, что фактически называется вызовом по ссылке. Имейте в виду, что при создании переменной типа класса создается только ссылка на объект. Таким образом, когда такая ссылка передается методу, то параметр, который ее получает, будет ссылаться на тот же объект, на который ссылается аргумент. Фактически это означает, что объекты действуют так, будто они передаются методам с помощью вызова по 
ссылке. Изменения объекта внутри метода влияют на объект, указанный в 
качестве аргумента.

[Chapter07/PassObjRef - Второй способ - вызов по ссылке](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/PassObjRef.java "Посмотреть пример Java")

При передаче методу ссылки на объект сама ссылка передается с применением вызова по 
значению. Но поскольку передаваемое значение относится к объекту, копия этого значения 
по-прежнему будет ссылаться на тот же объект, что и соответствующий аргумент. 

</details> 

<details><summary>Возвращение объектов</summary>
  
Метод способен возвращать данные любого типа, включая типы классов, которые вы создаете. Например, в приведенной далее программе метод incrByTen() возвращает объект, в котором значение а на 1О больше, чем в вызывающем объекте. 

[Chapter07/RetOb2 - Возвращение объектов](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/RetOb2.java "Посмотреть пример Java")

Как видите, каждый раз, когда вызывается incrByTen() , создается новый 
объект, а вызывающей процедуре возвращается ссылка на него. 
В предыдущей программе продемонстрирован еще один важный момент: 
поскольку все объекты динамически размещаются с помощью операции new, 
вам не нужно беспокоиться о том, что объект выйдет за пределы области 
видимости, т.к. метод, в котором он был создан, завершается. Объект будет 
продолжать существовать до тех пор, пока в программе где-то есть ссылка на 
него. Когда ссылки на него исчезнут, занимаемая объектом память освободится при очередной сборке мусора.

</details> 

<details><summary>Рекурсия</summary>

В языке Java померживается рекурсия - процесс определения чего-либо в 
терминах самого себя. Что касается программирования на Java, то рекурсия 
является характерной чертой, позволяющей методу вызывать самого себя. 
Метод, который вызывает сам себя, называется рекурсивным. 
Классическим примером рекурсии считается вычисление факториала 
числа. Факториал числа N - это произведение всех целых чисел от 1 до N. 
Например, факториал 3 равен 1 х 2 х 3, или 6. 

[Chapter07/Recursion05 - Простой пример рекурсии (вычисление Факториала)](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/Recursion05.java "Посмотреть пример Java")

Когда метод вызывает сам себя, новые локальные переменные и параметры размещаются в стеке, а код метода выполняется с этими новыми переменными с самого начала. При возврате из каждого рекурсивного вызова старые локальные переменные и параметры удаляются из стека, и выполнение 
возобновляется в точке вызова внутри метода. Можно сказать, что рекурсивные методы работают в стиле "раздвижения" и "складывания" подзорной 
трубы. 
Рекурсивные версии многих подпрограмм могут выполняться немного 
медленнее своих итеративных эквивалентов из-за добавочных накладных 
расходов на дополнительные вызовы методов. Большое количество рекурсивных вызовов метода может привести к переполнению стека. Поскольку 
хранилище для параметров и локальных переменных находится в стеке, и 
каждый новый вызов создает новую копию этих переменных, вполне возможно, что стек исчерпается. В таком случае исполняющая среда Java инициирует 
исключение. Тем не менее, как правило, проблема не возникает, если рекурсивная подпрограмма не выходит из-под контроля. 
Главное преимущество рекурсивных методов связано с тем, что их можно 
использовать для создания более ясных и простых версий ряда алгоритмов, 
чем их итеративные аналоги. Скажем, алгоритм быстрой сортировки довольно сложно реализовать итеративным способом. Кроме того, некоторые типы 
алгоритмов из области искусственного интеллекта проще всего реализовать 
с помощью рекурсивных решений. 
При написании рекурсивных методов вы должны где-то предусмотреть 
оператор if, чтобы заставить метод выполнить воз врат без рекурсивного 
вызова. Если вы этого не сделаете, то после вызова возврат из метода никогда не произойдет. Такая ошибка весьма распространена, когда приходится 
иметь дело с рекурсией. Свободно применяйте операторы println() во время разработки, чтобы вы могли следить за происходящим и прерывать выполнение, если видите, что допустили ошибку. 

[Chapter07/Recursion06 - Еще один пример рекурсии](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/Recursion06.java "Посмотреть пример Java")

</details> 

<details><summary>Введение в управление доступом</summary>

При правильной реализации класс создает "черный ящик", с которым можно взаимодействовать, но нарушить его внутреннюю работу не удастся.

Доступ к члену определяется модификатором доступа, присоединенным 
к ero объявлению. Язык Java предлагает богатый набор модификаторов доступа. Некоторые аспекты управления доступом в основном связаны с наследованием или пакетами. (Пакет по существу представляет собой группу классов)

Модификаторами доступа Java являются public(открытый), private(закрытый) и protected (защищенный). В Java также определен стандартный уровень доступа. Модификатор доступа protected применяется, только когда задействовано наследование. Другие модификаторы доступа описаны далее. 
Давайте начнем с определения pablic и private. Когда член класса изменяется с помощью public, доступ к нему может получать любой другой код. 
Kor да член класса указан как privаte, доступ к нему могут пол учать только 
другие члены этого класса. Теперь вы понимаете, почему объявлению метода 
main() всегда предшествовал модификатор public. Он вызывается кодом, 
находящимся вне программы, т.е. исполняющей средой Java. Если модификатор доступа не задействован, то по умолчанию член класса является открытым в своем пакете, но к нему нельзя получить доступ за пределами пакета. (Пакеты обсуждаются в главе 9.) 

[Chapter07/TestAccess07 - Демонстрация модификаторов доступа](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/TestAccess07.java "Посмотреть пример Java")

Как видите, внутри класса Test применяется стандартный доступ, что в 
данном примере равнозначно указанию public. Член b явно определен как 
puЫic, а член с - как private. Это означает, что доступ к члену с в коде за 
пределами его класса невозможен. Таким образом, внутри класса AccessTest 
член с нельзя использовать напрямую. Доступ к нему должен осуществляться через его открытые методы: setc() и getc().

Чтобы увидеть, как применить управление доступом к более реальному 
примеру, рассмотрим показанную в конце главы 6 усовершенствованную версию класса Stack: 

[Chapter07/StackTest08 - Пример, усовершенствованной версии класса Stack](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/StackTest08.java "Посмотреть пример Java")

</details> 

<details><summary>Ключевое слово static</summary>

Временами вам понадобится определять чл ен класса, который будет применяться независимо от любого объекта данного класса. Обычно доступ 
к члену класса должен осуществляться только в сочетании с объектом его 
класса. Однако можно создать член, который можно использовать сам по 
себе, без привязки к конкретному экземпляру. Чтобы создать такой элемент, 
перед его объявл ением следует указать ключевое слово static(статический). 
Когда член объявляется статическим, к нему можно получать доступ до того, 
как будут созданы какие-либо объекты его класса, и без ссылки на какой-либо объект. Объявить статическими можно как методы, так и переменные. 
Наиболее распространенным примером статического члена является метод 
main(), который объявлен как static, потому что он должен быть вызван до 
того, как будут созданы любые объекты. 
Переменные экземпляра, объявленные как static, по существу являются 
глобальными переменными. При объявлении объектов такого класса копия 
статической переменной не создается. Взамен все экземпляры класса имеют 
дело с одной и той же статической переменной. 

С методами, объявленными как static, связано несколько ограничений. 
• Они могут напрямую вызывать только другие статические методы своего класса. 
• Они могут напрямую получать доступ только к статическим переменным своего класса. 
• Они никоим образом не могут ссылаться на this или super. (Ключевое 
слово super относится к наследованию и описано в следующей главе.) 

Если для инициализации статических переменных нужно выполнять вычисления, тогда можно объявить блок static, который выполняется в точности один раз, когда класс загружается впервые. В примере ниже показан класс со статическим методом, несколькими статическими переменными и статическим блоком инициализации

[Chapter07/UseStatic09 - В этой версии класса Вох один объект допускается инициализировать другим объектом](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/UseStatic09.java "Посмотреть пример Java")

Как только загружается класс UseStatic09, выполняются все статические операторы.
Сначала в переменной а устанавливается значение 3, затем выполняется
статический блок кода, в котором выводится сообщение, а переменная Ь инициализируется
значением а*4, т.е. 12. После этого вызывается метод main(), который, в свою очередь,
вызывает метод meth(),передавая параметру х значение 42.
В трех вызовах метода println () делаются ссылки на две статические переменные, а и Ь,
а также на локальную переменную х. 

За пределами класса, в котором определены статические методы и переменные, ими можно пользоваться независимо от любого объекта. Для этого достаточно указать имя их класса через операцию-точку непосредственно перед их именами. Так, если требуется вызвать статический метод за пределами его класса, это можно сделать, используя следующую общую форму:

```html 
имя_класса.метод()
```

Здесь имя_класса обозначает имя того класса, в котором объявлен статический метод. Как видите, эта форма аналогична той, что применяется для вызова нестатических методов через переменные ссылки на объекты. Аналогично для доступа к статической переменной ее имя следует предварить именем ее класса через операцию-точку. Именно так в Java реализованы управляемые версии глобальных методов и переменных.

Обратимся к конкретному примеру. В теле метода main() обращение к статическому методу callme() и статической переменной "b" осуществляется по имени их класса "UseStatic09":

[Chapter07/StaticByName - В этой версии класса Вох один объект допускается инициализировать другим объектом](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/StaticByName.java "Посмотреть пример Java")

</details> 

<details><summary>Ключевое слово final</summary>
  
Поле может быть объявлено как final(финальное), что предотвращает 
изменение его содержимого, делая его по существу константой. Это означает, что поле final должно быть инициализировано при его объявлении. 
Существуют два способа инициализации такого поля. Во-первых, полю final 
можно присвоить значение при его объявлении. Во-вторых, полю final можно присвоить значение в конструкторе.

```html 
final int FILE_NEW = 1; 
final int FILE_OPEN = 2; 
final int FILE_SAVE = 3; 
final int FILE_SAVEAS = 4 ; 
final int FILE_QUIT = 5;
```

Как показано в примере, общепринятое соглашение при 
написании кода предусматривает выбор для полей final идентификаторов 
со всеми буквами верхнего регистра. 
Помимо полей как final могут быть объявлены и параметры метода, и 
локальные переменные. Объявление параметра как final предотвращает его 
изменение внутри метода. Объявление локальной переменной как final предотвращает присваивание ей значения более одного раза. 
Ключевое слово final также может применяться к методам, но его смысл 
существенно отличается от того, когда оно применяется к переменным. Такое 
дополнительное использование final объясняется в следующей главе при 
описании наследования. 

</details> 

<details><summary>Массивы</summary>

Массивы были представлены ранее в книге, еще до обсуждения классов. 
Теперь, когда вы ознакомились с классами, можно сделать важное замечание 
о массивах: они реализованы в виде объектов.

В частности, размер массива, т.е. количество элементов, которые может содержать массив, находится в его переменной экземпляра length. В частности, размер массива, т.е. количество элементов, которые может содержать массив, находится в его переменной экземпляра length. 

[Chapter07/StackTest10 -Усовершенствованный класс Stack, в котором используется свойство длины массива](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/StackTest10.java "Посмотреть пример Java")

Как видите, в выводе отображается размер каждого массива. Имейте в 
виду, что значение length не имеет ничего общего с количеством фактически 
используемых элементов. Оно отражает только количество элементов, для 
хранения которых проектировался массив. 
Вы можете найти хорошее применение члену length во многих ситуациях. 
Например, далее показана усовершенствованная версия класса Stack. Как вы 
помните, ранние версии класса Stack всегда создавали стек из десяти элементов. Новая версия позволяет создавать стеки любого размера. Переполнение 
стека предотвращается с применением значения stack.length.

</details> 

<details><summary>Вложенные и внутренние классы</summary>

Класс можно определять внутри другого класса; такой класс известен как вложенный класс. Область действия вложенного класса ограничена областью действия его объемлющего класса. Таким образом, если класс B определен внутри класса A, то B не существует независимо от A. Вложенный класс имеет доступ к членам, в том числе закрытым, класса, в который он вложен. Тем не менее, объемлющий класс не имеет доступа к членам вложенного класса. Вложенный класс, объявленный непосредственно в области действия его объемлющего класса, будет членом объемлющего класса. Также можно объявлять вложенный класс, локальный для блока.

Существуют два типа вложенных классов: статические и нестатические. Статический вложенный класс - это класс, к которому применяется модификатор static. Поскольку класс статический, он должен обращаться к нестатическим членам объемлющего класса через объект. То есть статический вложенный класс не может напрямую ссылаться на нестатические члены объемлющего класса.

Вторым типом вложенного класса является внутренний класс. Внутренний класс - это нестатический вложенный класс. Он имеет доступ ко всем переменным и методам своего внешнего класса и может ссылаться на них напрямую, так же как поступают другие нестатические классы.

В следующей программе иллюстрируется определение и использование 
внутреннего класса. Класс по имени Outer имеет одну переменную экземпляра по имени external_x, один метод экземпляра с именем test() и определяет один внутренний класс по имени

[Chapter07/InnerClassDemo11 - Продемонстрировать применение внутреннего класса](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/InnerClassDemo11.java "Посмотреть пример Java")

 В данной программе внутренний класс Inner определен в области действия
класса Outer. Поэтому любой код из класса Inner может непосредственно обращаться
к переменной outer_x. Метод экземпляра display() определен в классе Inner.
Этот метод выводит значение переменной outer_x в стандартный поток вывода.
В методе main() из класса InnerClassDemo создается экземпляр класса Outer и
вызывается его метод test().А в этом методе создается экземпляр класса Inner
и вызывается метод display().
Следует иметь в виду, что экземпляр класса Inner может быть создан только
в контексте класса Outеr.

Хотя мы сосредоточились на внутренних классах, объявленных в виде членов в области действия внешнего класса, внутренние классы можно определять в рамках области действия любого блока. Например, вложенный класс можно определить в блоке, который определен внутри метода, или даже в теле цикла for, как показано в следующем примере программы:

[Chapter07/InnerClassDemo13 - В этой версии класса Вох один объект допускается инициализировать другим объектом](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/InnerClassDemo13.java "Посмотреть пример Java")

Интересно отметить, что вложенные классы не были разрешены в исходной спецификации Java 1.0, а появились в Java 1.1

</details> 

<details><summary>Исследование класса String</summary>

Первое, что нужно понять о строках: каждая создаваемая вами строка на самом деле является объектом типа String. Даже строковые константы фактически представляют собой объекты String. Например, в следующем операторе строка "Это тоже строка" является объектом String:

```html 
System.out.println("Этo тоже строка"); 
```

Объекты типа String неизменяемы; после создания объекта String его содержимое нельзя модифицировать. Хотя это ограничение может показаться серьезным, оно не так важно по двум причинам.

- Если вам необходимо изменить строку, то вы всегда можете создать новую строку, отражающую изменения.
- В Java существуют классы StringBuilder и StringBuffer, которые предоставляют возможность изменять строки, поэтому в Java по-прежнему доступны все обычные операции со строками. (Классы StringBuilder и StringBuffer описаны в части II книги.)

Строки можно конструировать различными способами. Проще всего применять оператор такого вида:

```html 
String myString = "это просто тест";  
```

После создания объекта String, его можно использовать везде, где разрешена строка. 

Для объектов String в Java определена операция конкатенации строк, которая использует оператор "+". Следующий оператор конкатенирует строку "Мне нравится язык Java" с переменной myString:

```html 
myString = myString + "Мне нравится язык Java."; 
```

Класс String содержит нескол ько методов, которыми можно пользоваться. Рассмотрим несколько из них. Две строки можно проверить на предмет 
равенства с применением метода equals() . Вызвав метод length(), можно 
получить длину строки, а вызвав метод charAt() можно извлечь символ по 
указ анному индексу в строке.

[Chapter07/StringDemo14 - Продемонстрировать некоторые методы из класса String](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/StringDemo14.java "Посмотреть пример Java")

[Chapter07/StringDemo15 - Продемонстрировать применение массивов объектов типа String](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/StringDemo15.java "Посмотреть пример Java")

Все аргументы командной строки передаются в строковом виде. Как будет объяснено в 
главе 19, числовые значения придется вручную преобразовывать в их внутренние формы. 

</details> 

<details><summary>Аргументы переменной длины</summary>

В состав современных версий Java входит средство, упрощающее создание методов, которые должны принимать произвольное количество аргументов. Оно называется аргументами переменной длины (variable-length arguments - varargs). Метод, принимающий произвольное число аргументов, называется методом с переменной арностью или методом с аргументами переменной длины.

Ситуации, когда методу требуется передавать произвольное число аргументов, не являются чем-то необычным. Метод, который открывает подключение к Интернету, например, может принимать имя пользователя, пароль, имя файла, протокол и т.д., и предоставлять стандартные значения, если часть этой информации не была указана. В такой ситуации было бы удобно передавать только те аргументы, к которым не применяются стандартные значения. Другим примером может служить метод printf(), который является частью библиотеки ввода-вывода Java. Как вы увидите в главе 22, он принимает произвольное количество аргументов, форматирует их и затем отображает.

В ранних версиях Java аргументы переменной длины можно было поддерживать двумя способами, ни один из которых нельзя считать удобным. Первый способ, подходящий в ситуации, когда максимальное количество аргументов является небольшим и известным, предусматривал создание перегруженных версий метода, по одной для каждого варианта вызова метода. Хотя подобный подход работает и подходит в ряде случаев, он применим только к узкому набору ситуаций.

В тех случаях, когда максимальное количество потенциальных аргументов было большим или неизвестным, использовался второй подход, который заключался в помещении аргументов в массив, который затем передавался методу. Данный подход все еще встречается в унаследованном коде и иллюстрируется ниже:

[Chapter07/UseArrayToPassVariableToMethod16 - Использовать массив для передачи методу переменной количество аргументов](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/UseArrayToPassVariableToMethod16.java "Посмотреть пример Java")

Аргументы передаются методу vaTest() через массив v. Такой подход в старом стиле позволяет vaTest() принимать произвольное количество аргументов. Однако он требует, чтобы перед вызовом метода vaTest() аргументы вручную упаковывались в массив. Создание массива при каждом вызове vaTest() не только утомительно, но и потенциально подвержено ошибкам. Средство аргументов переменной длины предлагает более простой и совершенный вариант.

Аргумент переменной длины определяется с помощью трех точек (...). Например, вот как определить метод vaTest() с применением аргумента переменной длины:

```html 
static void vaтest(int ... v)
```

Этот синтаксис сообщает компилятору, что метод vaTest() можно вызывать с нулем или большим числом аргументов. В результате v неявно объявляется как массив типа int[]. Таким образом, внутри vaTest() доступ к v осуществляется с использованием обычного синтаксиса массива.

[Chapter07/VarArgs17 - Продемонстрировать применение аргументов переменной длины](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/VarArgs17.java "Посмотреть пример Java")

В приведенной выше программе следует отметить два важных момента. Во-первых, переменная v в методе vaTest() обрабатывается как массив. Фактически, v и является массивом. Синтаксис ... просто сообщает компилятору, что будет использоваться переменное число аргументов, причем аргументы будут храниться в массиве, на который ссылается v. Во-вторых, метод vaTest() вызывается внутри main() с разным количеством аргументов, включая вариант вообще без аргументов. Аргументы автоматически помещаются в массив и передаются v. При отсутствии аргументов длина массива равна нулю.

Наряду с параметром переменной длины, метод может иметь и "обычные" параметры. Тем не менее, параметр переменной длины должен объявляться в методе последним. Скажем, следующее объявление метода совершенно допустимо:

```html 
int doit( int а, int Ь, douЫe с, i nt ... val s) { 
```

В этом случае первые три аргумента, указанные в вызове doit(), сопоставляются с первыми тремя параметрами, а все остальные аргументы считаются относящимися к vals

```html 
int doit(int а, int Ь, douЫe с, int ... vals, boolean stopFlag ) { // Ошибка!
```

Существует еще одно ограничение, о котором следует помнить: должен 
быть только один параметр переменной длины. Скажем, приведенное ниже 
объявление тоже будет ошибочным:

```html 
int doit(int а, int Ь, douЫe с, int ... val s , douЬle ... moreval s) { // Ошибка!
```

Объявлять второй параметр переменной длины не разрешено. 
Вот переработанная версия метода vaTest(), которая принимает обычный аргумент и аргумент переменной длины: 

[Chapter07/VarArgs18 - Продемонстрировать применение аргументов переменной длины](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/VarArgs18.java "Посмотреть пример Java")

## Перегрузка методов с аргументами переменной длины
  
Метод, принимающий аргумент переменной длины, можно перегружать. 
Например, в показанной далее программе метод vaTest() перегружается три 
раза:

[Chapter07/VarArgs19 - Аргументы переменной длины и перегрузка](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/VarArgs19.java "Посмотреть пример Java")

Метод с аргументом переменной длины также может быть перегружен за счет определения метода без аргумента переменной длины. В приведенной выше программе, vaTest(int x) является допустимой версией vaTest(). Эта версия вызывается только при наличии одного аргумента типа int. Когда передаются два или более аргумента типа int, используется версия vaTest(int... v) с аргументом переменной длины. Таким образом, метод может иметь несколько перегруженных версий для разных сценариев вызова.

## Аргументы переменной длины и неоднозначность 

При перегрузке метода, принимающего аргумент переменной длины, могут возникать несколько неожиданных ошибок. Такие ошибки связаны с неоднозначностью, поскольку существует возможность создать двусмысленный вызов перегруженного метода с аргументами переменной длины.

[Chapter07/VarArgs20 - Аргументы переменной длины, перегрузка и Неоднозначность](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/VarArgs20.java "Посмотреть пример Java")

В этой программе перегрузка метода vaTest() совершенно корректна, но 
программа не скомпилируется из-за такого вызова: 

```html 
vaTest(); // Ошибка: Неоднозначность! 
```

vaTest(); - вызов метода vaTest без аргументов может вызвать ошибку "Неоднозначность", если есть несколько версий метода, подходящих для вызова. В этом случае компилятор не может определить, какую из перегруженных версий следует вызвать, так как нет явного указания на конкретный метод.

Чтобы избежать неоднозначности, необходимо предоставить дополнительную информацию или явно указать, какую версию метода вы хотите вызвать.

```html 
static void vaTest( int ... v) { 
static void vaTest(int n, int v) { 
```

Несмотря на различие в списках параметров vaTest(), компилятор не 
сможет распознать следующий вызов:

```html 
vaTest(l) 
```

Данный вызов vaTest(); вызывает неоднозначность, и компилятор не сможет определить, в какой метод он должен преобразоваться. Это происходит из-за того, что вызов без аргументов может соответствовать как методу vaTest(int...) с одним аргументом переменной длины, так и методу vaTest(int, int...) без аргументов переменной длины.

Из-за ошибок неоднозначности, подобных показанным, иногда вам придется отказаться от перегрузки методов и просто использовать методы с разными именами. Это избегает конфликта и делает код более явным. Кроме того, в ряде случаев ошибки неоднозначности могут указывать на концептуальные дефекты в коде, которые могут потребовать более тщательной проработки решения.

</details> 

<details><summary>Выведение типов локальных переменных для ссылочных типов</summary>

Как упоминалось в главе 3, начиная с версии JDK 10, в Java поддерживается выведение типов локальных переменных. Вспомните, что при выведении типов локальных переменных тип переменной указывается как var, а переменная должна быть инициализирована. В более ранних примерах выведение типов демонстрировалось с примитивными типами, но его также можно применять со ссылочными типами. Фактически, основное использование выведения типов связано со ссылочными типами. Вот простой пример, в котором объявляется строковая переменная с именем myStr:

```html 
var myStr = "Пример строки";
```

Из-за использования строки в кавычках в качестве инициализатора для переменной myStr, тип String выводится автоматически.

Как объяснялось в главе 3, одно из преимуществ выведения типов локальных переменных связано с его способностью оптимизировать код, и такая оптимизация наиболее очевидна именно со ссылочными типами. Причина в том, что многие классы в Java имеют довольно длинные имена. Например, в главе 13 вы узнаете о классе FileInputStream, который используется для открытия файлов для операций ввода. В прошлом, объект FileInputStream объявлялся и инициализировался с использованием традиционного объявления, подобного приведенному ниже:

```html 
FileInputStream fileInputStream = new FileInputStream("example.txt");
```

С использованием выведения типов, это можно упростить до:

```html 
var fileInputStream = new FileInputStream("example.txt");
```

Тут предполагается, что переменная fin имеет тип FileInputStream, так как это тип её инициализатора. Нет никакой необходимости явно повторять имя типа. В результате, такое объявление fin значительно короче, чем его запись традиционным способом, и потому применение var упрощает объявление.

Это преимущество становится еще более очевидным в более сложных объявлениях, включая объявления с обобщениями. В целом, упрощение выведения типов локальных переменных помогает уменьшить избыточное использование длинных имен типов в программах.

Разумеется, аспект упрощения кода со стороны выведения типов локальных переменных должен использоваться осмотрительно, чтобы не ухудшить читаемость программы и не скрыть её намерения. Например, рассмотрим следующее объявление:

```html 
var х = о.getNext(); 
```

Выведение типов локальных переменных можно также использовать в отношении пользовательских классов, как показано в ниже приведенной программе. В ней создается класс с именем MyClass, а затем с использованием выведения типов локальных переменных объявляется и инициализируется объект этого класса.

[Chapter07/RefVarDemo - Локальные переменные в отношении пользовательских классов](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/RefVarDemo.java "Посмотреть пример Java")

Тип переменной mc будет выводиться как MyClass, потому что это тип 
инициализатора, который является новым объектом MyClass.
</details>

</blockquote>
</details>

<details ГЛАВА 8><summary>ГЛАВА 8. "Наследование"</summary>
<blockquote>

Наследование является одним из краеугольных камней объектно-ориентированного программирования (ООП), поскольку позволяет создавать иерархические классификации. С использованием наследования вы можете создать универсальный класс, который определяет характерные черты, общие для набора связанных элементов. Затем этот класс может быть унаследован 
другими, более специфическими классами, каждый из которых добавляет те 
элементы, которые уникальны для него. В терминологии Java унаследованный 
класс называется суперклассом, а класс, выполняющий наследование - подклассом. Следовательно, подк ласс представляет собой специализированную 
версию суперкласса. Он наследует все члены, определенные суперклассом, и 
добавляет собственные уникальные элементы. 

<details><summary>Основы наследования</summary>

Чтобы наследовать класс, вы просто включаете определение одного класса 
в другой с применением ключевого слова extends.

[Chapter08/SimpleInheritance01 -  Простой пример наследования](https://github.com/Vladlena2/BookJava/tree/main/Chapter8/SimpleInheritance01.java "Посмотреть пример Java")

Как видите, подкласс В включает в себя все члены своего суперкласса А. Вот почему объект subOb может получать доступ к i и j и вызывать 
showij(). Кроме того, внутри sum() на i и j можно ссылаться напрямую, как 
если бы они были частью В. 
Несмотря на то что А выступает в качестве суперкласса для В, он также 
является полностью независимым, автономным классом. Быть суперклассом 
для подкласса не означает, что суперкласс не может использоваться сам по 
себе. Кроме того, подкласс может быть суперклассом для другого подкласса. 

Для любого создаваемого подкласса разрешено указывать только один суперкласс. Наследование нескольких суперклассов при создании одиночного 
подкласса в языке Java не поддерживается. Как было указано, можно создать 
иерархию наследования, в которой подкласс становится суперклассом для 
другого подкласса. Однако ни один класс не может быть суперклассом для 
самого себя.

</details>

<details><summary>Доступ к членам и наследования</summary>

Хотя подкласс включает в себя все члены своего суперкласса, он не может получить доступ к тем членам суперкласса, которые были объявлены как закрытые.

[Chapter08/DemoBoxWeight02 -  Пример, где наследование применяется для расширения класса](https://github.com/Vladlena2/BookJava/tree/main/Chapter8/DemoBoxWeight02.java "Посмотреть пример Java")

Классу BaxWeight вовсе не обязательно воссоздавать все функциональные средства, имеющиеся в Boх. Для достижения своих целей он может просто расширить Вох. 
Основное преимущество наследования связано с тем, что после создания 
суперкласса, который определяет характерные черты, общие для набора объектов, его можно применять для создания любого количества более конкретных подклассов. Каждый подкласс может точно настраивать собственное предназначение. 

</details>

<details><summary>Переменная типа суперкласса может ссылаться на объект подкласса</summary>

Ссылочной переменной типа суперкласса можно присваивать ссылку на объект любого подкласса, производного от данного суперкласса.

[Chapter08/RefDemo - Пример](https://github.com/Vladlena2/BookJava/tree/main/Chapter8/RefDemo.java "Посмотреть пример Java")

Здесь weightbox является ссылкой на объекты BoxWeight, а plainbox -
ссылкой на объекты Вох. Поскольку BoxWeight - подкласс Вох, переменной 
plainЬox разрешено присваивать ссылку на объект weightbox. 
Важно понимать, что именно тип ссылочной переменной, а не тип объекта, на который она ссылается, определяет, к каким членам можно получать 
доступ. Другими словами, когда ссылочной переменной типа суперкласса 
присваивается ссылка на объект подкласса, то доступ имеется только к тем 
частям объекта, которые определены в суперклассе. Вот почему переменная 
plainbox не может получить доступ к weight, даже если она ссылается на 
объект BoxWeight. Если подумать, то в этом есть смысл, потому что суперклассу ничего не известно о том, что к нему добавляет подкласс. Поэтому 
последняя строка кода в предыдущем фрагменте закомментирована. Ссылка Вох не может получить доступ к полю weight, т.к. в классе Вох оно не определено. 

</details>

<details><summary>Использование ключевого слова super</summary>

В предшествующих примерах классы, производные от Вох, не были реализованы настолько эффективно и надежно, насколько могли бы. Скажем, конструктор для BoxWeight явно инициализирует поля width, height и depth класса Вох. Это не только приводит к дублированию кода, уже имеющегося в 
его суперклассе, что неэффективно, но и подразумевает предоставление подклассу доступа к упомянутым членам. Тем не менее, будут возникать ситуации, ко гда желательно создавать суперкласс, который держит детали своей 
реализации при себе (т.е. хранит свои элементы данных закрытыми). В таком 
случае у подкласса не было бы возможности напрямую обращаться к этим 
переменным либо инициализировать их самостоятельно. Поскольку инкапсуляция является основным атрибутом ООП, совершенно не удивительно, что в Java предлагается решение описанной проблемы. Всякий раз, когда подклассу необходимо сослаться на свой непосредственный суперкласс, он может воспользоваться ключевым словом super. 

Подкласс может вызывать конструктор, определенный в его суперклассе, с 
применением следующей формы super:

```html 
suреr(список-аргументов);  
```

Здесь список-аргументов предназначен для указания любых аргументов, необходимых конструктору в суперклассе. Вызов super() всегда должен 
быть первым оператором, выполняемым внутри конструктора подкласса. 
Чтобы увидеть, как используется super(), рассмотрим показанную ниже 
усовершенствованную версию класса BoxWeight:

```html 
//В классе BoxWeight члены его суперкласса Вох теперь инициализируются с применением super. 
class BoxWeight exteпds Вох{ 
douЫe weight; //вес коробки 
//Инициализировать width, height и depth, используя super()
BoxWeight (douЫe w, douЫe h, douЫe d, double m) { 
super(w, h, d); // вызвать конструктор суперкласса 
weight = m;
}
}
```

Таким образом, super() всегда ссылается на суперкласс 
непосредственно над вызывающим классом. Это справедливо даже для многоуровневой иерархии. Кроме того, вызов super() всегда должен быть первым оператором, выполняемым внутри конструктора подкласса. 

Вторая форма ключевого слова super действует примерно так же, за исключением того, что всегда относится к суперклассу подкласса, в котором 
задействована. Вот как она выrлядит: 

```html 
suреr.член 
```

Здесь член может быть либо методом, либо переменной экземпляра. 
Вторая форма super наиболее применима в ситуациях, когда имена членов 
подкласса скрывают члены с тем же именем в суперклассе. Возьмем следующую простую иерархию классов:

[Chapter08/UseSupper - Пример](https://github.com/Vladlena2/BookJava/tree/main/Chapter8/UseSupper.java "Посмотреть пример Java")

Хотя переменная экземпляра i в В скрывает i в А, ключевое слово super 
делает возможным доступ к члену i, определенному в суперклассе. Как вы 
увидите, super можно также использовать для вызова методов, сокрытых 
подклассом.

</details>

<details><summary>Создание многоуровневой иерархии</summary>

При наличии трех классов А, В и С класс С может быть подклассом 
В, который является подклассом А. Когда возникает ситуация такого типа, 
каждый подкласс наследует все характерные черты, обнаруженные во всех 
его суперклассах. В данном случае С наследует все аспекты В и А.

[Chapter08/DemoShipment05 - Пример, создания многоуровневой иерархии](https://github.com/Vladlena2/BookJava/tree/main/Chapter8/DemoShipment05.java "Посмотреть пример Java")

Благодаря наследованию класс Shipment может задействовать определенные 
ранее классы Вох и BoxWeight, добавляя только ту дополнительную информацию, которая необходима для собственного конкретного приложения. Это часть 
ценности наследования; оно позволяет многократно использовать код. 
В примере иллюстрируется еще один важный момент: super() всегда ссылается на конструктор в ближайшем суперклассе. В классе Shipment с помощью super() вызывается конструктор BoxWeight, а в классе BoxWeight -конструктор Вох. В рамках иерархии классов, когда конструктору суперкласса требуются аргументы, то все подклассы должны передавать их "вверх по цепочке наследования'.

</details>

<details><summary>Порядок вызова конструкторов</summary>
  
В иерархии классов конструкторы завершают свое выполнение в порядке наследования от суперкласса к подклассу. 
Кроме того, поскольку вызов super() должен быть первым оператором, выполняемым в конструкторе подкласса, такой порядок остается тем же независимо от того, применяется super() или нет. Если super() не используется, то будет выполнен стандартный конструктор или конструктор без параметров каждого суперкласса. Выполнение конструкторов демонстрируется в следующей программе: 

[Chapter08/CallingConstr06 - Пример](https://github.com/Vladlena2/BookJava/tree/main/Chapter8/CallingConstr06.java "Посмотреть пример Java")

Если хорошо подумать, то имеет смысл, что конструкторы завершают свое 
выполнение в порядке наследования. Поскольку суперклассу ничего не известно о каких-либо подклассах, любая инициализация, которую должен выполнить суперкласс, является отдельной и возможно обязательной для любой инициализации, выполняемой подклассом. Следовательно, она должна быть завершена первой. 

</details>

<details><summary>Переопределение методов</summary>

В иерархии классов, когда метод в подклассе имеет то же имя и сигнатуру типа, что и метод в его суперклассе, то говорят, что метод в подклассе 
переопределяет метод в суперклассе. При вызове переопределенного метода через его подкласс всегда будет вызываться версия метода, определенная в подклассе. Версия метода, определенная в суперклассе будет сокрыта.

При желании получить доступ к версии переопределенного метода из суперкласса можно применить ключевое слово super. Скажем, в приведенном 
далее классе В внутри версии show() из подкласса вызывается версия show( ) 
из суперкласса, что позволяет отобразить все переменные экземпляра.

[Chapter08/OverloadMethod08 - Пример, переопределения методов](https://github.com/Vladlena2/BookJava/tree/main/Chapter8/OverloadMethod08.java "Посмотреть пример Java")

Метод переопределяется только в случае, если и мена и сигнатуры типов 
двух методов идентичны, а иначе два метода будут просто перегруженными.

[Chapter08/Override - Пример, перегрузки методов](https://github.com/Vladlena2/BookJava/tree/main/Chapter8/Override.java "Посмотреть пример Java")

Версия метода show() в классе В принимает строковый параметр, что отличает его сигнатуру типов от сигнатуры метода show() в классе А, который 
не принимает параметров. Поэтому никакого переопределения (или сокрытия имени) не происходит. Взамен версия show() в классе В просто перегружает версию show() из класса А. 

</details>

<details><summary>Динамическая диспетчеризация методов</summary>

Переопределение методов лежит в основе одной из самых мощных 
концепций Java - диспетчеризации динамических методов. Диспетчеризация 
динамических методов представляет собой механизм, с помощью которого 
вызов переопределенного метода распознается во время выполнения, а не на 
этапе компиляции. Динамическая диспетчеризация методов важна, потому 
что именно так в Java обеспечивается полиморфизм во время выполнения. 

Тип объекта, на 
который делается ссылка (а не тип ссылочной переменной), определяет, какая 
версия переопределенного метода будет выполняться. 

[Chapter08/DynamicMethodDispatching09 - Динамическая диспетчеризация методов](https://github.com/Vladlena2/BookJava/tree/main/Chapter8/DynamicMethodDispatching09.java "Посмотреть пример Java")

В программе создается один суперкласс по имени А и два его подкласса, 
в и С. Подклассы В и С переопределяют метод callme(), объявленный в А. 
Внутри метода main() объявляются объекты типов А, В и С. Кроме того, объявляется ссылка типа А по имени r. Затем в программе переменной r по очереди присваивается ссылка на каждый тип объекта и производится вызов 
метода callme(). В выводе видно, что выполняемая версия callme() определяется типом объекта, на который делается ссылка во время вызова. Если 
бы версия определялась типом ссылочной переменной r, то вы бы увидели 
три вызова метода callme() класса А.

</details>

<details><summary>Назначение и применение переопределенных методов</summary>

Полиморфизм важен для 
ООП по одной причине: он позволяет универсальному классу определять 
методы, которые будут общими для всех производных от него классов, одновременно разрешая подклассам определять индивидуальные реализации 
некоторых или всех общих методов. Переопределенные методы - еще один 
способ, которым в Java обеспечивается аспект полиморфизма "один интерфейс, несколько методов".

Одним из ключей к успешному применению полиморфизма является понимание того, что суперклассы и подклассы образуют иерархию с продвижением от меньшей специализации к большей. При правильном использовании 
суперкласс предоставляет все элементы, которые подкласс может задействовать напрямую. Он также определяет те методы, которые производный класс 
должен реализовать самостоятельно. Это позволяет подклассу не только гибко определять собственные методы, но также обеспечивает согласованный 
интерфейс. Таким образом, комбинируя наследование с переопределенными 
методами, суперкласс может определять общую форму методов, которые будут потребляться всеми его подклассами.

Динамический полиморфизм во время выполнения - один из самых 
мощных механизмов, которыми ООП воздействует на многократное использование и надежность кода. Способность существующих библиотек кода 
вызывать методы для экземпляров новых классов без перекомпиляции с одновременным сохранением чистого абстрактного интерфейса является чрезвычайно мощным инструментом

Практический пример, в котором применяется переопределение методов. В приведенной ниже программе создается суперкласс Figure для хранения размеров двумерного объекта, а также определяется метод area() для расчета площади этого объекта. Кроме того, в этой программе создаются два класса, Rectangle и Triangle, производные от класса Figure. Метод area() переопределяется в каждом из этих подклассов, чтобы возвращать площадь четырехугольника и треугольника соответственно.

[Chapter08/FigureFindArea10 - Применение динамического полиморфизма](https://github.com/Vladlena2/BookJava/tree/main/Chapter8/FigureFindArea10.java "Посмотреть пример Java")

С помощью дуальных механизмов наследования и полиморфизма во время выполнения можно определить один согласованный интерфейс, который 
применяется несколькими разными, но связанными типами объектов. В данном случае, если объект является производным от Figure, то его площадь 
можно получить, вызвав метод area(). Интерфейс этой операции одинаков 
вне зависимости от того, какой тип фигуры используется. 

</details>
 
<details><summary>Использование абстрактных классов</summary> 

Бывают ситуации, когда желательно определить суперкласс, который 
объявляет структуру заданной абстракции, не предоставляя полные реализации методов. То есть иногда нужно создать суперкласс, определяющий 
только обобщенную форму, которая будет применяться всеми его подклассами, оставляя каждому подклассу возможность заполнить детали. Такой 
класс определяет природу методов, подлежащих реализации в подклассах. 
Ситуация подобного рода может возникнуть, когда суперкласс не способен 
создать осмысленную реализацию метода. Это относится к классу Figure, 
использованному в предыдущем примере. Определение метода area() является просто заполнителем. Он не будет рассчитывать и отображать площадь 
объекта любого вида. 

Вы можете потребовать, чтобы некоторые методы были переопределены 
в подклассах, указав модификатор abstract. Иногда их называют методами, 
подпадающими под ответственность подкласса, потому что они не имеют 
реализ ации, указанной в суперклассе. Таким образом, подкласс обязан их 
переопределить - он не может просто использовать версию, определенную 
в суперклассе. Для объявления абстрактного метода применяется следующая 
общая форма: 

```html 
abstract тип имя(список-параметров);
```

Любой класс, содержащий один или несколько абстрактных методов, тоже 
должен быть объявлен абстрактным. Чтобы объявить класс абстрактным, 
перед ключевым словом class в начале объявления класса просто используется ключевое слово abstract. Объектов абстрактного класса не бывает, т.е. экземпляр абстрактного класса нельзя создать напрямую с помощью операции new. Подобного рода объекты был и бы бесполезными, т.к. абстрактный класс не определен полностью. Кроме того, не допускается объявлять абстрактные конструкторы или абстрактные статические методы. Любой подкласс абстрактного класса должен либо реализовать все абстрактные методы суперкласса, либо сам быть объявлен абстрактным. 

Хотя абстрактные классы нельзя задействовать для создания объектов, их 
можно применять для создания ссылок на объекты, поскольку подход Java 
к полиморфизму во время выполнения обеспечивается через использование 
ссылок на суперклассы. Таким образом, должна быть возможность создания 
ссылки на абстрактный класс, чтобы ее можно было применять для указания 
на объект подкласса.

[Chapter08/FigureFindArea10 - Применение динамического полиморфизма](https://github.com/Vladlena2/BookJava/tree/main/Chapter8/FigureFindArea10.java "Посмотреть пример Java")

</details>

<details><summary>Предотвращение переопределения с помощью ключевого слова final</summary> 

Наряду с тем, что переопределение методов является одной из самых 
мощных функциональных средств Java, иногда его желательно предотвращать. Чтобы запретить переопределение метода, в начале его объявления понадобится указать ключевое final в качестве модификатора. Методы, объявленные как final, не могут быть переопределены.

```html 
class A {
   final void meth() {
       System.out.println("Этo конечный метод.");
   }   
}
class B extends A {
   void meth() {
       // ОШИБКА!!! Этот метод не может быть переопределен.
   }
}
```

Методы, объявленные как final, иногда могут обеспечить повышение 
производительности: компилятор способен встраивать их вызовы, потому 
что он "знает'; что они не будут переопределяться в подклассе. Когда компилятор Java встречает вызов небольшого метода final, он часто может копировать байт-код для подпрограммы непосредственно в скомпилированный код вызывающего метода, тем самым устраняя накладные расходы по вызову метода. Встраивание возможно только с методами final. Обычно компилятор Java распознает вызовы методов динамически во время выполнения. Это 
называется поздним связыванием. Но поскольку методы final не могут быть 
переопределены, их вызов может распознаваться на этапе компиляции. Это 
называется ранним связыванием.

</details>

<details><summary>Предотвращение наследования с помощью ключевого слова final</summary> 

Иногда нужно предотвратить наследование класса. Для этого перед объявлением класса укажите ключевое слово final. Объявление класса как final также неявно объявляет все его методы как final. Вполне ожидаемо объявлять класс как abstract и final одновременно не разрешено, поскольку абстрактный класс сам по себе неполный и в обеспечении полных реализаций 
полагается на свои подклассы. 

```html 
final class A {
   // ...
}
// Следующий класс недопустим!!!
class B extends A {
  // ОШИБКА!!! Класс А не может иметь подклассы.
}
```

</details>

<details><summary>Выведение типов локальных переменных и наследование</summary> 

Важно иметь четкое представление о том, как работает выведение типов в иерархии наследования. Вспомните, что ссылка на суперкласс может ссылаться на объект производного класса, и такое средство является частью поддержки полиморфизма в Java. Однако важно помнить, что при использовании выведения типов локальных переменных выведенный тип переменной базируется на объявленном типе ее инициализатора. Следовател ьно, если инициализатор относится к типу суперкласса, то он и будет выведенным типом переменной. Не имеет значения, является 
ли фактический объект, на который ссылается инициализатор, экземпляром 
производного класса.

[Chapter08/TypeinferenceAndinheritance - Выведение типов локальных переменных в наследовании](https://github.com/Vladlena2/BookJava/tree/main/Chapter8/TypeinferenceAndinheritance.java "Посмотреть пример Java")

В программе создается иерархия, состоящая из трех классов, на вершине 
которых находится MyClass. Класс FirstDerivedClass определен как подкласс MyClass, а SecondDerivedClass - как подкласс FirstDerivedClass. 
Затем с применением выведения типа создаются три переменные с именами mc, mc2 и mсЗ путем вызова getObj(). Метод getObj() имеет возвращаемый тип MyClass(суперкласс), но в зависимости от передаваемого аргумента возвращает объекты типа MyClass, FirstDeri vedClass или 
SecondDeri vedClass. Как видно в отображенных результатах программы, 
выведенный тип определяется возвращаемым типом getObj(), а не фактическим типом полученного объекта. Таким образом, все три переменные будут 
иметь тип MyClass.

</details>

<details><summary>Класс Object</summary> 

В языке Java определен один специальный класс, называемый Object. Все остальные классы являются подклассами, производными от этого класса. Это означает, что класс Object служит суперклассом для всех остальных классов, и ссылочная переменная из класса Object может ссылаться на объект любого другого класса. А поскольку массивы реализованы в виде классов, то ссылочная переменная типа Object может ссылаться и на любой массив. В классе Object определены методы, перечисленные ниже:

|Метод |Назначение |
|:-----------------------------|:-------------------------------------|
|Object clone() |Создает новый объект, не отличающийся от клонируемго |
|boolean equals(Object object) | Определяет, равен ли один объект другому |
|void finalize() |Вызывается перед удалением неиспользуемого объекта (не рекомендован для применения, начиная с версии JDK 9) |
|Class<?> getClass() |Получает класс объекта во время выполнения |
|int hashCode() |Возвращает хеш-код, связанный с вызывающим объектом |
|void notify() |Возобновляет исполнение потока, ожидающего вызывающего объекта |
|void notifyAll() |Возобновляет исполнение всех потоков, ожидающих вызывающий объект |
|String toString() |Возвращает символьную строку, описывающую объект |
|void wait() |Ожидает другого потока исполнения |
|void wait(long миллисекунд) |Ожидает другого потока исполнения |

Методы getClass(), notify(), notifyAll() и wait() объявлены как final. Остальные методы можно переопределять (они будут описаны в последующих главах данной книги). Обратите, однако, внимание на два метода: equals() и toString(). Метод equals() сравнивает два объекта. Если объекты равны, он возвращает логическое значение true, а иначе - логическое значение false. Точное определение равенства зависит от типа сравниваемых объектов. Метод toString() возвращает символьную строку с описанием объекта, для которого он вызван. Кроме того, метод toString() вызывается автоматически, когда содержимое объекта выводится с помощью метода println(). Этот метод переопределяется во многих классах, чтобы приспосабливать описание к создаваемым в них конкретным типам объектов.

</details>

</blockquote>
</details>

<details ГЛАВА 9><summary>ГЛАВА 9. "Пакеты и интерфейсы"</summary>
<blockquote>

Пакеты представляют собой контейнеры для классов. Они используются для отделения пространства имен класса. Например, создав класс по имени List и сохранив его в собственном пакете, можно не беспокоиться о том, что он будет конфликтовать с другим классом по имени List, который находится где-то в другом месте. Пакеты хранятся в иерархическом порядке и явно импортируются в определения новых классов.

В предыдущих главах вы видели, что методы определяют интерфейс к данным в классе. Ключевое слово interface позволяет полностью абстрагировать интерфейс от его реализации. С помощью interface указывается набор методов, которые могут быть реализованы одним или несколькими классами. В своей традиционной форме интерфейс сам по себе не определяет никакой реализации.

Хотя интерфейсы похожи на абстрактные классы, они обладают дополнительной возможностью: класс может реализовывать более одного интерфейса. В противоположность этому класс может быть унаследован только от одного суперкласса (абстрактного либо иного).

<details><summary>Пакеты</summary>

В Java предоставляется механизм для разделения пространства имен классов на более управляемые фрагменты - пакеты. Пакет является как механизмом именования, так и механизмом управления видимостью. Вы можете определять классы внутри пакета, которые не доступны коду вне пакета. Вы также можете определять члены класса, которые видны только другим членам классов в том же пакете. Это позволяет вашим классам хорошо знать друг друга, но не раскрывать такие знания остальному миру.

Создать пакет довольно легко: просто поместите в начало файла с исходным кодом Java оператор `package`. Любые классы, объявленные в данном файле, будут принадлежать указанному пакету. Оператор `package` определяет пространство имен, в котором хранятся классы. Если оператор `package` отсутствует, то имена классов помещаются в стандартный пакет, не имеющий имени.

Вот общая форма оператора package: 

```html 
package пакет; 
```

Допускается создавать иерархию пакетов, для чего нужно просто отделять имя каждого пакета от имени пакета над ним с помощью точки. Общая форма оператора многоуровневого пакета выглядит следующим образом:
```html
package пакет1 [ . пакет2 [ . пакет3]] ;
```

Иерархия пакетов должна быть отражена в файловой системе на машине для разработки приложений Java. Например, объявленный ниже пакет должен храниться в папке `а\Ь\с` в среде Windows:
```html
package а.Ь.с ;
```

Имена пакетов должны выбираться крайне аккуратно, так как нельзя переименовать пакет, не переименовав каталог, в котором хранятся классы.

По умолчанию исполняющая среда Java в качестве начальной точки использует текущий рабочий каталог. Таким образом, если ваш пакет расположен в каком-то подкаталоге внутри текущего каталога, то он будет найден. Во-вторых, вы можете указать путь или пути к каталогам, установив переменную среды `CLASSPATH`. В-третьих, вы можете применить параметр `-classpath` при запуске `java` и `javac`, чтобы указать путь к своим классам.

Полезно отметить, что начиная с JDK 9, пакет может быть частью модуля и, следовательно, находиться в пути к модулю. Чтобы программа могла найти пакет `mypack`, ее можно либо запустить из каталога непосредственно над `mypack`, либо переменная среды `CLASSPATH` должна включать путь к `mypack`, либо при запуске программы через `java` в параметре `-classpath` должен быть указан путь к `mypack`.

Когда применяются последние два способа, путь к классу не должен содержать само имя `mypack`. Он должен просто указывать путь к `mypack`. Например, если в среде Windows путем к `mypack` является:

```html
C:\MyPrograms\Java\mypack
```

то путем к классу для `mypack` будет:

```html
C:\MyPrograms\Java
```

Испытать примеры, приведенные в книге, проще всего, создав каталоги пакетов внутри текущего каталога разработки, поместив файлы `.class` в соответствующие каталоги, и затем запустив программы из каталога разработки. Именно такой подход используется в рассматриваемом далее примере.

Классы и пакеты являются средствами инкапсуляции и содержания в 
себе пространства имен, а также области видимости переменных и методов. 
Пакеты действуют в качестве контейнеров для классов и других подчиненных 
пакетов. Классы действуют как контейнеры для данных и кода. Класс - это 
наименьшая единица абстракции Java.

Доступ к членам классов:

|                      | Тот же класс | Подкласс из того же пакета | Не подкласс из того же пакета | Подкласс из другого пакета | Не подкласс из другого пакета |
|----------------------|--------------|-----------------------------|-------------------------------|-----------------------------|-------------------------------|
| `public`             | Да           | Да                          | Да                            | Да                          | Да                            |
| `protected`          | Да           | Да                          | Да                            | Да                          | Нет                           |
| `default` (по умолчанию) | Да           | Да                          | Да                            | Нет                         | Нет                           |
| `private`            | Да           | Нет                         | Нет                           | Нет                         | Нет                           |

Эта таблица иллюстрирует, какие члены класса видны для других классов в зависимости от уровня доступа и отношений между классами (в том же классе, подклассе, из того же пакета, из другого пакета).

Хотя механизм управления доступом в Java может показаться сложным, его можно упростить следующим образом. Ко всему, что объявлено как `public`, можно получать доступ из разных классов и разных пакетов. Все, что объявлено как `private`, не может быть видимым за пределами его класса. Когда у члена нет явной спецификации доступа, он виден подклассам, а также другим классам в том же пакете. Такой доступ принят по умолчанию. Если вы хотите, чтобы элемент был видимым за пределами вашего текущего пакета, но только классам, которые напрямую являются подклассами вашего класса, тогда объявите этот элемент как `protected`.

Правила доступа к членам классов, приведенные в таблице 9.1, применимы только к членам классов. Класс, не являющийся вложенным, имеет только два возможных уровня доступа: стандартный и открытый. Когда класс объявлен как `public`, он доступен за пределами своего пакета. Если класс имеет стандартный доступ, то к нему может получать доступ только другой код в том же пакете. Когда класс является открытым, он должен быть единственным открытым классом, объявленным в файле, а файл должен иметь такое же имя, как у класса.

<details><summary>Пример, использование модификаторов доступа</summary>

В приведенном примере демонстрируются все комбинации модификаторов управления доступом. В примере присутствуют два пакета и пять классов. Не забывайте, что классы для двух разных пакетов должны храниться в каталогах с именами, совпадающими с именами соответствующих пакетов - в данном случае pl и р2.

В файле с исходным кодом для первого пакета определены три класса: `Protection`, `Derived` и `SamePackage`. В первом классе определяются четыре переменные типа int с каждым допустимым уровнем доступа. Переменная `n` объявлена со стандартным доступом, `n_pri` - с доступом `private`, `n_pro` - с доступом `protected`, а `n_pub` - с доступом `public`. Все последующие классы в рассматриваемом примере будут пытаться получить доступ к переменным экземпляра класса `Protection`. Строки, которые не будут компилироваться из-за ограничений доступа, закомментированы. Перед каждой из таких строк находится комментарий с перечислением мест, из которых этот уровень защиты разрешит доступ.

Второй класс, `Derived`, является подклассом `Protection` в том же пакете `pl`, что дает `Derived` доступ ко всем переменным в `Protection` кроме закрытой переменной `n_pri`. Третий класс, `SamePackage`, не является подклассом `Protection`, но находится в том же самом пакете и тоже имеет доступ ко всем переменным кроме `n_pri`.

[Chapter09/MainDemo - получить экземпляры различных классов из пакета pkg01](https://github.com/Vladlena2/BookJava/tree/main/Chapter9/pkg01/MainDemo.java "Посмотреть пример Java")

Ниже представлен исходный код другого пакета, `p2`. Два класса, определенные в `p2`, охватывают остальные два условия, на которые влияет управление доступом. Первый класс, `Protection2`, является подклассом `pl.Protection`, что дает ему доступ ко всем переменным `pl.Protection` кроме `n_pri` (поскольку она является закрытой) и `n` - переменной, объявленной со стандартной защитой.

Вспомните, что по умолчанию разрешен доступ только из класса или пакета, а не из подклассов вне пакета. Наконец, класс `OtherPackage` имеет доступ только к одной переменной `n_pub`, которая была объявлена открытой.

[Chapter09/MainDemo - получить экземпляры различных классов из пакета pkg02](https://github.com/Vladlena2/BookJava/tree/main/Chapter9/pkg02/MainDemo.java "Посмотреть пример Java")

</details>

<details><summary>Импортирование пакетов</summary>

Поскольку классы в пакетах должны полностью уточняться с помощью одного или нескольких имен пакетов, набор длинного пути к пакету, разделенного точками, для каждого используемого класса может стать утомительным. По этой причине в составе Java имеется оператор импортирования import, который позволяет сделать видимыми определенные классы или целые пакеты. После импортирования на класс можно ссылаться напрямую с применением только его названия. Оператор import является удобным инструментом для программиста и формально не нужен для написания законченной программы на Java. Однако, если вы собираетесь ссылаться на несколько десятков классов в своем приложении, то оператор import существенно сократит объем кода.

В файле с исходным кодом на Java операторы импорта располагаются сразу после оператора пакета (если он присутствует) и перед любыми определениями классов. Общая форма оператора импорта выглядит следующим образом:

```html
import пакет [пакет2] имя_класса;
```

В конце оператора импорта указывается либо явное имя класса (name_class), либо звездочка (*), которая сообщает компилятору Java о необходимости импортировать весь пакет. Вот два примера использования:

```html
import java.util.Date;
import java.io.*;
```

Все стандартные классы Java SE, включенные в состав Java, начинаются с имени java. Основные языковые функции содержатся в пакете с именем java.lang. Обычно вам нужно импортировать каждый пакет или класс, который вы планируете использовать, но так как язык Java бесполезен без большей части функциональности пакета java.lang, он неявно импортируется компилятором для всех программ. Это равносильно наличию в начале кода каждой вашей программы следующей строки:

```html
import java.lang.*;
```

Если в двух различных пакетах, импортированных с помощью оператора импорта со звездочкой, имеются классы с одинаковыми именами, компилятор никак не отреагирует на это, пока вы не попытаетесь использовать один из классов. В этом случае возникнет ошибка компиляции.

Например, если вы хотите, чтобы класс Balance из упомянутого ранее пакета mypack был доступен как автономный класс для общего использования вне пакета mypack, вам нужно объявить его как public и поместить в отдельный файл:

[Chapter09/mypack/Balance - Пример самостоятельного класса за пределами пакета mypack](https://github.com/Vladlena2/BookJava/tree/main/Chapter9/mypack/Balance.java "Посмотреть пример Java")

Теперь класс Balance стал открытым, равно как его конструктор и метод show(). Это означает, что к ним можно получить доступ в коде любого 
вида за рамками пакета mypack. Например, класс TestBalance импортирует 
mypack и затем может работать с классом Balance:

[Chapter09/mypack02/TestBalance - Пример пример, класс TestBalance импортирует пакет mypack](https://github.com/Vladlena2/BookJava/tree/main/Chapter9/mypack02/TestBalance.java "Посмотреть пример Java")

</details>

</details>

<details><summary>Интерфейсы</summary>

С помощью ключевого слова interface, вы можете полностью абстрагировать интерфейс класса от его реализации. То есть, с использованием interface можно указать, что класс должен делать, но не как конкретно. Интерфейсы синтаксически похожи на классы, но в них отсутствуют экземпляры переменных и, как правило, их методы объявлены без тела.

На практике это означает, что вы можете определить интерфейсы, не делая предположений о том, каким образом они реализуются. После определения, интерфейс может быть реализован любым количеством классов. Кроме того, один класс может реализовать любое количество интерфейсов.

Для реализации интерфейса, класс должен предоставить полный набор методов, требуемых интерфейсом. Однако, каждый класс может самостоятельно определять детали своей реализации. Благодаря предоставлению ключевого слова interface в языке Java, можно в полной мере использовать аспект полиморфизма: “один интерфейс - несколько методов”. Интерфейсы предназначены для поддержки динамического распознавания методов во время выполнения. Как правило, для вызова метода одного класса внутри другого, оба класса должны быть доступны во время компиляции, чтобы компилятор Java смог проверить совместимость сигнатур методов.

Поскольку интерфейсы находятся в иерархии, отличной от иерархии классов, классы, не связанные с точки зрения иерархии классов, получают возможность реализации одного и того же интерфейса. Здесь проявляется истинная сила интерфейсов.

Если модификатор доступа не указан, то устанавливается стандартный доступ и интерфейс будет доступен только другим элементам пакета, в котором он объявлен. Если интерфейс объявлен как public, его может использовать код вне пакета, где он объявлен. В этом случае интерфейс должен быть единственным открытым интерфейсом, объявленном в файле, и файл должен иметь то же имя, что и интерфейс. Обратите внимание, что у объявленных методов нет тела. Они завершаются точкой с запятой после списка параметров. По сути, это абстрактные методы. Каждый класс, который включает такой интерфейс, должен реализовать все методы.

Начиная с JDK 8, метод интерфейса может иметь стандартную реализацию. Также, в JDK 8 были добавлены статические методы интерфейса. А начиная с JDK 9, интерфейс может содержать закрытые методы. Таким образом, теперь интерфейс может задавать некоторое поведение. Как видно из общей формы, внутри объявления интерфейса можно объявлять переменные. Они автоматически становятся final и static, то есть не могут изменяться в реализующем классе. Они также должны быть проинициализированы. Все методы и переменные автоматически являются открытыми.

После определения интерфейса, один или несколько классов могут его реализовать. Чтобы реализовать интерфейс, добавьте в определение класса конструкцию implements и затем создайте требуемые интерфейсом методы. Методы, реализующие интерфейс, должны быть объявлены как public.

<details><summary>Доступ к реализациям через ссылки на интерфейсы</summary>
  
Вы можете объявлять переменные как ссылки на объекты, использующие тип интерфейса, а не тип класса. Используя переменную такого типа, вы можете ссылаться на любой объект любого класса, который реализует объявленный интерфейс. Когда вы вызываете метод через одну из таких ссылок, корректная версия вызывается на основе фактического объекта реализации интерфейса, на которую сделана ссылка. Это одно из ключевых преимуществ интерфейсов. Метод, который должен быть выполнен, определяется динамически во время выполнения, что позволяет вам создавать классы после того, как код, вызывающий их методы, уже написан. Диспетчеризация (определение того, какой метод следует выполнить) в вызывающем коде может осуществляться через интерфейс без необходимости знания о “стороне вызова”. Этот процесс аналогичен использованию ссылки на суперкласс для доступа к объекту подкласса (как было описано в Главе 8).

```html
class TestIface { 
public static void main(String[] args ) { 
Callback с = new Client(); 
c.callback (42) ; 
}

Вот вывод, генерируемый программой: 
callback () вызывается со значением 42 
```

Обратите внимание, что переменная c объявлена как имеющая тип интерфейса Callback, хотя ей присваивается экземпляр класса Client. Хотя переменную c можно использовать для вызова метода callback(), через неё нельзя получить доступ к другим членам класса Client. Переменной, которая ссылается на интерфейс, известны только методы, которые присутствуют в её объявлении интерфейса. Таким образом, переменная c не может использоваться для вызова метода noniFaceMeth(), потому что он определён в классе Client, а не в интерфейсе Callback.

Хотя в предыдущем примере показывалось, как переменная, ссылающаяся на интерфейс, может получить доступ к объекту реализации, там не демонстрировались полиморфные возможности этой ссылки. Чтобы их испытать, сначала потребуется создать ещё одну реализацию Callback:

```html
// Еще одна реализация Callback. 
class AnotherClient implements Callback { 
// Реализовать метод интерфейса Callback. 
public void callback (int р) { 
System.out.println("Eшe одна версия callback()"); 
System.out.println("p в квадрате равно " + (р*р));
} }

// Теперь создадим следующий класс: 
class Testiface2 { 
puЬlic static void main (String[] args) 
Callback с = new Client( ) ; 
AnotherClient оb = new AnotherClient(); 
с.callback(42);
с = оb; // c теперь ссылается на объект AnotherClient
c.callback (42) ; 
} }

Ниже показан вывод, генерируемый программой: 
callback() вызывается со значением 42 
Еше одна версия callback() 
р в квадрате равно 1764 
```

Как видите, переменная с может ссылаться на объекты разных типов, реализующих один и тот же интерфейс Callback.

</details>

Если класс включает интерфейс, но не полностью реализует методы, требуемые этим интерфейсом, то такой класс должен быть объявлен абстрактным, например: 

```html
abstract class Incomplete implements Callback { 
int а, Ь; 
void show() { 
System.out.println(a + " " + Ь ) ; 
} 
// ... 
}
```

В этом примере класс Incomplete не реализует метод callback() и поэтому должен быть объявлен абстрактным. Любой класс, наследующий Incomplete, обязан реализовать callback() или сам должен быть объявлен абстрактным.

<details><summary>Вложенные интерфейсы</summary>

Интерфейс может быть объявлен в качестве члена класса или другого интерфейса. Такой интерфейс называется интерфейсом-членом или вложенным интерфейсом. Вложенный интерфейс может быть объявлен как public, private или protected. Он отличается от интерфейса верхнего уровня, который должен быть либо объявлен как public, либо иметь стандартный уровень доступа, как обсуждалось ранее. Когда вложенный интерфейс используется за пределами его области видимости, он должен быть полностью уточнен именем класса или интерфейса, элементом которого он является. Поэтому, вне класса или интерфейса, где вложенный интерфейс был объявлен, его имя должно быть полностью уточненным.

[Chapter09/NestedIFDemo - Пример вложенного интерфейса](https://github.com/Vladlena2/BookJava/tree/main/Chapter9/NestedInterfaces/NestedIFDemo.java "Посмотреть пример Java")

Обратите внимание, что в класс A определяет и объявляет открытый интерфейс-член по имени NestedIF. Затем этот вложенный интерфейс реализуется в классе B с помощью указания следующей конструкции:

```html
implements A.NestedIF
```

Кроме того, имя интерфейса полностью уточняется именем охватывающего класса. Внутри метода main() создаётся ссылка A.NestedIF по имени nif, которой присваивается ссылка на объект класса B. Поскольку B реализует A.NestedIF, такая операция допустима.

</details>

<details><summary>Применение интерфейсов</summary>

В предыдущих Главе 6 был разработан класс Stack, реализующий простой стек фиксированного размера. Однако стек можно реализовать разными способами, но независимо от реализации стека, его интерфейс остается неизменным. Это означает, что методы push() и рор() определяют интерфейс стека независимо от особенностей его реализации. А поскольку интерфейс стека отделен от его реализации, то такой интерфейс можно определить без особого труда, оставив уточнение конкретных деталей в его реализации.

[Chapter06/Stack - Реализация класса Stack](https://github.com/Vladlena2/BookJava/blob/main/Chapter6/Stack.java "Посмотреть пример Java")

Создадим сначала интерфейс, определяющий целочисленный стек, разместив его в файле IntStack.java. Этот интерфейс будет использоваться в обеих реализациях стека.

[Chapter09/Stack/IntStack - Пример интерфейса для целочисленного стека](https://github.com/Vladlena2/BookJava/blob/main/Chapter9/Stack/IntStack.java "Посмотреть пример Java")

В приведенной ниже программе создается класс FixedStack, реализующий версию целочисленного стека фиксированной длины.

[Chapter09/Stack/IFFixedStack - Реализация интерфейса IntStack для стека фиксированного размера](https://github.com/Vladlena2/BookJava/blob/main/Chapter9/Stack/IFFixedStack.java "Посмотреть пример Java")

Ниже приведена еще одна реализация интерфейса IntStack, в которой с помощью того же самого определения interface создается динамический стек. В этой реализации каждый стек создается с первоначальной длиной. При превышении этой начальной длины размер стека увеличивается. Каждый раз, когда возникает потребность в дополнительном свободном месте, размер стека удваивается.

[Chapter09/Stack/IFDynStack - Реализация "наращиваемого" стека](https://github.com/Vladlena2/BookJava/blob/main/Chapter9/Stack/IFDynStack.java "Посмотреть пример Java")

В приведенном ниже примере программы создается класс, в котором используются обе реализации данного интерфейса в классах FixedStack и DynStack. Для этого применяется ссылка на интерфейс. Это означает, что поиск вариантов при вызове методов push() и рор() осуществляется во время выполнения, а не во время компиляции.

В этой программе переменная myStack содержит ссылку на интерфейс IntStack. Следовательно, когда она ссылается на переменную dynStack, выбираются варианты методов push() и рор(), определенные при реализации данного интерфейса в классе DynStack. Когда же она ссылается на переменную fixedStack, выбираются варианты методов push() и рор(),определенные при реализации данного интерфейса в классе FixedStack. Как отмечалось ранее, все эти решения принимаются во время выполнения.

[Chapter09/Stack/IFTestЗ - Создать переменную интерфейса и обратиться к обоим стекам через нее](https://github.com/Vladlena2/BookJava/blob/main/Chapter9/Stack/IFTestЗ.java "Посмотреть пример Java")

Обращение к нескольким реализациям интерфейса через ссылочную переменную интерфейса является наиболее эффективным средством в Java для поддержки полиморфизма во время выполнения.

</details>

<details><summary>Переменные в интерфейсах</summary>

Интерфейсы можно использовать для импорта общих констант в несколько классов, просто объявляя интерфейс, который содержит переменные, инициализированные требуемыми значениями. Когда этот интерфейс включается в класс (то есть когда интерфейс «реализуется»), имена всех этих переменных становятся видимыми в классе как константы.

Если интерфейс не содержит методов, любой класс, включающийся в этот интерфейс, на самом деле ничего не реализовывает. Результат будет таким же, как будто бы класс импортировал эти константные переменные в пространство имён класса как final.

[Chapter09/VariablesInInterfaces/AskМe - Реализация автоматизированной системы "принятия решений"](https://github.com/Vladlena2/BookJava/blob/main/Chapter9/VariablesInInterfaces/AskМe.java "Посмотреть пример Java")

</details>

<details><summary>Интерфейсы можно расширять</summary>

Ключевое слово extends позволяет одному интерфейсу наследовать другой.

Синтаксис определения такого наследования аналогичен синтаксису наследования классов. Когда класс реализует интерфейс, наследующий другой интерфейс, он должен предоставлять реализации всех методов, определенных по цепочке наследования интерфейсов.

[Chapter09/ExtendsInterfaces/IFExtend - Пример расширения интерфейсов](https://github.com/Vladlena2/BookJava/blob/main/Chapter9/ExtendsInterfaces/IFExtend.java "Посмотреть пример Java")

</details>

<details><summary>Стандартные методы интерфейса</summary>

В версии JDK 8 была добавлена новая возможность, которая называется стандартный метод. Стандартный метод позволяет определить реализацию по умолчанию для методов интерфейса. Используя стандартный метод, методы интерфейса могут предоставлять тело, а не являться абстрактными. Во время разработки стандартные методы также упоминались как расширяющие методы.

Основным мотивом для введения стандартных методов было предоставление возможности расширять интерфейсы без нарушения работы существующего кода. Раньше добавление нового метода в популярный интерфейс могло нарушить работу существующего кода, потому что для нового метода не было реализации. Эту проблему решает стандартный метод, обеспечивая реализацию по умолчанию, которая используется, если другая реализация не указана явно. Таким образом, добавление стандартных методов не приводит к нарушению работы существующего кода.

Ещё одним мотивом для добавления стандартных методов было желание указать в интерфейсе методы, которые, по сути, являются опциональными в зависимости от того, как используется интерфейс.

Например, интерфейс может определять набор методов, работающих с последовательностью элементов. Один из таких методов может называться remove(), и его задача — удалять элемент из последовательности. Но если интерфейс предназначен для поддержки как изменяемых, так и неизменяемых последовательностей, метод remove() не является обязательным, так как он не будет применяться к неизменяемым последовательностям.

В прошлом класс, реализующий неизменяемую последовательность, должен был определить пустую реализацию метода remove(), даже если в этом не было необходимости. Сейчас интерфейс может содержать стандартную реализацию метода remove() , которая ничего не делает (или вызывает исключение).

Предоставление стандартной реализации делает необязательным определение в классе собственной версии метода remove(). Таким образом, благодаря стандартному методу реализация remove() в классе становится необязательной.

Важно отметить, что добавление стандартных методов не изменяет ключевого аспекта интерфейса: его непригодности для поддержки информации о состоянии. Например, интерфейс по-прежнему не может иметь переменных экземпляра.

Следовательно, определяющее различие между интерфейсом и классом заключается в том, что класс может поддерживать информацию о состоянии, а интерфейс — нет. Также, как и раньше, невозможно создать экземпляр интерфейса как такового. Интерфейс должен быть реализован классом. По этой причине, даже с учётом появившейся в версии JDK 8 возможности определения стандартных методов, интерфейс всё равно должен быть реализован классом, если нужно создание экземпляра.

</details>

<details><summary>Основы стандартных методов</summary>

Стандартный метод интерфейса определяется аналогично определению 
метода в классе. Основное отличие связано с тем, что объявление предваряется ключевым словом default. Например, возьмем следующий простой интерфейс:  

```html
public interface MyIF{ 
// Это объявление "нормального" метода интерфейса. 
// В нем НЕ определяется стандартная реализация. 
int getNumЬer(); 
// Это стандартный метод. Обратите внимание, 
// что он предоставляет реализацию по умолчанию. 
default String getString() { 
return "Стандартная строка ";
} }
```

Поскольку метод getString() содержит стандартную реализацию,
классу, реализующему этот интерфейс, не обязательно переопределять его.
Другими словами, если класс, реализующий этот интерфейс, не предоставляет
свою собственную реализацию этого метода, будет использоваться стандартная.

[Chapter09/DefaultMethods/DefaultMethMain - Пример использования реализации метода по умолчанию](https://github.com/Vladlena2/BookJava/blob/main/Chapter9/DefaultMethods/DefaultMethMain.java "Посмотреть пример Java")

[Chapter09/DefaultMethods/DefaultMethMain2 - В этом классе предоставляются реализации обоих методов](https://github.com/Vladlena2/BookJava/blob/main/Chapter9/DefaultMethods/DefaultMethMain2.java "Посмотреть пример Java")

Усовершенствуем интерфейс IntStack дополнив его новыми функциональными возможностями, не нарушая уже существующий код. Благодаря внедрению методов с реализацией по умолчанию добавим метод очищающий стек, чтобы подготовить его к повторному использованию.
Например, интерфейс IntStack можно усовершенствовать следующим образом:

```html
interface IntStack {
   void push(int item); // сохранить элемент в стеке
   int pop(); // извлечь элемент из стека
   
   // метод очищающий стек по умолчанию
   default void clear() {
   System.out.println("Метод очищающий стек пока не реализован.");
   }   
}
```

Данный метод пока только выводит сообщение по умолчанию. Его нельзя вызвать из уже существующего класса, реализующего интерфейс IntStack.

Но метод clear() может быть реализован в новом классе вместе с интерфейсом IntStack. Новую реализацию метода clear() потребуется определить лишь в том случае, если он используется.

Метод с реализацией по умолчанию предоставляет возможность сделать следующее:
- изящно расширить интерфейс со временем;
- предоставить дополнительные функциональные возможности, исключая замещающую реализацию в классе, если эти функциональные возможности не требуются.

Методы с реализацией по умолчанию предоставляют отчасти возможности, которые обычно связываются с понятием * множественного наследования*. Например, в одном классе можно реализовать два интерфейса. Если в каждом из этих интерфейсов предоставляются методы с реализацией по умолчанию, то некоторое поведение наследуется от обоих интерфейсов.
- Приоритет отдается реализации метода в классе над его реализацией в интерфейсе.
- В тех случаях, когда один интерфейс наследует другой и в обоих интерфейсах определяется общий метод с реализацией по умолчанию, предпочтение отдается варианту метода из наследующего интерфейса.

</details>

<details><summary>Проблемы множественного наследования</summary>

Как объяснялось в книге, в Java нет множественного наследования классов. Несмотря на то, что интерфейс теперь может содержать стандартные методы, вас может заинтересовать, можно ли обойти это ограничение с помощью интерфейсов. Ответ: в сущности, нет.

Однако стоит отметить, что стандартные методы предоставляют функционал, который обычно ассоциируется с концепцией множественного наследования. Например, у вас может быть класс, реализующий два интерфейса, каждый из которых предоставляет стандартные методы. В таком случае поведение будет наследоваться от обоих интерфейсов. Таким образом, в ограниченной степени стандартные методы поддерживают множественное наследование поведения.

Как и следовало ожидать, в такой ситуации возможны конфликты имён. Например, если класс MyClass реализует два интерфейса Alpha и Beta, и оба интерфейса предоставляют метод reset() со стандартной реализацией, возникает вопрос: какая версия метода reset() будет использоваться в классе MyClass — из интерфейса Alpha или из интерфейса Beta?

Если интерфейс Beta расширяет интерфейс Alpha, какая версия стандартного метода будет использоваться? А если класс MyClass предоставляет свою собственную реализацию метода? Для обработки таких и подобных ситуаций в Java есть набор правил, позволяющих разрешать возникающие конфликты.

Во-первых, если в классе есть собственная реализация метода, она и будет использоваться. Во-вторых, если один из интерфейсов предоставляет стандартную реализацию метода, а другой — нет, будет использоваться та, что с реализацией. В-третьих, если оба интерфейса предоставляют стандартные реализации метода, но одна из них расширяет другую, будет использоваться более специализированная версия.

Во-вторых, если класс реализует два интерфейса, которые оба предоставляют стандартный метод, но класс не переопределяет его, возникает ошибка. В нашем примере, если класс MyClass реализует интерфейсы Alpha и Beta, но не переопределяет метод reset(), возникает ошибка.

В случаях, когда один из интерфейсов наследует другой и оба определяют общий стандартный метод, версия из наследующего интерфейса будет приоритетной. В нашем случае, если Beta наследует Alpha, будет использоваться версия reset() из Beta.

Используя ключевое слово super в унаследованном интерфейсе, можно явно сослаться на стандартную реализацию:

```html
ИмяИнтерфейса.suреr.имяМетода() 
```

Например, если в Beta нужно сослаться на стандартный метод reset из Alpha, можно использовать следующий код:

```html
default void reset() {
    Alpha.super.reset();
}
```

</details>

<details><summary>Применение статических методов в интерфейсе</summary>
       
В JDK 8, у интерфейсов появилась еще одна возможность: определять в нем один или несколько статических методов.
Метод, объявляемый в интерфейсе как static, можно вызывать независимо от любого объекта. И для этого не требуется ни реализация такого метода в интерфейсе, ни экземпляр самого интерфейса. Напротив, для вызова статического метода достаточно указать имя интерфейса и через точку имя самого метода.
В приведенном ниже примере кода демонстрируется ввод статического метода getDefaultNumber() в упоминавшийся ранее интерфейс MyIF. Этот метод возвращает нулевое значение.

```html
public interface MyIF {
    // Это объявление обычного метода в интерфейсе. Он НЕ предоставляет реализацию по умолчанию
    int getNumber();

    // А это объявление метода с реализацией по умолчанию. Обратите внимание на его реализацию по умолчанию
    default String() {
        return "Объект типа String по умолчанию";
    }

    // Это объявление статического метода в интерфейсе
    static int getDefaultNumber {
        return 0;
    }
}
```

Метод getDefaultNumber() может быть вызван следующим образом:

```html
int defNum = MyIF.getDefaultNumber(); 
```

Для вызова метода getDefaultNumber() реализация или экземпляр интерфейса MyIF не требуется, поскольку это статический метод.

Замечание: статические методы из интерфейсов не наследуются ни реализующими их классами, ни подчиненными интерфейсами.

</details>

<details><summary>Закрытые методы интерфейсов</summary>

С версии JDK 9, в интерфейс можно включать закрытый метод. Такой метод можно вызвать только из метода, реализуемого по умолчанию или другого закрытого метода в том же самом интерфейсе. А поскольку закрытый метод интерфейса объявляется как private, то им нельзя воспользоваться в коде за пределами того интерфейса, где он определен.

Главное преимущество закрытого метода интерфейса заключается в том, что он позволяет использовать общий фрагмент кода в двух и большем числе методов с реализацией по умолчанию, исключая тем самым дублирование кода.

В качестве примера ниже приведена очередная версия интерфейса IntStack с двумя реализуемыми по умолчанию методами popNElements() и skipAndPopNElements(). Первый из них возвращает массив из N элементов, начиная с вершины стека, а второй сначала пропускает указанное количество элементов, а затем возвращает массив из следующих N элементов. В обоих методах вызывается закрытый метод getElements() с целью извлечь из стека массив с указанным количеством элементов.

Обратите внимание на то, что закрытый метод getElements() вызывается в обоих методах popNElements() и skipAndPopNElements() с целью получить возвращаемый массив извлекаемых из стека элементов. Благодаря этому исключается дублирование одного и того же кода в этих реализуемых по умолчанию методах.

Следует, однако, иметь в виду, что метод getElements() нельзя вызвать за пределами его интерфейса, поскольку он объявлен закрытым. Это означает, что его применение ограничивается пределами интерфейса IntStack (в данном случае - методами с реализацией по умолчанию). А поскольку для извлечения элементов из стека в методе getElements() применяется метод рор(), то в нем автоматически вызывается вариант данного метода, предоставляемый в реализации интерфейса IntStack. Следовательно, метод пригоден для работы с классом любого стека, реализующим интерфейс IntStack.

```html
//Очередная версия интерфейса IntStack с закрытым методом, применяемым в двух реализуемых по умолчанию методах.
interface IntStack {
    void push(int item); // сохранить элемент в стеке
    int pop();           // извлечь элемент из стека

    // Метод с реализацией по умолчанию, возвращающий массив из N элементов, начиная с вершины стека
    default int[] popNElements(int n) {
        return getElements(n); // возвратить запрашиваемые элементы из стека
    }

    // Метод с реализацией по умолчанию, возвращающий из стека массив из N элементов,
    // следующих после указанного количества пропускаемых элементов
    default int[] skipAndPopNElements(int skip, int n) {
        getElements(skip);      // пропустить указанное количество элементов в стеке
        return getElements(n);  // возвратить запрашиваемые элементы из стека
    }

    // Закрытый метод, возвращающий массив из N элементов, начиная с вершины стека
    private int[] getElements(int n) {
        int[] elements = new int[n];
        for (int i = 0; i < n; i++) elements[i] = pop();
        return elements;
    }
}
```

Как правило, закрытые методы интерфейсов не находят широкого применения.

</details>

</details>

<details><summary>Почему в Java нет множественного наследования классов</summary>

[Почему в Java нет множественного наследования классов](https://sky.pro/media/chto-takoe-abstraktnye-klassy/#:~:text=%D0%92%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE%2D%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%20%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0%D1%85%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D1%8B%D0%BC,%E2%80%94%20%D0%B8%D0%BB%D0%B8%2C%20%D0%BF%D0%BE%2D%D0%B4%D1%80%D1%83%D0%B3%D0%BE%D0%BC%D1%83%2C%20%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D1%83%20%D0%B0%D0%BB%D0%BC%D0%B0%D0%B7%D0%B0)

</details>

</blockquote>
</details>

<details ГЛАВА 10><summary>ГЛАВА 10. "Обработка исключений"</summary>
<blockquote>

Исключение - это нестандартная ситуация, которая возникает во время исполнения кода. Иными словами, исключение представляет собой ошибку времени исполнения. В языках программирования, которые не поддерживают обработку исключений, необходимо проверять и обрабатывать ошибки вручную - обычно через коды ошибок и т. д. Такой подход столь же сложный, сколь и трудоемкий. Обработка исключений в Java позволяет избежать подобных проблем и одновременно переносит управление ошибками во время исполнения в объектно-ориентированный мир.

<details><summary>Основы обработки исключений</summary>

Исключение Java представляет собой объект.

Обработка исключений в Java управляется пятью ключевыми словами: try, catch, throw, throws и finally.


При возникновении нестандартной ситуации в методе, который вызвал ошибку, создается объект, представляющий эту нестандартную ситуацию. Метод может обработать эту нестандартную ситуация самостоятельно или передать ее дальше. В любом случае, в какой-то момент эта нестандартная ситуация перехватывается и обрабатывается. Нестандартные ситуации могут возникать из-за исполняющей среды Java или создаваться вручную в вашем коде. Нестандартные ситуации, возникающие из-за Java, связаны с основными ошибками, которые нарушают правила Java или ограничения исполняющей среды Java. Нестандартные ситуации, созданные вручную, обычно используются для сообщения об ошибках вызывающему методу.

Программы, которые вы хотели бы отследить на предмет исключений, помещаются в блок try. Если в рамках этого блока возникает нестандартная ситуация, она генерируется. Код может обработать это исключение (с помощью конструкции catch) и рационально его обработать. Нестандартные ситуации, создаваемые исполняющей средой Java, генерируются автоматически. Для ручной генерации нестандартной ситуации используется ключевое слово throw. Любое исключение, которое генерируется в методе, должно указываться с помощью конструкции throws. Весь код, который должен обязательно выполняться после завершения блока try, размещается в блоке finally.

Ниже показана общая форма блока обработки исключений:

```html
try { 
// блок кода , где отслеживаются ошибки
}
catch ( ТипИсключенияl объектИсключения) {
// обработчик исключений для ТипИсключенияl
}
catch ( ТипИсключения2 объектИсключения) { 
// обработчик исключений для ТипИсключения2
}
// ... 
finally {
// блок кода, подлежащий выполнению nосле о кончания блока try 
}
```

</details>

<details><summary>Типы исключений</summary>
       
Все типы исключений являются подклассами, производными от встроенного класса **Throwable**. Это означает, что класс **Throwable** находится на вершине иерархии классов исключений. Сразу же за классом Throwable ниже по иерархии следуют два подкласса, разделяющие все исключения на две ветви. Одну ветвь возглавляет класс Exception. Он служит для исключительных условий, которые должна перехватывать прикладная программа. Именно от этого класса вам и предстоит наследовать свои подклассы при создании собственных типов исключений. У класса Exception имеется важный подкласс - RuntimeException. Исключения типа RuntimeException автоматически определяются для создаваемых вами прикладных программ и охватывают такие ошибки, как деление на нуль и ошибочная индексация массивов.

Другая ветвь возглавляется классом Error, определяющим исключения, появление которых не предполагается при нормальном выполнении программы. Исключения типа Error используются в исполняющей системе Java для обозначения ошибок, происходящих в самой исполняющей среде. Примером такой ошибки может служить переполнение стека.

        Throwable
        /       \
       /         \
 Exception      Error
      |
RuntimeException

</details>

<details><summary>Неперехваченные исключения</summary>
       
Следующая небольшая программа содержит выражение, которое намеренно вызывает 
ошибку деления на ноль: 

```html
class ЕхсО { 
public static void main (String[] args ) { 
int d = О; 
int а = 42 / d; 
} 
}
```

Когда исполняющая среда Java выявляет попытку деления на нуль, она создает новый объект исключения, а затем генерирует данное исключение. В результате исполнение класса ExсO прекращается, так как после генерации исключение должно быть обработано обработчиком исключений и немедленно обработано.

В представленном примере не предусматривалось наличие каких-либо собственных обработчиков исключений. Поэтому исключение обрабатывается стандартным обработчиком, предоставляемым исполняющей средой Java. Любое исключение, которое не обработано вашей программой, будет в конечном итоге обработано стандартным обработчиком.

Стандартный обработчик отображает строку с описанием исключения, выводит трейсбек стека от точки, где произошло исключение, и останавливает работу программы.

</details>

<details><summary>Использование try и catch</summary>

Самостоятельная обработка, во-первых, дает возможность исправить ошибку и, во-вторых, предотвращает автоматическое завершение работы программы. Большинство пользователей будут (как минимум) сбиты с толку, если ваша программа остановится, начав отображать трейсбек стека каждый раз, когда возникает ошибка!

[Chapter10/Exc2 - Пример обработки исключения](https://github.com/Vladlena2/BookJava/blob/main/Chapter10/Exc2.java "Посмотреть пример Java")

Целью большинства корректно созданных конструкций catch должен быть анализ исключительной ситуации и продолжение выполнения кода, как будто ошибка вообще не произошла.

В приведенном ниже примере программы на каждом шаге цикла for получаются два случайных числа. Эти два числа делятся одно на другое, а результат используется для деления числового значения 12 . Окончательный результат размещается в переменной а. Если какая-нибудь из этих операций деления приводит к ошибке деления на нуль, эта ошибка перехватывается, в переменной а устанавливается нулевое значение и программа выполняется дальше.

[Chapter10/HandleError - Обработать исключение и продолжить работу](https://github.com/Vladlena2/BookJava/blob/main/Chapter10/HandleError.java "Посмотреть пример Java")

</details>

<details><summary>Использование нескольких конструкций catch</summary>

Когда в одном фрагменте кода возникает более одного исключения. В таком случае можно указать два или больше оператора *catch*, каждый из которых предназначается для перехвата отдельного типа исключения. Когда генерируется исключение, каждый оператор catch проверяется по порядку, и выполняется тот из них, который совпадает по типу с возникшим исключением. По завершении одного из операторов catch все остальные пропускаются, и выполнение программы продолжается с оператора, следующего сразу за блоком операторов try/catch.

В этой программе произойдет исключение в связи с делением на нуль, если она будет запущена без аргументов командной строки. Ведь в этом случае значение переменной а будет равно нулю. Деление будет выполнено нормально, если программе будет передан аргумент командной строки, устанавливающий в переменной а значение больше нуля. Но в этом случае возникнет исключение типа ArrayindexOutOfBoundsException, поскольку длина массива целых чисел "m" равна 1, тогда как программа пытается присвоить значение элементу массива "m" [10].

[Chapter10/MultipleCatches - Продемонстрировать применение нескольких операторов catch](https://github.com/Vladlena2/BookJava/blob/main/Chapter10/MultipleCatches.java "Посмотреть пример Java")

Важно помнить, что перехват исключений из подклассов должен следовать до перехвата исключений из суперклассов.

Дело в том, что оператор catch, в котором перехватывается исключение из суперкласса, будет перехватывать все исключения из этого суперкласса, а также все исключения из его подклассов. Это означает, что исключения из подкласса вообще не будут обработаны, если попытаться перехватить их после исключений из его суперкласса. Кроме того, недостижимый код считается в Java ошибкой.

[Chapter10/SuperSubCatch - Эта программа содержит ошибку](https://github.com/Vladlena2/BookJava/blob/main/Chapter10/SuperSubCatch.java "Посмотреть пример Java")

Если попытаться скомпилировать эту программу, то появится сообщение об ошибке, уведомляющее, что второй оператор * catch* недостижим, потому что исключение уже перехвачено. Класс исключения типа ArithmeticException является производным от класса Exception, и поэтому первый оператор catch обработает все ошибки, относящиеся к классу Exception, включая и класс ArithmeticException. Это означает, что второй оператор catch так и не будет выполнен. Чтобы исправить это положение, придется изменить порядок следования операторов catch.

[Chapter10/SuperSubCatch2 - В этом коде исправлена ошибка](https://github.com/Vladlena2/BookJava/blob/main/Chapter10/SuperSubCatch2.java "Посмотреть пример Java")

</details>

<details><summary>Вложенные операторы try</summary>

Оператор try может быть вложен, то есть находиться внутри другого оператора try. При входе в try контекст исключения помещается в стек. Если у внутреннего оператора try нет обработчика catch для определенного исключения, стек разворачивается, и проверяются обработчики исключения следующего оператора try. Этот процесс продолжается до тех пор, пока подходящая конструкция catch не будет найдена или все вложенные операторы try не будут исчерпаны.

[Chapter10/NestedTry - Пример применения вложенных операторов try](https://github.com/Vladlena2/BookJava/blob/main/Chapter10/NestedTry.java "Посмотреть пример Java")

Вложение операторов try может быть не столь очевидным при вызовах методов. Например, вызов метода можно заключить в блок оператора try, а в теле этого метода организовать еще один блок оператора try. В этом случае блок оператора try в теле метода оказывается вложенным во внешний блок оператора try, откуда вызывается этот метод. Ниже приведена версия предыдущей программы, где блок вложенного оператора try перемещен в тело метода nesttry(). Эта версия программы выводит такой же результат, как и предыдущая.

[Chapter10/MethNestedTry - Операторы try могут быть неявно вложены в вызовы методов](https://github.com/Vladlena2/BookJava/blob/main/Chapter10/MethNestedTry.java "Посмотреть пример Java")

</details>

<details><summary>Оператор throw</summary>

Программа может создать исключение явно с использованием оператора throw и следующей общей формы:

```html
throw ThrownаЫеinstance;
```

Здесь ThrownаЫeinstance должна быть объектом класса ThrownаЫe или подкласса ThrownаБЫe. Примитивные типы, такие как int или char, и классы, отличные от ThrownаБЫe, такие как String или Objеct, не могут использоваться в качестве исключений. Существуют два способа получения объекта ThrownaЫe - указание параметра в конструкции catch или создание его с помощью операции new.

[Chapter10/ThrowDemo - Продемонстрировать применение оператора throw](https://github.com/Vladlena2/BookJava/blob/main/Chapter10/ThrowDemo.java "Посмотреть пример Java")

</details>

<details><summary>Оператор throws</summary>

Если метод способен вызвать исключение, которое он сам не обрабатывает, то он должен задать свое поведение таким образом, чтобы вызывающий его код мог обезопасить себя от такого исключения. С этой целью в объявление метода вводится оператор throws, где перечисляются типы исключений, которые метод может генерировать. Это обязательно для всех исключений, кроме тех, которые относятся к классам Error и * RuntimeException* или любым их подклассам. Все остальные исключения, которые может сгенерировать метод, должны быть объявлены в операторе throws. Если этого не сделать, то во время компиляции возникнет ошибка.
Общая форма объявления метода, которая включает оператор throws:

```html
тип имя_метода(список_параметров) throws список_исключений
{
 // тело метода
}
```

Здесь список_исключений обозначает разделяемый запятыми список исключений, которые метод может сгенерировать.

[Chapter10/ThrowsDemo - Продемонстрировать throws](https://github.com/Vladlena2/BookJava/blob/main/Chapter10/ThrowsDemo.java "Посмотреть пример Java")

Например, у нас имеется метод вычисления факториала, и нам надо обработать ситуацию, если в метод передается число меньше 1. Наш метод, в котором генерируется исключение, сам не обрабатывает это исключение. В этом случае в объявлении метода используется оператор throws, который надо обработать при вызове этого метода.

С помощью оператора throw по условию выбрасывается исключение. В то же время метод сам это исключение не обрабатывает с помощью try..catch, поэтому в определении метода используется выражение throws Exception. Теперь при вызове этого метода нам обязательно надо обработать выбрасываемое исключение:

[Chapter10/ThrowsFactorial - Пример, метод вычисления факториала throws](https://github.com/Vladlena2/BookJava/blob/main/Chapter10/ThrowsFactorial.java "Посмотреть пример Java")

</details>

<details><summary>Конструкция finally</summary>

Когда генерируются исключения, поток выполнения в методе направляется по довольно резкому нелинейному пути, изменяющем нормальный ход выполнения метода. В зависимости от того, как закодирован метод, исключение может даже привести к преждевременому возврату из метода, что в некоторых методах может стать проблемой. Например, если метод открывает файл при входе и закрывает его при выходе, то пропуск кода закрывающего файл механизмом обработки исключений считать приемлемым нельзя. Для такой нештатной ситуации предназначено ключевое слово finally.

Ключевое слово finally позволяет создать блок кода, который будет выполняться после завершения блока try/catch и перед следующим после try/catch кодом. Блок finally выполняется независимо от того, создано исключение или нет. Если создано исключение, блок finally выполняется даже если исключение не подходит ни к одной конструкции catch. Каждый раз когда метод собирается вернуть управление вызывающему коду через неперехваченное исключение из блока try/catch или явно через оператор возврата, блок finally также выполняется непосредственно перед тем как метод вернет управление. Таким образом с помощью блока finally удобно закрывать файловые дескрипторы или освобождать другие ресурсы которые могли быть заняты в начале метода и которые должны быть освобождены до возврата управления. Конструкция finally не является обязательной, однако для каждого оператора try должна существовать хотя бы одна конструкция catch или finally.

Пример программы, в котором демонстрируются три метода, возвращающих управление разными способами. Но ни в одном из них не пропускается выполнение блока оператора finally.

[Chapter10/FinallyDemo - Продемонстрировать применение оператора finally](https://github.com/Vladlena2/BookJava/blob/main/Chapter10/FinallyDemo.java "Посмотреть пример Java")

ВАЖНО!!! Если блок оператора finally связан с блоком оператора try, то блок оператора finally будет выполнен по завершении блока оператора try.

[Chapter10/ExampleException - Продемонстрировать все исключения](https://github.com/Vladlena2/BookJava/blob/main/Chapter10/ExampleException.java "Посмотреть пример Java")

</details>

<details><summary>Создание собственных подклассов Exception</summary>

В самом классе Exception не определено никаких методов. Разумеется, он наследует методы, предоставляемые Throwable. Таким образом, все исключения, включая те, которые вы создаете, имеют доступные для них методы, определенные в классе Throwable. Вы также можете переопределить один или несколько из этих методов в классах исключений, которые вы создаете.

В классе Exception определено четыре открытых конструктора. Два из них поддерживают сцепленные исключения, которые обсуждаются в следующем разделе, а другие два показаны ниже:

```html
Exception()
Exception(String msg)
```

Первая форма конструктора создает исключение без описания. Вторая форма конструктора позволяет указать описание исключения в аргументе msg.

Хотя указание описания при создании исключения часто полезно, иногда
лучше переопределить метод toString() и вот почему: версия toString(),
определенная в классе ThrowaЫe (и унаследованная классом Exception),
сначала отображает имя исключения, за которым следует двоеточие и ваше
описание. Переопределив toString(), вы можете запретить отображение
имени исключения и двоеточия, сделав вывод более чистым, что желательно в некоторых случаях.
В следующем примере объявляется новый подкласс Exception, который
з атем используется для сигнализации об ошибке в методе. В подклассе переопределяется метод toString(), позволяя отобразить аккуратно настроенное описание исключения.   

В данном примере создается подкласс MyException класса Exception. Он довольно прост и содержит только конструктор и переопределённый метод toString(), который выводит значение исключения.

В классе ExceptionDemo определяется метод calculate(), который создает объект MyException. Исключение генерируется при целочисленном параметре метода calculate() больше 10.

В методе main() устанавливается обработчик исключений для MyException, после чего вызывается метод calculate() с допустимым (меньше 10) и недопустимым значениями, чтобы продемонстрировать оба пути выполнения кода.

[Chapter10/MyException - Создание собственных подклассов Exception](https://github.com/Vladlena2/BookJava/blob/main/Chapter10/MyException.java "Посмотреть пример Java")

</details>

<details><summary>Сцепленные исключения</summary>

Сцепленные исключения позволяют ассоциировать с одним исключением другое исключение, описывающее причину первого исключения. Это может быть полезно, например, в ситуации, когда метод генерирует исключение ArithmeticException из-за деления на ноль. Однако фактической причиной проблемы была ошибка ввода-вывода, в результате которой делитель был установлен неправильно. Несмотря на то, что метод должен сгенерировать исключение ArithmeticException, поскольку именно эта ошибка произошла, вы можете информировать вызывающий код, что основной причиной является ошибка ввода-вывода. Сцепленные исключения помогают справиться с такими и любыми другими ситуациями, когда имеются вложенные уровни исключений.

Для поддержки сцепленных исключений в класс Throwable были добавлены два конструктора:

```html
Throwable(Throwable cause)
Throwable(String message, Throwable cause)
```

Первый принимает в качестве аргумента исключение, которое стало причиной для возникновения текущего исключения. Второй позволяет указать сообщение об ошибке вместе с указанием причины исключения. Оба эти конструктора были также добавлены в классы Error, Exception и RuntimeException.

Класс Throwable также поддерживает методы getCause() и initCause(), которые позволяют получить или установить причину исключения.

```html
Throwable getCause()
Throwable initCause(Throwable cause)
```

Метод getCause() возвращает исключение, которое послужило причиной для текущего исключения. Если такого исключения нет, возвращается null. Метод initCause() связывает cause с текущим исключением и возвращает ссылку на это исключение.

Таким образом, можно связать причину с исключением уже после его создания. Однако, исключение-причину можно установить только один раз - вызывать initCause для одного объекта исключения можно только однажды. Кроме того, если исключение-причина уже было установлено через конструктор, его нельзя установить снова через initCause. В целом, метод initCause используется для установки причины для старых классов исключений, которые не поддерживают два дополнительных конструктора, описанных ранее.

[Chapter10/ChainExcDemo - Сцепленные исключения](https://github.com/Vladlena2/BookJava/blob/main/Chapter10/ChainExcDemo.java "Посмотреть пример Java")

В представленном примере исключение верхнего уровня - NullPointerException. К нему добавляется исключение-причина - ArithmeticException. Когда исключение генерируется в demoproc(), оно перехватывается в main(). Здесь отображается исключение верхнего уровня и базовое исключение, полученное вызовом getCause(). Сцепленные исключения можно создавать любой желаемой глубины, так что у исключения-причины тоже может быть причина. Однако стоит помнить, что слишком длинная цепочка исключений может указывать на неудачное проектное решение.

</details>

<details><summary>Три дополнительных средства в системе исключений</summary>

В версии Java 7 в систему исключений было добавлено несколько новых и полезных инструментов. Первый из них автоматизирует процесс очистки ресурсов, таких как файлы, когда они больше не нужны. Он основан на расширенной форме оператора try под названием try-with-resources и описывается в главе 13, посвященной файлам.

Второй инструмент называется множественный перехват, а третий иногда упоминается как окончательная или улучшенная регенерация исключений. Последние два инструмента описаны ниже.

Инструмент множественного перехвата позволяет захватывать два или более исключений одним и тем же блоком catch. Часто два или более обработчика исключений используют одну и ту же последовательность кода, даже если они реагируют на разные типы исключений. Вместо использования отдельного обработчика для каждого типа исключения можно использовать один общий обработчик для обработки всех типов исключений без дублирования кода.

Для использования множественного перехвата нужно объединить все типы исключений в блоке catch через операцию “ИЛИ”: каждый параметр множественного перехвата становится final по умолчанию. Если необходимо, final можно указать явно, но это необязательно. Поскольку каждый параметр множественного перехвата является final, ему нельзя присвоить новое значение.

[Chapter10/MulitCatch - Множественный перехват](https://github.com/Vladlena2/BookJava/blob/main/Chapter10/MulitCatch.java "Посмотреть пример Java")

Программа генерирует ArithmeticException при попытке деления на ноль. Если закомментировать оператор деления и убрать символ комментария в следующей строчке, будет сгенерировано ArrayIndexOutOfBoundsException. Оба исключения обрабатываются одним блоком catch.
Инструмент улучшенной регенерации ограничивает типы исключений, которые могут быть повторно сгенерированы, только проверяемыми исключениями, созданными связанным блоком try, которые не обрабатываются предыдущим блоком catch и которые являются либо подтипами, либо супертипами параметра. Хотя эта возможность может потребоваться нечасто, теперь она доступна для использования. Для использования улучшенной регенерации параметр catch должен быть либо final (ему не должно присваиваться новое значение в блоке catch), либо явно объявлен как final.

</details>

</blockquote>
</details>

<details ГЛАВА 11><summary>ГЛАВА 11. "Многопоточное программирование"</summary>
<blockquote>

<details><summary>Введение</summary>
       
Многопоточная программа - это программа, которая состоит из двух или более потоков, способных выполняться одновременно. Каждый из этих потоков представляет отдельный путь выполнения, и все они работают совместно для выполнения общей задачи. Таким образом, многопоточность является специализированной формой многозадачности, позволяя выполнять несколько операций одновременно.

Однако есть два разных типа многозадачности: на основе процессов и на основе потоков.

Процесс - это экземпляр выполняющейся программы, и многозадачность на уровне процессов является способом, с помощью которого компьютер может выполнять две или более программы одновременно. Например, на уровне процессов можно скомпилировать код Java и одновременно использовать текстовый редактор или работать с веб-сайтом. Многозадачность на уровне процессов позволяет координировать выполнение наименьшей единицы кода, которую может контролировать планировщик - программы.

Планировщик задач - это часть операционной системы, которая отвечает за распределение ресурсов компьютера между различными работающими программами. В контексте многозадачности на уровне процессов планировщик задач управляет временем центрального процессора, памятью и другими ресурсами, чтобы обеспечить эффективное выполнение каждой программы.

В многопоточной среде поток является наименьшей единицей кода, который может координироваться, то есть одна программа может выполнять две или более задачи одновременно. Например, в текстовом редакторе можно форматировать текст и одновременно выводить его на печать, если эти две операции выполняются разными потоками. Многозадачность на основе процессов работает на более высоком уровне, управляя общими ресурсами и задачами, в то время как многопоточная многозадачность управляет деталями выполнения отдельных операций.

Многопоточная многозадачность обычно требует меньше ресурсов, чем многозадачность на основе процессов. Процессы требуют отдельного адресного пространства и больше ресурсов, а взаимодействие между ними может быть сложным и ресурсоемким. Переключение между контекстами разных процессов также требует больше ресурсов.

С другой стороны, потоки имеют меньше требований к ресурсам. Они разделяют одно адресное пространство и общий процесс. Взаимодействие между потоками недорого и переключение между ними тоже недорого. В то время, как Java-программы используют многозадачность на основе процесса, она не контролируется непосредственно Java, но есть некоторые аспекты, которые она может контролировать. Например, через API Java можно создать новый поток или процесс, управлять приоритетами потоков и т.д. Тем не менее, многопоточная многозадачность есть.

Многопоточная многозадачность - это более узкое понятие. Это когда в рамках одной задачи выполняется несколько потоков. А просто многозадачность - это когда выполняется несколько задач одновременно.

Многопоточность позволяет разработчикам писать более эффективные программы, которые используют всю доступную вычислительную мощность в системе.

Одним из ключевых способов достижения этой цели с помощью многопоточности является минимизация времени простоев, что особенно актуально для интерактивной сетевой среды Java, где простои неизбежны. Скорость передачи данных по сети значительно ниже скорости обработки данных компьютером, так же как и ресурсы локальной файловой системы считываются и записываются медленнее, чем могут быть обработаны процессором. Кроме того, пользовательский ввод значительно медленнее возможностей компьютера. В однопоточном режиме программа вынуждена ожидать завершения каждой задачи до перехода к следующей, даже если большая часть времени уходит на ожидание ввода. Многопоточность сокращает время простоев, так как во время ожидания ввода одного потока другой может продолжать выполнение.

</details>

<details><summary>Потоковая модель Java</summary>

Среда исполнения Java во многом полагается на потоки, и все библиотеки классов разработаны с учётом многопоточности. Java использует потоки, делая всю среду асинхронной, что помогает снизить неэффективность, предотвращая простои центрального процессора (за счет предотвращения потери циклов центрального процессора). 

Цикл - это последовательность команд, которые выполняются процессором друг за другом. Потеря цикла означает, что процессор простаивает, не выполняя никаких действий. Предотвращение потери циклов позволяет использовать процессор более эффективно.

В однопоточных системах используется подход, называемый циклом обработки событий с опросом. В этой модели один поток управления работает в бесконечном цикле, проверяя одну очередь событий на наличие новых задач. Когда этот цикл обнаруживает, например, сигнал о том, что сетевой файл готов для чтения, он передает управление соответствующему обработчику событий. До тех пор, пока этот обработчик не завершит свою работу, программа не может выполнить никаких других задач, что приводит к неэффективному использованию процессорного времени. Кроме того, одна часть программы может начать доминировать в системе и препятствовать обработке всех остальных событий. В общем, в однопоточном окружении, когда поток блокируется в ожидании какого-либо ресурса, вся программа останавливается.

Преимущество многопоточности в Java состоит в том, что устраняется механизм главного цикла/опроса. Один поток может быть приостановлен без остановки других частей программы. Например, простои, возникающие при чтении данных из сети одним потоком или ожидании пользовательского ввода, могут быть использованы в другом месте. Многопоточность позволяет анимационным циклам приостанавливаться на секунду между кадрами без паузы всей системы. Когда поток заблокирован в Java-программе, блокируется только один поток. Все остальные потоки продолжают работать.

Многопоточность в Java работает как в одноядерных, так и в многоядерных системах. В одноядерной системе два или более потока фактически не выполняются одновременно, но задействуется время простоя ЦП. В одноядерном процессоре два потока поочередно получают время процессора в рамках схемы временного дележа. Когда один поток завершает свой выделенный квант времени (или возникает событие, требующее переключения), операционная система переключает контекст на другой поток. Это происходит так быстро, что создается иллюзия параллельной работы, хотя фактически процессор выполняет инструкции последовательно для каждого потока.

В многоядерной системе, несколько потоков могут выполняться одновременно на разных ядрах процессора. Это позволяет увеличить скорость выполнения операций и повысить эффективность программы в целом.

Потоки могут находиться в различных состояниях. Вот общее описание возможных состояний потока:
- Поток может **выполняться**, то есть его код выполняется процессором.
- Готовый к выполнению поток может **ожидать** своей очереди на выполнение, если процессор занят другими потоками.
- Во время выполнения поток может быть **приостановлен**, то есть временно прекращает свою работу. - После этого выполнение потока может быть продолжено.
- Поток может быть **заблокирован**, ожидая какой-то ресурс, например, данные из сети.
- В любой момент выполнение потока можно **прекратить**, что немедленно останавливает его работу.
- После прекращения выполнения потока его дальнейшее выполнение **невозможно возобновить**.

</details>

<details><summary>Приоритеты потоков</summary>

Каждому потоку в Java присваивается приоритет, который определяет порядок обработки этого потока по сравнению с другими потоками. Приоритеты потоков являются целыми числами, которые определяют относительный приоритет одного потока относительно другого. Абсолютное значение приоритета не имеет смысла; поток с более высоким приоритетом не выполняется быстрее потока с более низким приоритетом, если это единственный работающий поток. Вместо этого приоритет потока используется для принятия решения о том, когда переключаться с одного работающего потока на другой. Этот процесс называется переключением контекста. Правила, определяющие, когда происходит переключение контекста, просты и приведены ниже.

Поток может добровольно отказаться от выполнения, например, передав управление другому потоку, приостановившись или заблокировавшись. В этом случае проверяются все остальные потоки и поток с наивысшим приоритетом получает процессор.

Поток может быть вытеснен другим потоком с более высоким приоритетом. В этом случае поток с более низким приоритетом, который не хочет уступать процессор, просто вытесняется потоком с более высоким приоритетом. Этот процесс называется вытесняющей многозадачностью.

Если два потока имеют одинаковый приоритет и конкурируют за процессорное время, ситуация усложняется. В некоторых операционных системах потоки с одинаковым приоритетом автоматически чередуются по времени в циклическом режиме. В других типах операционных систем потоки с одинаковым приоритетом должны добровольно передавать управление друг другу. Если они этого не делают, то другие потоки не запускаются.

Проблемы с переносимостью могут возникать из-за различий в том, как ОС переключают 
контекст для потоков с одинаковым приоритетом. 

</details>

<details><summary>Синхронизация</summary>

Поскольку многопоточность вносит асинхронное поведение в программы, необходимо иметь возможность обеспечить синхронность, когда это необходимо. Например, если вы хотите, чтобы два потока взаимодействовали и совместно использовали сложную структуру данных, такую как связанный список, вам нужен способ предотвращения конфликтов между ними. Другими словами, вы должны запретить одному потоку записывать данные, пока другой поток находится в процессе их чтения. В Java для этой цели реализован элегантный вариант старой модели синхронизации между потоками: монитор. Монитор представляет собой механизм управления, впервые определенный Ч.Э. Р. Хоаром. Вы можете рассматривать монитор как очень маленький “ящик”, в котором может находиться только один поток. Когда поток входит в монитор, все остальные потоки должны ждать, пока он не выйдет из него. Таким образом, монитор может использоваться для защиты общих ресурсов от манипуляций несколькими потоками одновременно.

В Java нет класса с названием “Monitor”. Вместо этого каждый объект имеет свой собственный неявный монитор, который автоматически вызывается при вызове одного из синхронизированных методов этого объекта. Когда поток находится внутри синхронизированного метода, другие потоки не могут вызывать какие-либо другие синхронизированные методы для того же объекта. Это позволяет создавать очень чистый и компактный многопоточный код, так как поддержка синхронизации встроена в язык.

</details>

<details><summary>Обмен сообщениями</summary>

После разделения вашей программы на несколько потоков вам нужно определить, как они будут взаимодействовать друг с другом. Для установления связи между потоками на других языках вам придется полагаться на операционную систему. Конечно, это приводит к увеличению накладных расходов. Java, напротив, предоставляет нескольким потокам простой и эффективный способ взаимодействия друг с другом через вызов предопределенных методов всех объектов. Система обмена Java сообщениями позволяет потоку входить в синхронизированный метод объекта и ожидать, пока другой поток явно не уведомит его о выходе.

</details>

<details><summary>Класс Thread и интерфейс Runnable</summary>

Поскольку вы не можете ссылаться на нематериальное состояние исполняющегося потока, вы будете работать с его представителем, то есть с экземпляром класса Thread, который его создал. Чтобы создать новый поток, ваша программа должна либо расширить класс Thread, либо реализовать интерфейс Runnable.

**Методы управления потоками исполнения из класса Thread**  
|Метод |Название|
|:----------|:-------|
|getName |Получает имя потока исполнения|
|getPriority|Получает приоритет потока исполнения|
|isAlive |Определяет, выполняется ли поток|
|join |Ожидает завершения потока исполнения|
|run |Задает точку входа в поток исполнения|
|sleep |Приостанавливает выполнение потока на заданное время|
|start |Запускает поток, вызывая ero метод run()|

### Главный поток 

Когда программа на Java запускается, первым выполняется один поток. Обычно его называют основным потоком программы, так как именно он выполняет запуск программы. Основной поток важен по двум причинам:
- он является потоком, из которого создаются другие “дочерние” потоки;
- часто он должен завершать свою работу, так как выполняет различные действия по завершению программы.

Хотя основной поток создается автоматически при запуске программы, его можно контролировать с помощью объекта Thread. Для этого нужно получить ссылку на него, вызвав метод currentThread(), который является открытым статическим методом класса Thread с общим видом:

```html
static Thread currentThread() 
```

Этот метод возвращает ссылку на тот поток, в котором он был вызван. Когда у вас есть ссылка на основной поток, вы сможете управлять им также, как и любым другим потоком.

[Chapter11/Package00/CurrentThreadDemo - Управление главным потоком исполнения](https://github.com/Vladlena2/BookJava/blob/main/Chapter11/Package00/CurrentThreadDemo.java "Посмотреть пример Java")

В приведенном примере ссылка на текущий поток (в данном случае основной) получается вызовом currentThread() и сохраняется в локальной переменной t. Затем программа выводит информацию о потоке, вызывает setName() для изменения имени потока и снова выводит информацию о потоке. После этого происходит обратный отсчет от пяти до одного с паузой, составляющей одну секунду, между выводом строк. Пауза достигается методом sleep(). Аргумент функции sleep() задает период
задержки в миллисекундах. Обратите внимание на блок try/catch, внутрькоторого помещен цикл. Метод sleep() в Thread может сгенерировать исключение InterruptedException в случае, если какой-то другой поток пожелает прервать этот спящий поток. В данном примере просто вводится сообщение, если поток прерывается, но в реальной программе пришлось бы поступать по-другому.

### Создание потока 

В языке Java предусмотрены два способа: 
- можно реализовать интерфейс Runnable;
- можно расширить класс Thread. 

### Реализация интерфейса RunnaЬle 

Вы можете создать поток для любого объекта, который реализует интерфейс Runnable. Для реализации Runnable в классе вам нужно реализовать только один метод с именем run().

В методе run() размещается код, который создает новый поток. Важно понимать, что run() может вызывать другие методы, использовать другие классы и объявлять переменные так же, как это делает основной поток. Разница заключается в том, что метод run() устанавливает точку входа для второго параллельного потока исполнения в программе. Этот поток завершается, когда управление возвращается из run(). После создания класса, который реализует интерфейс Runnable, внутри него создается объект типа Thread. Класс Thread содержит несколько конструкторов. Вот один из них: 

```html
Thread(Runnable threadObj, String threadName)
```

В указанном конструкторе threadObj является экземпляром класса, реализующим интерфейс Runnable. Он определяет место, где начинается выполнение потока. Имя нового потока задается параметром threadName. После создания новый поток будет запущен только после вызова его метода start(), объявленного в классе Thread. По сути, start() инициирует вызов run().

[Chapter11/Package01/ThreadDemo - Создать второй поток исполнения](https://github.com/Vladlena2/BookJava/blob/main/Chapter11/Package01/ThreadDemo.java "Посмотреть пример Java")

Новый объект Thread создается внутри конструктора класса NewThread с помощью следующего оператора:

```html
t = new Thread(this , "Demo Thread"); 
```

Передача this в качестве первого аргумента указывает на то, что новый поток должен вызвать метод run() для данного объекта. Внутри main() вызывается start(), который запускает поток выполнения, начиная с метода run(). Это приводит к тому, что цикл for дочернего потока начинает свою работу. Затем главный поток входит в цикл for. Оба потока продолжают работать, совместно используя ЦП в одноядерных системах, пока их цикл не завершится.

Как упоминалось ранее, в мноrопоточной программе часто бывает полезно, чтобы главный поток заканчивал работу последним. Предыдущая программа гарантирует, что главный поток завершится последним, потому что он засыпает на 1000 миллисекунд между итерациями, а дочерний поток - только на 500 миллисекунд. В итоге дочерний поток завершается раньше, чем главный. Вскоре вы увидите лучший способ дождаться завершения потока. 

### Расширение класса Thread 

Второй способ создания потока предусматривает создание нового класса, расширяющего Thread, и создание экземпляра этого класса. Расширяющий класс должен переопределить метод run(), который является точкой входа для нового потока. Как и раньше, вызов start() начинает выполнение нового 
потока.

[Chapter11/Package01/ExtendThread - Создать второй поток исполнения](https://github.com/Vladlena2/BookJava/blob/main/Chapter11/Package01/ExtendThread.java "Посмотреть пример Java")

### Выбор подхода

На данном этапе вам может быть интересно, почему в Java есть два способа создания дочерних потоков и какой подход лучше. Ответы на упомянутые вопросы касаются одного и того же. В классе Thread имеется несколько методов, которые могут быть переопределены в производном классе. 
Единственным методом, который должен быть переопределен, является run(). Конечно, это тот же самый метод, требующийся при реализации интерфейса Runnable. Многие программисты на Java считают, что классы следует расширять только тогда, когда они каким-то образом совершенствуются или адаптируются. Таким образом, если вы не собираетесь переопределять какие-то другие методы Thread, то вероятно лучше просто реализовать Runnable. Кроме того, благодаря реализации RunnaЫe ваш класс потока не придется наследовать от Thread, что позволяет наследовать его от другого класса.

</details>

<details><summary>Создание множества потоков</summary>

В прикладной программе можно порождать сколько угодно потоков исполнения. Например, в следующей программе создаются три дочерних потока исполнения:

[Chapter11/Package03/MultiThreadDemo - Создать несколько потоков исполнения](https://github.com/Vladlena2/BookJava/blob/main/Chapter11/Package03/MultiThreadDemo.java "Посмотреть пример Java")

</details>

<details><summary>Использование isAlive() и join()</summary>

В предыдущих примерах это достигается путем вызова функции s leep() в main() с достаточно длительной задержкой, что обеспечивает выполнение всех дочерних потоков до основного. Однако, такое решение вряд ли может считаться приемлемым, и также поднимает важный вопрос: как один поток может определить, когда другой поток завершился? К счастью, класс Thread предоставляет инструменты, которые помогают ответить на этот вопрос.

Есть два способа определить, завершился ли поток. Первый - вызвать для потока метод isAlive(), который определен в классе Thread и имеет следующую общую форму:

```html
final boolean isAlive()
```

Метод isAlive() возвращает true, если поток, для которого он вызван, все еще работает, и false в противном случае.
Несмотря на то, что метод isAlive() иногда полезен, для ожидания завершения потока обычно используется метод с именем join():

```html
final void join() throws InterruptedException
```

Этот метод ожидает завершения потока, для которого он вызывается. Название метода происходит от идеи вызывающего потока, который ждет, пока указанный поток не завершится. Также существуют различные формы метода join(), которые позволяют указать максимальное время ожидания завершения указанного потока.

[Chapter11/Package04/DemoJoin - Применить метод join(), чтобы ожидать завершения потоков исполнения](https://github.com/Vladlena2/BookJava/blob/main/Chapter11/Package04/DemoJoin.java "Посмотреть пример Java")

Как видите, после возврата управления из вызовов join() потоки остановили свое выполнение.

</details>

<details><summary>Приоритеты потоков</summary>

Приоритеты потоков используются планировщиком для определения того, когда следует начать выполнение каждого потока. Теоретически, в течение определенного периода времени, потоки с более высоким приоритетом получают больше процессорного времени, чем потоки с более низким приоритетом. Однако, на практике, количество процессорного времени, получаемого потоком, часто зависит от ряда факторов, помимо его приоритета (например, от способа реализации многозадачности операционной системой). Поток с более высоким приоритетом также может вытеснять поток с более низким приоритетом, например, когда поток с низким приоритетом начинает выполняться, но затем возобновляется выполнение потока с более высоким приоритетом (если он, например, выходит из режима ожидания или ввода-вывода).

Теоретически потоки с одинаковыми приоритетами должны получать равные возможности использования процессора. Однако следует проявлять осторожность. Помните, что Java предназначен для работы во множестве сред. Некоторые из этих сред реализуют многозадачность совершенно иными способами, чем другие. В целях обеспечения безопасности потоки с одинаковыми приоритетами иногда должны уступать управление другим потокам. Такой подход гарантирует, что все потоки могут работать в операционной системе без вытеснения друг друга.

На практике, даже в средах, где нет вытеснения, большинство потоков все равно могут запускаться, потому что большинство потоков в какой-то момент сталкиваются с блокирующими ситуациями, например, ожиданием ввода-вывода. В такой ситуации поток блокируется и другие потоки могут выполняться. Однако, если вы хотите обеспечить гладкую многопоточную работу, вам лучше не полагаться на этот факт. Кроме того, некоторые типы задач сильно загружают процессор. Потоки этого типа полностью занимают процессор. Для таких потоков необходимо иногда передавать управление, чтобы другие потоки могли выполняться.

Чтобы установить приоритет потока исполнения, следует вызвать метод setPriority() из класса Thread. Его общая форма выглядит следующим образом:

```html
final void setPriority(int уровень)
```

Здесь аргумент уровень обозначает новый уровень приоритета для вызывающего потока исполнения. Значение аргумента уровень должно быть в пределах от MIN_PRIORITY до МAX_PRIORITY. В настоящее время эти значения равны соответственно 1 и 10. Чтобы возвратить потоку исполнения приоритет по умолчанию, следует указать значение NORM_PRIORITY, которое внастоящее время равно 5. Эти приоритеты определены в классе Thread как статические конечные (static final) переменные. А для того чтобы получить текущее значение приоритета потока исполнения, достаточно вызвать метод getPriority() из класса Thread, как показано ниже.

```html
final int getPriority()
```

Разные реализации Java могут вести себя совершенно иначе в отношении планирования потоков исполнения. Большинство несоответствий возникает при наличии потоков исполнения, опирающихся на вытесняющую многозадачность вместо совместного использования времени ЦП. Наиболее безопасный способ получить предсказуемое межплатформенное поведение многопоточных программ на Java состоит в том, чтобы использовать потоки исполнения, которые добровольно уступают управление ЦП.

</details>

<details><summary>Синхронизация</summary>

Синхронизацией называется процесс, обеспечивающий доступ к одному совместно используемому ресурсу только одному потоку.
Монитор - это объект, используемый в качестве взаимоисключающей блокировки.
Только один поток исполнения может в одно и то же время владеть монитором. Когда поток исполнения запрашивает блокировку, то говорят, что он входит в монитор. Все другие потоки исполнения, пытающиеся войти в заблокированный монитор, будут приостановлены до тех пор, пока первый поток не выйдет из монитора. Обо всех прочих потоках говорят, что они ожидают монитор. Поток, владеющий монитором, может, если пожелает, повторно войти в него. Синхронизировать прикладной код можно с использованием ключевого слова **synchronized**.

[Chapter11/Package05/Synch - Пример синхронизированной программы](https://github.com/Vladlena2/BookJava/blob/main/Chapter11/Package05/Synch.java "Посмотреть пример Java")

Как только поток исполнения входит в любой синхронизированный метод экземпляра, ни один другой поток исполнения не сможет войти в какой-нибудь другой синхронизированный метод того же экземпляра.
Тем не менее несинхронизированные методы этого экземпляра по-прежнему остаются доступными для вызова.

</details>

<details><summary>Оператор synchronized</summary>
       
Общая форма оператора synchronized с синхронизированным блоком операторов.

```html
synchronized(ссылка_на_объект) {
//... синхронизируемые операторы
}
```

Здесь ссылка_на_объект обозначает ссылку на синхронизируемый объект. Блок оператора synchronized гарантирует, что вызов метода, являющегося членом того же класса, что и синхронизируемый объект, на который делается указанная ссылка_на_объект, произойдет только тогда, когда текущий поток исполнения успешно войдет в монитор данного объекта.

[Chapter11/Package06/Synch1 - Пример использования синхронизированого блока](https://github.com/Vladlena2/BookJava/blob/main/Chapter11/Package06/Synch1.java "Посмотреть пример Java")
  
</details>

<details><summary>Взаимодействие между потоками</summary>

В предыдущих примерах обеспечивалась безусловная блокировка асинхронного доступа к некоторым методам для других потоков. Использование неявных мониторов объектов в Java дает мощный эффект. Однако вы можете достичь более тонкого контроля, используя взаимодействие между потоками.

Как обсуждалось ранее, использование многопоточности вместо программирования с использованием событийного цикла позволяет разделить ваши задачи на отдельные логические блоки. Потоки также предоставляют дополнительное преимущество, устраняя необходимость в опросе. Опрос обычно реализуется в виде цикла, использующегося для проверки некоторого условия в цикле. Как только условие становится истинным, запускается соответствующее действие, что ведет к ненужной трате процессорного времени. Например, рассмотрим классическую проблему организации очереди, где один поток создает некоторые данные, а другой поток их обрабатывает. Чтобы усложнить задачу, предположим, что производителю необходимо дождаться окончания работы потребителя, прежде чем он начнет создавать новые данные. В случае опроса потребитель будет тратить много процессорного времени в ожидании, когда производитель начнет создавать данные. После того, как производитель завершает свою работу, потребитель начинает опрос, снова тратя процессорное время на ожидание окончания работы потребителя и так далее. Очевидно, что такая ситуация нежелательна.

В Java есть эффективный механизм взаимодействия между потоками, основанный на методах wait(), notify() и notifyAll(). Они позволяют избежать опроса и реализованы как финальные методы класса Object, поэтому доступны во всех классах. Эти методы можно использовать только из синхронизированного контекста. Хотя они сложны в вычислительном плане, правила их использования довольно просты:
- Метод wait() сообщает текущему потоку, что он должен уступить монитор и заснуть, пока другой поток не войдет в тот же монитор и вызовет notify() или notifyAll().
- Метод notify() будит один из потоков, ожидающих на том же объекте.
- Метод notifyAll() будит все потоки, ожидающие на том же объекте. Один из них получит доступ к монитору.

Важное замечание. Метод wait() обычно ожидает до тех пор, пока не будет вызван метод notify() или notifyAll(). Но вполне вероятно, хотя и в очень редких случаях, что ожидающий поток исполнения может быть возобновлен вследствие ложной активизации. При этом исполнение ожидающего потока возобновляется без вызова метода notify() или notifyAll().
Oracle рекомендует вызывать метод wait() в цикле, проверяющем условие, по которому поток ожидает возобновления. Пример программы, неправильно реализующей простую форму поставщика и потребителя данных.

  Эта программа состоит из четырех классов:
• Q - синхронизируемой очереди;
• Producer - поточного объекта, создающего элементы очереди;
• Consumer - поточного объекта, принимающего элементы очереди;
• РС - мелкого класса, в котором создаются объекты классов Q, Producer и Consumer.

[Chapter11/Package07/PC - НЕправильная реализация поставщика и потребителя](https://github.com/Vladlena2/BookJava/blob/main/Chapter11/Package07/PC.java "Посмотреть пример Java")

Как видите, после того, как поставщик отправит значение 1, запускается потребитель, который получает это значение пять раз подряд. Затем поставщик продолжает свою работу, поставляя значения от 2 до 7, не давая возможности потребителю получить их. Чтобы правильно реализовать взаимодействие поставщика и потребителя в рассматриваемом здесь примере программы на Java, следует применить методы wait() и notify() для передачи уведомлений в обоих направлениях:

[Chapter11/Package08/PCFixed - Правильная реализация поставщика и потребителя](https://github.com/Vladlena2/BookJava/blob/main/Chapter11/Package08/PCFixed.java "Посмотреть пример Java")

</details>

<details><summary>Взаимоблокировка</summary>

Взаимной блокировкой называется особый тип ошибки, которая происходит в том случае, когда потоки исполнения имеют циклическую зависимость от пары синхронизированных объектов. Предположим, что один поток исполнения входит в монитор объекта Х, а другой - в монитор объекта У, далее поток исполнения в объекте Х попытается вызвать любой синхронизированный метод для объекта У, он будет блокирован, как и предполагалось. Но если поток исполнения в объекте У, в свою очередь, попытается вызвать любой синхронизированный метод для объекта Х, то этот поток будет ожидать вечно, поскольку для получения доступа к объекту Х он должен снять свою блокировку с объекта У, чтобы первый поток исполнения мог завершиться. Взаимная блокировка является ошибкой, которую трудно отладить, по двум следующим причинам.
• Взаимная блокировка возникает очень редко, когда исполнение двух потоков точно совпадает по времени.
• Взаимная блокировка может возникнуть, если в ней участвует больше двух потоков исполнения и двух синхронизированных объектов. (Это означает, что взаимная блокировка может произойти в результате более сложной последовательности событий, чем в упомянутой выше ситуации.)

[Chapter11/Package09/Deadlock - Пример взаимной блокировки](https://github.com/Vladlena2/BookJava/blob/main/Chapter11/Package09/Deadlock.java "Посмотреть пример Java")

В частности, Соперничающий поток владеет монитором объекта "b", тогда как он ожидает монитор объекта "а". В то же время Главный поток владеет объектом "а" и ожидает получить объект "b". Следовательно, программа никогда не завершится. Как демонстрирует данный пример, если многопоточная программа неожиданно зависла, то прежде всего следует проверить возможность взаимной блокировки.

</details>

<details><summary>Приостановка, возобновление и остановка потоков исполнения</summary>

Поскольку методы suspend(), resume() или stop() для управления потоками теперь недоступны, может показаться, что нет способа приостановить, перезапустить или завершить поток. Однако, это не совсем так. Вместо этого, поток должен быть разработан таким образом, чтобы метод run() периодически проверял, должен ли он приостановить, возобновить или полностью остановить свое выполнение. Обычно это решается установкой флаговой переменной, указывающей состояние выполнения потока. Если флаговая переменная установлена в рабочее состояние, метод run() продолжает работу, позволяя потоку выполняться. Если переменная установлена в состояние приостановки, поток приостанавливается. Если она установлена в состояние остановки, поток завершается. Есть много способов написать такой код, но основной принцип будет одинаковым для всех программ.

Он является подходом, который должен использоваться в любом новом коде.

[Chapter11/Package10/SuspendResume - Пример приостановки и возобновления исполнения потока](https://github.com/Vladlena2/BookJava/blob/main/Chapter11/Package10/SuspendResume.java "Посмотреть пример Java")

</details>

<details><summary>Получен ие состояния потока</summary>

Чтобы получить текущее состояние потока исполнения, достаточно вызвать метод getState(), определенный в классе Thread, следующим образом:

```html
Thread.State getState()
```

Этот метод возвращает значение типа Thread.Stаtе, обозначающее состояние потока исполнения на момент вызова. Перечисление State определено в классе Thread. (Перечисление представляет собой список именованных констант).

|Значение   |Состояние|
|:----------|:-------|
|BLOCKED    |Поток приостановил выполнение, поскольку ожидает получения блокировки|
|NEW        |Поток еще не начал выполнение|
|RUNNAВLE   |Поток в настоящее время выполняется или начнет выполняться, когда  получит доступ к ЦП|
|TERМINATED |Поток завершил выполнение |
|TIМED_WAITING |Поток приостановил выполнение на определенный промежуток времени, например после вызова метода sleep(). Поток переходит в это состояние и при вызове метода wait() или join()|
|WAITING      |Поток приостановил выполнение, поскольку он ожидает некоторого действия, например вызова версии метода wait() или join() без заданного времени ожидания|  

Имея в своем распоряжении экземпляр класса Thread, можно вызвать метод getState(), чтобы получить состояние потока исполнения. Например, в следующем фрагменте кода определяется, находится ли поток исполнения thrd в состоянии RUNNABLE во время вызова метода getState():

```html
Thread.State ts = thrd.getState();
if(ts == Thread.State.RUNNABLE) // ... 
```

Нужно иметь в виду, что состояние потока исполнения может измениться после вызова метода getState(). Поэтому в зависимости от обстоятельств состояние, полученное при вызове метода getState(), мгновение спустя может уже не отражать фактическое состояние потока исполнения. По этой и другим причинам метод getState() не предназначен для синхронизации потоков исполнения. Он служит прежде всего для отладки или профилирования характеристик потока во время выполнения.

</details>

<details><summary>Использование фабричных методов для создания и запуска потока</summary>

В некоторых случаях нет необходимости отделять создание потока от его запуска. Другими словами, иногда удобно создать и запустить поток одновременно. Один из способов это сделать - использовать статический фабричный метод. Фабричный метод возвращает экземпляр класса. Обычно, фабричные методы - это статические методы класса.

Они используются по разным причинам, например, для инициализации объекта перед работой с ним, для настройки конкретного типа объекта или для обеспечения повторного использования объекта. В контексте создания и запуска потока фабричный метод создает поток, вызывает метод start() на потоке и возвращает ссылку на поток. Используя этот подход, вы можете создать и запустить поток с помощью одного вызова метода, упрощая свой код. Например, добавление в класс NewThread из приведенной в начале главы программы ThreadDemo фабричного метода, показанного ниже, позволит создать и запустить поток за один шаг:

```html
// Фабричный метод, который создает и запускает поток. 
public static NewThread createAndStart() { 
NewThread myThrd = new NewThread(); 
myThrd.t.start(); 
return myThrd;
}
```

С применением метода createAndStart() следующий фрагмент кода: 

```html
NewThread nt = new NewThread(); // Создать новый поток
nt.t.start(); // Запустить потом
```

можно заменить так:

```html
NewThread nt = NewThread .createAndStart();
```

В некоторых случаях может потребоваться сохранить ссылку на поток, но если это не нужно, можно создать и запустить его одной строкой кода без использования фабричного метода. Снова вернувшись к программе ThreadDemo, вот как создать и запустить поток NewThread:

```html
new NewThread().t.start();
```

Тем не менее, в реальных приложениях обычно требуется сохранять ссылку на поток, поэтому фабричный метод часто будет удачным вариантом.

</details>

Эффективное использование многопоточности в Java требует мышления в категориях параллельного выполнения, а не последовательного. Если в программе есть две подсистемы, способные работать одновременно, их следует сделать отдельными потоками. Но при этом следует помнить, что создание слишком большого количества потоков может ухудшить, а не улучшить производительность программы, так как переключение контекста требует определенных затрат. Если создать слишком много потоков, большая часть процессорного времени уйдет на переключение контекста, а не на выполнение программы!

</blockquote>
</details>

<details ГЛАВА 12><summary>ГЛАВА 12. "Перечисления, автоупаковка и аннотация"</summary>
<blockquote>

<details><summary>Перечисления</summary>

В своей основе перечисление - это список именованных констант, создающий новый тип данных с указанными значениями. Таким образом, объекты перечисления могут принимать только значения, определенные в этом списке. Иные значения недопустимы. Другими словами, перечисления позволяют четко указывать единственные возможные значения для данного типа данных. Обычно перечисления используются для определения наборов значений, которые представляют группы элементов, например коды ошибок выполнения операций (успех, отказ, ожидание) или состояния устройства (работает, остановлено, приостановлено). В ранних версиях Java для этого использовались final переменные, но перечисления обеспечивают более гибкий подход.

Хотя на первый взгляд, перечисления в Java и других языках могут показаться похожими, их схожесть лишь поверхностна, поскольку в Java перечисления определяются как типы классов. Благодаря преобразованию перечислений в классы, возможности перечислений значительно расширяются. Например, в Java перечисления могут иметь конструкторы, методы и переменные экземпляра. Из-за их гибкости и мощи, перечисления широко используются во всей Java API библиотеке.

Перечисление создается с применением ключевого слова enum 

```html
// Перечисление сортов яблок
enum Apple {
Jonathan, GoldenDel, RedDel, Winesap, Cortland
}
```

Идентификаторы Jonathan, GoldenDel и т. д. называются константами перечисления. Каждая из них автоматически объявляется как публичная статическая финальная переменная типа Apple. Кроме того, их тип - это тип перечисления, где они объявлены - в данном случае Apple. Таким образом, эти константы в Java называются “самоназванными”, где “самоназвание” относится к охватывающему его перечислению. После создания перечисления можно создать переменную этого типа. Однако, хотя перечисления определяются как тип класса, экземпляр перечисления не создается через new. Вместо этого переменная перечисления объявляется и используется аналогично переменной одного из примитивных типов данных. Например, переменная ap объявляется как принадлежащая типу перечисления Apple:

```html
Apple ар;
```

Поскольку ap относится к типу Apple, то единственные значения, которыми она может быть присвоена (или способна содержать) определяются перечислением. Например, следующий оператор присвоит ap значение RedDel:

```html
ар = Appl.e.RedDel;
```

Две константы перечислений можно сравнивать на равенство с использованием оператора ==. Например, приведенный ниже оператор сравнивает значение переменной ap с константой GoldenDel:

```html
if(ap == Apple.GoldenDel) // ...
```

Значение перечисления также может использоваться для управления оператором switch. Конечно, все операторы case должны указывать на константы из того же перечисления, что и оператор switch. Например, указанный ниже оператор switch вполне допустим:

```html
switch(ap) {
    case Jonathan:
        System.out.println("ap = Jonathan");
        break;
    case GoldenDel:
        System.out.println("ap = GoldenDel");
        break;
    // ...
    default:
        System.out.println("ар не является допустимым значением");
        break;
}
```

Обратите внимание, что в операторах case имена констант перечислений используются без указания имени типа перечисления, например Winesap, а не Apple.Winesap. Тип перечисления в операторе switch уже неявно определяет тип перечисления констант в case, поэтому нет необходимости указывать константы в операторах case с помощью имени типа перечисления. Фактически, попытка сделать это вызовет ошибку на стадии компиляции. При отображении константы перечисления, например в операторе println(), выводится ее имя. В результате выполнения следующего оператора будет отображено имя Winesap:

```html
System.out.println(ap);
```

[Chapter12/Package01/EnumDemo - Пример, Перечисление сортов яблок](https://github.com/Vladlena2/BookJava/blob/main/Chapter12/Package01/EnumDemo.java "Посмотреть пример Java")

<details><summary>Методы values() и valueOf()</summary>

Метод values() возвращает массив, содержащий перечисление констант. Метод valueOf() возвращает константу перечисления, значение которой соответствует строке str. В обоих случаях в enum-type указывается тип данного перечисления. Например, для представленного ранее перечисления Apple возвращаемым значением Apple.valueOf("Winesap") будет Winesap.

[Chapter12/Package01/EnumDemo2 - Пример, встроенных в перечисление методов](https://github.com/Vladlena2/BookJava/blob/main/Chapter12/Package01/EnumDemo2.java "Посмотреть пример Java")

Обратите внимание, что для обхода массива констант, полученного вызовом values(), в программе используется “foreach”-стиль цикла for. В качестве примера была создана переменная allApples, которой присваивается ссылка на массив перечислений. Однако в этом нет необходимости, поскольку цикл for можно было бы записать, как показано ниже, без потребности в переменной allApples:

```html
for (Apple apple : Apple.values()) {
  System.out.printf("%s: %d%n", apple, apple.ordinal());
}
```

</details>

<details><summary>Перечисления Java являются типами классов</summary>

Как уже упоминалось, перечисления в Java относятся к типу класса. Несмотря на то, что вы не создаете экземпляр перечисления через new, в целом оно обладает теми же возможностями, что и другие классы. Факт того, что enum определяет класс, дает перечислению необычайную мощь в Java. Например, можно предоставить ему конструкторы, добавлять переменные экземпляра и методы и даже реализовывать интерфейсы. Важно понимать, что каждая константа в перечислении является объектом своего типа. Помимо этого, каждая константа имеет свою собственную копию любых
переменных экземпляра, определенных в перечислении.

[Chapter12/Package02/EnumDemo3 - Использовать конструктор, переменную экземпляра и метод в перечислении](https://github.com/Vladlena2/BookJava/blob/main/Chapter12/Package02/EnumDemo3.java "Посмотреть пример Java")

Когда переменная ap объявляется в main(), конструктор Apple вызывается по разу для каждой указанной константы. Заметьте, как аргументы конструктора указываются путем помещения их в круглые скобки после каждой константы:

```html
 Jonathan(10), GoldenDel(9), RedDel(12), Winesap(15), Cortland(8);
```

Эти значения передаются в параметр р конструктора Apple(), который затем присваивает их переменной экземпляра price. Опять же, конструктор вызывается один раз для каждой константы.

Цены яблок всех сортов получаются путем прохода по перечислению с использованием цикла for. Ввиду того, что для каждой константы перечисления существует копия price, значение, связанное с одной константой, будет отдельным от значения, связанного с другой константой. Это мощная концепция, которая доступна только тогда, когда перечисления реализованы в виде классов, как сделано в Java. 
Хотя в предыдущем примере содержится только один конструктор, перечисление может предлагать две или более перегруженных формы, как и любой другой класс. Например, в приведенной ниже версии перечисления Apple дополнительно предоставляется конструктор по умолчанию, инициализирующий цену значением -1, которое означает, что цена не указана.

```html
// Использовать конструкторы в перечислении
enum Apple {
   // цена яблока каждого сорта
   Jonathan(10), GoldenDel(9), RedDel, Winesap(15), Cortland(8);

   // Переменная экземпляра price, служит для хранения цены
   private int price;

    // Конструктор
    Apple(int p) {
        price = p;
    }

   // Перегружаемый конструктор
   Apple() {
       price = -1;
   }   

    // Метод getPrice(), возвращающий значение цены
    int getPrice() {
        return price;
    }
}
```

**На перечисления накладываются два ограничения:** их нельзя наследовать от других классов и они не могут быть суперклассами — другими словами, их нельзя расширять. Во всем остальном они ведут себя как любые другие классы. Главное — помнить, что каждая их констант является объектом в том классе, в котором она определена.

</details>

<details><summary>Перечисления унаследованы от Enum</summary>

Несмотря на то что при объявлении перечисления невозможно наследовать его от суперкласса, все перечисления автоматически наследуются от класса java.lang.Enum. В этом классе определено несколько доступных для использования методов всеми перечислениями.

Вы можете получить значение, указывающее позицию константы перечисления в списке всех констант. Это значение называется порядковым номером и получается вызовом метода ordinal().
В Java метод ordinal() возвращает порядковый номер указанной константы перечисления.
Этот метод определен в интерфейсе java.lang.Enum и применяется ко всем перечислениям.
В нашем примере мы используем метод ordinal(), чтобы получить числовые значения констант
перечисления Apple. Константам Jonathan, GoldenDel,…,Cortland соответствуют числа 0, 1, …, 4.

Метод ordinal() возвращает порядковый номер той константы, на которой он вызван. Порядковые номера начинаются с нуля, таким образом, в перечислении Apple константа Jonathan имеет порядковый номер 0, константа GoldenDel — порядковый номер 1, константа RedDel — порядковый номер 2 и так далее.

Вы можете сравнивать порядковые номера двух констант из одного и того же перечисления, используя метод compareTo().

Константы перечисления можно сравнить на равенство с любым другим объектом с помощью метода equals(), который переопределяет метод equals(), определенный в Object. Несмотря на то, что метод equals() может сравнивать константу перечисления с любым другим объектом, эти два объекта будут равны только если они оба указывают на одну и ту же константу внутри одного и того же перечисления. Просто наличие одинаковых порядковых номеров не приводит к тому, что equals() вернет true, если две константы находятся в разных перечислениях.

Кроме того, помните о возможности сравнения двух ссылок на перечисления на равенство с использованием операции ==.

[Chapter12/Package03/EnumDemo4 - Продемонстрировать применение методов ordinal(), compareTo() и equals()](https://github.com/Vladlena2/BookJava/blob/main/Chapter12/Package03/EnumDemo4.java "Посмотреть пример Java")

В главе 9 рассматривался пример программы для автоматического принятия решений.
[Chapter09/VariablesInInterfaces/AskМe - Реализация автоматизированной системы "принятия решений"](https://github.com/Vladlena2/BookJava/blob/main/Chapter9/VariablesInInterfaces/AskМe.java "Посмотреть пример Java")

В той ее версии переменные NO, YES, МАУВЕ, LATER, SOON и NEVER объявлялись в интерфейсе и использовались для представления возможных ответов. Хотя в этом нет ничего формально неверного, в данном случае лучше подходит перечисление. Пример усовершенствованной версии программы принятия решений из Главы 9. В этой версии для представления возможных ответов используется перечисление, а не переменные экземпляра.

[Chapter12/Package04/AskМe - Усовершенствованная версия программы принятия решений](https://github.com/Vladlena2/BookJava/blob/main/Chapter12/Package04/AskМe.java "Посмотреть пример Java")

</details>

</details>

<details><summary>Автоупаковка</summary>

Это процесс, в результате которого примитивный тип автоматически инкапсулируется (упаковывается) в эквивалентную ему оболочку типа всякий раз, когда требуется объект данного типа. Благодаря этому отпадает необходимость в явном создании объекта.
Автораспаковка - это процесс автоматического извлечения значения упакованного объекта (распаковки) из оболочки типа, когда нужно получить его значение. Благодаря этому отпадает необходимость вызывать методы вроде intValue() или doubleValue().

С появлением автоупаковки отпадает необходимость в ручном создании объектов для заключения примитивных типов в оболочку. Для этого достаточно присвоить значение примитивного типа переменной ссылки на объект оболочки данного типа, а сам объект будет создан средствами Java автоматически.

Версия программы из предыдущего примера, переделанная с целью продемонстрировать автоупаковку и автораспаковку.

```html
class AutoBox {
   public static void main(String[] args){
       Integer iOb = 100; // автоупаковка значения типа int
       int i = iOb;       // автораспаковка значения типа int
       System.out.println(i + " " + iOb); // выводит значения 100 и 100
   }
}
```

<details><summary>Автоупаковка и методы</summary>

Помимо простых случаев присваивания, автоупаковка происходит автоматически всякий раз, когда примитивный тип должен быть преобразован в объект. Автораспаковка происходит всякий раз, когда объект должен быть преобразован в примитивный тип. Таким образом, автоупаковка и автораспаковка может произ водиться, когда аргумент передается методу или значение возвращается из метода.

[Chapter12/Package05/AutoBox - Автоупаковка/автораспаковка происходит при передаче параметров и возврате значений из методов](https://github.com/Vladlena2/BookJava/blob/main/Chapter12/Package05/AutoBox.java "Посмотреть пример Java")

</details>

<details><summary>Автоупаковка и автораспаковка в выражениях</summary>

Автоупаковка и автораспаковка производится всякий раз, когда требуется взаимное преобразование значения примитивного типа и объекта оболочки этого типа. Это, как правило, происходит в выражениях, где автоматически распаковывается объект оболочки числового типа. Результат вычисления такого выражения снова упаковывается по мере надобности.

[Chapter12/Package05/AutoBox2 - Автоупаковка/автораспаковка происходит в выражениях](https://github.com/Vladlena2/BookJava/blob/main/Chapter12/Package05/AutoBox2.java "Посмотреть пример Java")

Автоматическая распаковка позволяет также сочетать числовые объекты разных типов в одном выражении. Как только числовое значение будет распаковано, вступают в действие стандартные правила продвижения и преобразования типов данных. Например, следующая программа написана совершенно верно:

```html
class AutoBox {
   public static void main(String[] args) {
       Integer iOb = 100;
       Double dOb = 98.6; // примитивный тип
       dOb = dOb + iOb;
       System.out.println(dOb);
   }
}
```

Оба объекта (из переменных dОb типа Double и iOb типа Integer) участвуют в операции сложения, а результат повторно упаковывается и сохраняется в объекте dOb.

Благодаря автоупаковке и автораспаковке применение числовых объектов в выражениях становится интуитивно понятным и значительно упрощается. Прежде для написания подобного кода приходилось выполнять приведение типов и вызывать методы вроде intValue().

</details>

<details><summary>Автоупаковка и распаковка значений из классов Boolean и Character</summary>

C появлением автоупаковки и распаковки появилась возможность применять объекты типа Boolean для управления условным оператором if.
Объект типа Boolean автоматически распаковывается, когда он употребляется в условном операторе if.

[Chapter12/Package05/AutoBox3 - Автоупаковка/распаковка значений из классов Boolean и Character](https://github.com/Vladlena2/BookJava/blob/main/Chapter12/Package05/AutoBox3.java "Посмотреть пример Java")

</details>

<details><summary>Автоупаковка и автораспаковка помогает предотвратить ошибки</summary>

Эта программа выводит не предполагаемое значение 1ООО, а - 24. Дело в том, что значение в оболочке объекта iOb распаковывается вручную при вызове метода byteVal(), что приводит к усечению значения 1000, хранящегося в этом объекте. В итоге получилось неверное значение - 24, которое было присвоено переменной i. Автораспаковка предотвращает подобные ошибки, поскольку значение из объекта iOb всегда будет автоматически распаковываться в значение, совместимое с типом int.

```html
// Ошибка, порождаемая ручной распаковкой
class UnboxingError {
   public static void main(String[] args) {
       Integer iOb = 1000; // автоупаковка значения 1000
       int i = iOb.byteValue(); // ручная распаковка значения, как относящегося к типу byte !!!
       System.out.println(i); // значение 1000 не выводится!
   }
}
```

</details>

<details><summary>Предостережение</summary>

По причине автоупаковки и автораспаковки у некоторых может возникнуть соблазн использовать исключительно такие объекты, как Integer или Double, полностью отказавшись от примитивных типов. Скажем, при автоупаковке/автораспаковке можно написать такой код:

```html
// Неудачное применение автоупаковки/автораспаковки ! 
DouЫe а, b, с; 
а = 10.0; 
Ь = 4.0; 
с = Math.sqrt(а*а + b*b) ; 
System.out.println("Гиnoтeнyзa равна " + с );
```

Дело в том, что каждая автоупаковка и 
автораспаковка добавляют накладные расходы, которые отсутствуют в случае 
использования примитивного типа. 
Вообще говоря, вам следует ограничить применение оболочек типов только теми случаями, когда объектное представление примитивного типа обязательно. Автоупаковка/автораспаковка не добавлялась в Java как "черный ход" для устранения примитивных типов. 

</details>

</details>

<details><summary>Аннотации</summary>

Java предлагает механизм для встраивания дополнительной информации в исходный код программы. Эта информация, называемая аннотациями, не влияет на поведение программы, сохраняя ее семантику неизменной. Однако эта информация может быть использована различными инструментами как в процессе разработки, так и при развертывании программы. Например, аннотация может быть обработана генератором исходного кода. Термин “метаданные” также используется для обозначения этого механизма, но термин “аннотация” является более описательным и распространенным.

<details><summary>Основы аннотаций</summary>

Аннотации предназначены в основном для использования в инструментальных средствах разработки и развертывания прикладных программ на Java.

Аннотации создаются с помощью механизма, основанного на интерфейсе.

```html
// Простой тип аннотации
@interface MyAnno {
   String str();
   int val();
}
```

Объявление аннотации не может включать в себя ключевое слово extends. Но все аннотации автоматически расширяют интерфейс Annotation. Это означает, что Annotation является суперинтерфейсом для всех аннотаций. Он объявлен в пакете java.lang.annotation. В интерфейсе Annotation переопределяются методы hashCode(), equals() и toString(), определенные в классе Object. В нем также объявляется метод annotationType(), возвращающий объект типа Class, представляющий вызывающую аннотацию.

Когда применяется аннотация, ее членам присваиваются соответствующие значения. В качестве примера приведен вариант применения аннотации MyAnno к объявлению метода.

```html
// Аннотирование метода
@MyAnno(str = "Пример аннотации", val = 100)
public static void myMeth() { // ... 
}
```

Эта аннотация связана с методом myMeth(). Обратите особое вниматение на ее синтаксис. Сразу за именем аннотации, которому предшествует знак @, следует список инициализируемых ее членов в скобках. Чтобы установить значение члена аннотации, достаточно присвоить его имени данного члена. Таким образом, в данном примере строка "Пример аннотации" присваивается члену str аннотации MyAnno. Обратите также внимание на то, что в этом присваивании нет никаких скобок после имени члена str. Когда члену аннотации присваивается значение, используется только его имя. В данном контексте члены похожи на поля.

</details>

<details><summary>Указание политики хранения</summary>

Перед тем, как продолжить изучение аннотаций, нужно обсудить политики сохранения аннотаций. Они определяют момент, когда аннотация удаляется. В Java существует три такие политики: SOURCE, CLASS и RUNTIME. Они инкапсулированы в перечислении java.lang.annotation.RetentionPolicy.

- Аннотация с политикой SOURCE доступна только в исходном коде и удаляется на этапе компиляции.
- Аннотация с политикой CLASS сохраняется в файле .class на этапе компиляции и доступна через JVM во время выполнения. Однако, она не будет доступна через JVM.
- Аннотация с политикой RUNTIME сохраняется в файле .class и доступна через JVM на этапе выполнения. Таким образом, RUNTIME предоставляет наибольшую долговечность аннотации.

```html
@Retention(RUNTIME)
@interface MyAnnotation {
String str();
int val();
}
```

Аннотация MyAnnotation будет доступна во время выполнения программы через JVM.

</details>

<details><summary>Получение аннотаций во время выполнения с использованием рефлексии</summary>

Аннотации в основном предназначены для использования другими инструментами разработки или развертывания. Однако, если для аннотаций определена политика сохранения во время выполнения (RUNТIME), тогда их можно запрашивать во время исполнения с использованием любой программы на Java через механизм рефлексии.

Рефлексия - это механизм, позволяющий получать информацию о классе во время выполнения программы. API-интерфейс для рефлексии находится в пакете java.lang.eflect. 

Первый шаг с целью воспользоваться рефлексией состоит в получении объекта типа Class. Этот объект представляет класс, аннотацию которого требуется получить. А Class относится к числу встроенных в Java классов и определен в пакете java.lang .
Метод getClass(), определенный в классе Object возвращает объект типа Class, который представляет вызывающий объект.

```html
final Class<?> getClass() 
```

Обратите внимание на знаки <?>, указанные после имени Class в приведенном выше объявлении метода getClass(). Это обозначение имеет отношение к обобщениям в Java.

Имея в своем распоряжении объект типа Class, можно воспользоваться его методами для получения сведений о различных элементах, объявленных в классе, включая и его аннотацию. Если требуются аннотации, связанные с определенным элементом, объявленным в классе, сначала следует получить объект, представляющий этот элемент.
Например, класс Class предоставляет (среди прочего) методы getMethod(), getField() и getConstructor(), возвращающие сведения о методе, поле и конструкторе соответственно. Эти методы возвращают объекты типа Method, Field и Constructor.

Пример получения аннотаций, связанных с методом. Для этого сначала получается объект типа Class, представляющий класс, затем вызывается метод getMethod() для этого объекта с указанным именем искомого метода. У метода getMethod() имеется следующая общая форма:

```html
Method getMethod(String имя_метода, Class<?> ... типы_параметров)
```

Имя искомого метода передается в качестве аргумента имя_метода. Если этот метод принимает аргументы, то объекты типа Class, представляющие их типы, должны быть также указаны в качестве аргумента типы_параметров. Обратите внимание на то, что аргумент типы_параметров представляет собой список аргументов переменной длины. Это позволяет задать столько типов параметров, сколько требуется, в том числе и не указывать их вообще.
Метод getMethod() возвращает объект типа Method, который представляет метод. Если метод не удается найти, то генерируется исключение типа NoSuchМethodException.

Из объекта типа Class, Method, Field или Constructor можно получить конкретные аннотации, связанные с этим объектом, вызвав метод getAnnotation(). Его общая форма приведена ниже.

```html
<А extends Annotation> getAnnotation(Class<A> тип_аннотации)
```

Здесь параметр тип_аннотации обозначает объект типа Class, представляющий требующуюся аннотацию. Этот метод возвращает ссылку на аннотацию. Используя эту ссылку, можно получить значения, связанные с членами аннотации. Метод getAnnotation() возвращает пустое значение null, если аннотация не найдена. В этом случае у искомой аннотации отсутствует аннотация @Retention, устанавливающая правило удержания RUNTIME.
В этом примере рефлексия применяется для вывода аннотации, связанной с конкретным методом.

[Chapter12/Package05/Meta - Пример рефлексии для вывода аннотации, связанной с конкретным методом](https://github.com/Vladlena2/BookJava/blob/main/Chapter12/Package05/Meta.java "Посмотреть пример Java")

**Второй пример применения рефлексии**

В предыдущем примере у метода myMeth() отсутствовали параметры. Иными словами, когда вызывался метод getMethod(), передавалось только имя myMeth искомого метода. Но для того, чтобы получить метод, у которого имеются параметры, следует задать объекты класса, представляющие типы этих параметров, в виде аргументов метода getMethod().

[Chapter12/Package05/Meta2 - Пример немного измененной версии программы из предыдущего примера](https://github.com/Vladlena2/BookJava/blob/main/Chapter12/Package05/Meta2.java "Посмотреть пример Java")

Получение всех аннотаций

Для того чтобы получить сразу все аннотации, имеющие аннотацию @Retentiоп с установленным правилом удержания RUNTIME и связанные с искомым элементом, достаточно вызвать метод getAnnotations() для этого элемента.

```html
Annotation[] getAnnotations() 
```

Метод getAnnotations() возвращает массив аннотаций. Этот метод может быть вызван для объектов типа Class, Method, Constructor и Field. Пример применения рефлексии, демонстрирующий получение всех аннотаций, связанных с классом и методом.

[Chapter12/Package05/Meta3 - Показать все аннотации для класса и метода](https://github.com/Vladlena2/BookJava/blob/main/Chapter12/Package05/Meta3.java "Посмотреть пример Java")

Доп: https://habr.com/ru/companies/otus/articles/764244/

</details>

<details><summary>Использование стандартных значений</summary>

Аннотация @MyAnno, переделанная с учетом значений по умолчанию.

```html
// Объявление типа аннотации, включающее значения по умолчанию
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnno {
   String str() default "Тестирование";
   int val() default 9000;
}
```

В этом объявлении определяются значения по умолчанию "Тестирование" и 9000 для членов str и val аннотации @MyAnno соответственно. Это означает, что значения ни одного из членов аннотации @MyAnno указывать необязательно, когда она применяется. Но любому из них или обоим сразу можно, если требуется, присвоить конкретное значение явным образом. Таким образом, имеются четыре способа применения аннотации @MyAnno:

```html
@MyAnno()                                // значения str и val принимаются по умолчанию
@MyAnno(str = "Некоторая строка")        // значение val - по умолчанию
@MyAnno(val = 100)                       // значение str - по умолчанию
@MyAnno(str = "Тестирование", val = 100) // значения не по умолчанию
```

В следующем примере программы демонстрируется использование значений членов аннотации по умолчанию:

[Chapter12/Package05/Meta4 - Объявление типа аннотации, включая значения ее членов по умолчанию](https://github.com/Vladlena2/BookJava/blob/main/Chapter12/Package05/Meta4.java "Посмотреть пример Java")

</details>

<details><summary>Маркерные аннотации</summary>

Это специальный вид аннотаций, которые не содержат членов. Единственное назначение маркерных аннотаций - пометить объявление, для чего достаточно наличия такого маркера, как аннотации. Лучший способ выяснить, присутствует ли в прикладном коде маркерная аннотация, вызвать метод isAnnotationPresent(), определенный в интерфейсе AnnotatedElement.

[Chapter12/Package05/Marker - Маркерная аннотация](https://github.com/Vladlena2/BookJava/blob/main/Chapter12/Package05/Marker.java "Посмотреть пример Java")

</details>

<details><summary>Одноэлементные аннотации</summary>

Одноэлементная аннотация состоит из одного члена. Она функционирует как обычная аннотация, за исключением того, что предоставляет сокращенную форму для указания значения этого члена. Если в аннотации присутствует только один член, то при использовании этой аннотации можно просто указать значение этого члена, не указывая его имя - при условии, что имя члена является “value”.

[Chapter12/Package05/Single - Одночленная аннотация](https://github.com/Vladlena2/BookJava/blob/main/Chapter12/Package05/Single.java "Посмотреть пример Java")

Обратите внимание, что указание value= не является обязательным. Синтаксис с одним элементом можно использовать при использовании аннотации, которая содержит другие элементы, но все эти другие элементы должны иметь стандартные значения. Например, следующий фрагмент кода добавляет элемент xyz со стандартным значением 0:

```html
@interface SomeAnno {
int value {};
int xyz {} default 0;
}
```

В ситуациях, где для xyz требуется использовать стандартное значение, можно использовать @SomeAnno, указав только значение value в синтаксисе одного элемента:

```html
@SomeAnno(88)
```

В этом случае стандартное значение xyz будет 0, а значение value будет 88. Конечно, если требуется задать другое значение для xyz, оба элемента должны быть явно указаны:

```html
@SomeAnno{value = 88, xyz=99}
```

Помните, что при использовании одноэлементной аннотации именем элемента всегда должно быть value

</details>

<details><summary>Stream API</summary>

В языке Java определено немало встроенных аннотаций. Большинство встроенных аннотаций имеют специальное назначение, но девять из них - общее назначение. Следующие четыре аннотации из этих девяти импортируются из пакета * jаvа.lang.annotation: @Retention, @Docurnented, @Target и @Inherited*. А еще пять аннотаций - @Override, @Deprecated, @Functionallnterface, @SafeVarargs и @SuppressWarnings - входят в состав пакета java.lang.

**Аннотация @Retention**

Предназначена для применения только в качестве аннотации к другим аннотациям. Она определяет правило удержания, как пояснялось ранее.

**Аннотация @Documented**

Служит маркерным интерфейсом, сообщающим инструментальному средству разработки, что аннотация должна быть документирована. Она предназначена для применения только в качестве аннотации к объявлению другой аннотации.

**Аннотация @Target**

Задает типы элементов, к которым можно применять аннотацию. Она предназначена для применения только в качестве аннотации к другим аннотациям. Аннотация @Target принимает один аргумент, который должен быть константой из перечисления ElementType. Этот аргумент задает типы объявляемых элементов, к которым можно применять аннотацию.

|Целевая константа|Объявляемый элемент, к которому можно применять аннотацию|  
|:----------------|:--------------------------------------------------------|  
|ANNOTATION_ТYPE|Другая аннотация|  
|CONSTRUCTOR|Конструктор|  
|FIELD|Поле|  
|LOCAL_VARIAВLE|Локальная переменная|  
|МЕТНОD|Метод|  
|РАСКАGЕ|Пакет|  
|PARAМETER|Параметр|  
|ТУРЕ|Класс, интерфейс или перечисление|  
|ТУРЕ_РАRАМЕТЕR|Параметр типа (добавлено в версии JDK 8)|  
|ТYPE_USE|Использование типа (добавлено в версии JDK 8)|

В аннотации @Target можно задать одно или несколько значений этих констант. Чтобы задать несколько значений, их следует указать списком, заключив в фигурные скобки. Например, чтобы указать, что аннотация применяется только к полям и локальным переменным, достаточно определить следующую аннотацию @Target:

```html
@Target({ ElementТype.FIELD, ElementТype.LOCAL_VARIABLE })
```

В отсутствие обозначения @Target аннотацию можно применять к любому объявляемому элементу, за исключением параметров типов. Именно поэтому зачастую лучше указывать целевые константы явным образом, чтобы ясно обозначить назначение аннотации.

**Аннотация @Inherited**

Это маркерная аннотация, которую можно применять только в другом объявлении аннотации. Более того, она оказывает воздействие только на те аннотации, которые будут применяться в объявлениях классов. Аннотация @Inherited обусловливает наследование аннотации из суперкласса в подклассе. Так, если конкретная аннотация запрашивается в подклассе, то в отсутствие этой аннотации в подклассе проверяется ее присутствие в суперклассе. Если запрашиваемая аннотация присутствует в суперклассе и аннотирована как @Inherited, то она будет возвращена по запросу.

**Аннотация @Оvеrridе**

Это маркерная аннотация, которую можно применять только в методах. Метод, аннотированный как @Override, должен переопределять метод из суперкласса. Если он этого не сделает, во время компиляции возникнет ошибка. Эта аннотация служит для гарантии того, что метод из суперкласса будет действительно переопределен, а не просто перегружен.

**Аннотация @Deprecated**

Эта маркерная аннотация обозначает, что объявление устарело и должно быть заменено более новой формой. Начиная с версии JDK 9, аннотация @Deprecated позволяет также указать версию Java, с которой аннотируемый элемент считается не рекомендованным к употреблению и подлежит удалению.

**Аннотация @FunctionalInterface**

Эта маркерная аннотация предназначена для применения в интерфейсах. Она обозначает, что аннотируемый интерфейс является функциональным, т.е. содержит один и только один абстрактный метод. Функциональные интерфейсы применяются в лямбда-выражениях. Если же аннотируемый интерфейс не является функциональным, то во время компиляции возникает ошибка. Следует, однако, иметь в виду, что для создания функционального интерфейса аннотация @FunctionalInterfасе не требуется. Следовательно, эта аннотация носит исключительно информативный характер.

**Аннотация @SafeVarargs**

Это маркерная аннотация применяется в методах и конструкторах. Она указывает на отсутствие каких-нибудь небезопасных действий, связанных с параметром переменной длины. Эта аннотация служит для подавления непроверяемых предупреждений, возникающих в коде, который в остальном является безопасным, в связи с применением неовеществляемых типов аргументов переменной длины и получением экземпляра параметризированного массива. (Неовеществляемый тип - это, по существу, обобщенный тип). Эту аннотацию следует применять только к методам или конструкторам с переменным количеством аргументов, объявляемым как static или final.

**Аннотация @SuppressWarnings**

Эта аннотация обозначает, что следует подавить одно или несколько предупреждений, которые могут быть выданы компилятором. Подавляемые предупреждения указываются по имени в строковой форме.

</details>

<details><summary>Аннотации типов</summary>

В версии JDK 8 расширены места, в которых могут применяться аннотации. Раньше аннотации допускались только в объявлениях, как было показано в предыдущих примерах. Но с выпуском версии JDK 8 появилась возможность указывать аннотации везде, где применяются типы данных. Такая расширенная возможность применения аннотаций называется типовой аннотац,ией. Например, аннотировать можно тип, возвращаемый методом, тип объекта по ссылке this в теле метода, приведение типов, уровни доступа к массиву, наследуемый класс, оператор throws, а также обобщенные типы, включая границы параметров и аргументы обобщенного типа.

Типовые аннотации важны потому, что они позволяют выполнять дополнительные проверки прикладного кода различными инструментальными средствами на стадии разработки, чтобы предотвратить ошибки. Следует, однако, иметь в виду, что эти проверки, как правило, не производятся компилятором по команде j avac. Для этой цели служит отдельное инструментальное средство, хотя оно и могло бы действовать в качестве модуля, подключаемого к компилятору. В типовую компиляцию должна быть включена целевая константа ElementType. TYPE_USE. (Как пояснялось ранее, достоверные целевые константы аннотаций указываются с помощью аннотации @Target.) Типовая аннотация применяется к тому типу данных, которому она предшествует. Так, если обозначить типовую аннотацию как @TypeAnno, то приведенная ниже строка кода считается вполне допустимой. В этой строке кода аннотация @TypeAnno аннотирует исключение типа NullPointerException в операторе throws:


```html
void myMeth() throws @ТypeAnno NullPointerException { // ...  }
```

Аннотировать можно также тип объекта по ссылке this (так называемого получателя). Как вам должно быть уже известно, ссылка this является неявным аргументом во всех методах экземпляра и делается на вызывающий объект. Для аннотирования такого типа данных требуется еще одна новая возможность, появившаяся в версии JDK 8. Теперь ссылку this можно явным образом объявлять в качестве первого параметра метода. В этом объявлении тип объекта по ссылке this должен соответствовать типу его класса, как показано в приведенном ниже примере.

```html
void myMeth() throws @ТypeAnno NullPointerException { // ...  }
```

В данном примере типом объекта по ссылке this является класс SomeClass, поскольку метод myMeth() определен в этом классе. С помощью такого объявления теперь можно аннотировать тип объекта по ссылке thi s. Так, если снова обозначить типовую аннотацию как @TypeAnno, то приведенная ниже строка кода считается вполне допустимой.

```html
int myMeth(@ТypeAnno SomeClass this, int i, int j) { // ... }
```

Но если объект по ссылке this не аннотируется, то объявлять его совсем не обязательно. Ведь если объект по ссылке this не объявляется, он все равно передается неявным образом. Кроме того, явное объявление объекта по ссылке this никоим образом не меняет сигнатуру метода, поскольку такое объявление все равно делается неявно по умолчанию. Опять же объект следует объявлять по ссылке this лишь в том случае, если к нему требуется применить аннотацию. И в этом случае ссылка this должна быть указана в качестве первого параметра метода.

```html
// Продемонстрировать применение нескольких типовых аннотаций
import java.lang.annotation.*;
import java.lang.reflect.*;

// Аннотация-маркер, которую можно применить к типу данных
@Target(ElementType.TYPE_USE)
@interface TypeAnno{ }

// Еще одна аннотация-маркер, которую можно применить к типу данных
@Target(ElementType.TYPE_USE)
@interface NotZeroLen { }

// Следующая аннотация-маркер, которую можно применить к типу данных
@Target(ElementType.TYPE_USE)
@interface Unique { }

// Параметризированная аннотация, которую можно применить к типу данных
@Target(ElementType.TYPE_USE)
@interface MaxLen {
   int value();
}

// Аннотация, которую можно применить к параметру типа
@Target(ElementType.TYPE_PARAMETER)
@interface What {
   String description();
}

// Аннотация, которую можно применить в объявлении поля
@Target(ElementType.FIELD)
@interface EmptyOK { }

// Аннотация, которую можно применить в объявлении метода
@Target(ElementType.METHOD)
@interface Recommended { }

// применить аннотацию в параметре типа
class ТypeAnnoDemo<>@What(description = "Данные обобщенного типа") T> {
  // применить типовую аннотацию в конструкторе
  //public void TypeAnnoDemo() { }
  public >@Unique TypeAnnoDemo() { }
  // аннотировать тип (в данном случае - String), но не поле
  @TypeAnno String str;

// аннотировать тест поля
@EmptyOK String test;

// применить типовую аннотацию для аннотирования ссылки this на объект (получатель)
public int f(>@TypeAnno TypeAnnoDemo<T> this, int x) {
   return 10;
}

// аннотировать возвращаемый тип
public >@TypeAnno Integer f2(int j, int k) {
   return j + k;
}

// аннотировать объявление метода
public >@Recommended Integer f3(String str) {
   return str.length() / 2;
}

// применить типовую аннотацию в операторе throws
public void f4() throws >@TypeAnno NullPointerException{
// ...
}

// аннотировать уровни доступа к массиву
String >@MaxLen(10) [] >@NotZeroLen [] w;

// аннотировать тип элемента массива
@TypeAnno Integer[] vec;

public static void myMeth(int i) {
// применить типовую аннотацию в аргументе типа
   TypeAnnoDemo<>@TypeAnno Integer> ob = new TypeAnnoDemo<>@TypeAnno Integer>();

// применить типовую аннотацию в операторе new
@Unique TypeAnnoDemo<Integer> ob2 = new TypeAnnoDemo<Integer>();
   Object x = new Integer(10);
   Integer y;

// применить типовую аннотацию в приведении типов
   y = (>@TypeAnno Integer) x;
}

public static void main(String[] args) {
  myMeth(10);
}

// применить типовую аннотацию в выражении наследования
class SomeClass extends >@TypeAnno TypeAnnoDemo<Boolean> { }
}
```

Теперь обратите внимание на аннотирование this (получателя): 

```html
public int f(@TypeAnno TypeAnnoDemo<T> this, int x) { 
```

Здесь this указывается в качестве первого параметра и имеет тип TypeAnnoDemo (класс, членом которого является метод f()). Как объяснялось ранее, в объявлении метода экземпляра, можно явно указать параметр this, чтобы применить к нему аннотацию типа.

И наконец, посмотрите на аннотировавшие массивы разных уровней:

```html
String @MaxLen(10)[] @NotZeroLen[] w; 
```

В этом объявлении, @MaxLen аннотирует первый уровень, а @NotZeroLen - второй. В следующем объявлении, аннотируется тип элементов Integer:

```html
@TypeAnno Integer[] vec;
```

</details>

<details><summary>Повторяющиеся аннотации</summary>

Начиная с версии JDK 8 аннотации можно повторять в одном и том же элементе. Такие аннотации называются повторяющимися . Чтобы сделать аннотацию повторяющейся, ее следует снабдить аннотацией @Repeatable, определенной в пакете java.lang.annotation. В ее поле value указывается тип контейнера для повторяющейся аннотации. Такой контейнер указывается в виде аннотации, для которой поле val ue является массивом типа повторяющейся аннотации. Следовательно, чтобы сделать аннотацию повторяющейся, необходимо создать сначала контейнерную аннотацию, а затем указать ее тип в качестве аргумента аннотации @Repeatable.

Для доступа к повторяющимся аннотациями с помощью такого метода, как, например, getAnnotation(), следует воспользоваться контейнерной, а не самой повторяющейся аннотацией. Именно такой подход и демонстрируется в приведенном ниже примере программы. В этой программе представленная ранее версия аннотации МуAnno преобразуется в повторяющуюся аннотацию, а затем демонстрируется ее применение.

[Chapter12/Package06/RepeatAnno - Продемонстрировать применение повторяющейся аннотации](https://github.com/Vladlena2/BookJava/blob/main/Chapter12/Package06/RepeatAnno.java "Посмотреть пример Java")

</details>

</details>

</blockquote>
</details>

<details ГЛАВА 13><summary>ГЛАВА 13. "Ввод-вывод, оператор try с ресурсами и др."</summary>
<blockquote>

<details><summary>Ввод-вывод</summary>

Поддержка ввода-вывода обеспечивается основными библиотеками Java API, а не системными библиотеками языка.

<details><summary>Потоки данных</summary>

Ввод и вывод данных в Java-программах осуществляется через потоки данных. Поток данных - это абстракция, которая может производить или потреблять информацию. Поток связывается с физическим устройством посредством системы ввода-вывода Java. Классы и методы ввода-вывода можно применять к различным типам устройств, таким как дисковые файлы, клавиатура или сетевые соединения. Это позволяет абстрагироваться от множества различных видов ввода. Вывод данных может осуществляться на консоль, в дисковый файл или по сетевому соединению. Потоки данных в Java реализованы в иерархиях классов, определенных в пакете java.io.

Java также предоставляет ввод-вывод на основе буферов и каналов, которые определены в пакете java.nio и его подпакетах.

</details>

<details><summary>Потоки байтовых и символьных данных</summary>

В Java существуют два типа потоков ввода/вывода: байтовые и символьные. Байтовые потоки удобны для обработки ввода и вывода байтовых данных, например при чтении или записи двоичных данных. Символьные потоки используют Unicode и позволяют обрабатывать ввод и вывод символов, обеспечивая поддержку интернационализации. В некоторых случаях символьные потоки более эффективны, чем байтовые.

На самом низком уровне операции ввода-вывода по-прежнему выполняются с байтами. Символьные потоки предоставляют удобный и эффективный способ работы со символами в кодировке Unicode.
  
</details>

<details><summary>Классы потоков байтовых данных</summary>

**Классы потоков ввода-вывода байтов из пакета java.io**

Потоки ввода-вывода байтов определены в двух иерархиях классов. На вершине этих иерархий находятся _абстрактные классы InputStream и OutputStream_. У каждого из этих абстрактных классов имеется несколько конкретных подклассов, в которых учитываются отличия разных устройств, в том числе файлов на диске, сетевых соединений и даже буферов памяти.

```html
BufferedInputStream    Буферизованный поток ввода  
BufferedOutputStream   Буферизованный поток вывода  
ByteArrayinputStream   Поток ввода, читающий байты из массива  
ByteArrayOutputStream  Поток вывода, записывающий байты в массив  
DataInputStream        Поток ввода, содержащий методы для чтения данных стандартных типов, определенных в Java  
DataOutputStream       Поток вывода, содержащий методы для записи данных стандартных типов, определенных в Java  
FileInputStream        Поток ввода, читающий данные из файла  
FileOutputStream       Поток вывода, записывающий данные в файл  
FilterInputStream      Реализует абстрактный класс InputStream  
FilterOutputStream     Реализует абстрактный класс OutputStream  
InputStream            Абстрактный класс, описывающий поток ввода  
ObjectInputStream      Поток ввода объектов  
ObjectOutputstream     Поток вывода объектов  
OutputStream           Абстрактный класс, описывающий поток вывода  
PipedInputStream       Канал ввода  
PipedOutputstream      Канал вывода  
PrintStream            Поток вывода, содержащий методы print() и println()  
PushbackInputStream    Поток ввода, поддерживающий возврат одного байта обратно в поток ввода  
SequenceInputStream    Поток ввода, состоящий из нескольких потоков ввода, данные из которых читаются по очереди  
```

В абстрактных классах InputStream и OutputStream определяется ряд ключевых методов, реализуемых в других классах потоков ввода-вывода. Наиболее важными среди них являются методы read() и writе(), читающие и записывающие байты данных соответственно. Оба эти метода объявлены как абстрактные в классах InputStream и OutputStream, а в производных классах они переопределяются.

**Классы потоков ввода-вывода символов**

Потоки ввода-вывода символов также определены в двух иерархиях классов. На вершине этих иерархий находятся два * абстрактных* класса - Reader и Writer. Эти абстрактные классы управляют потоками символов в Юникоде. Для каждого из них в Java предусмотрен ряд конкретных подклассов.

```html
BufferedReader         Буферизированный поток ввода символов  
BufferedWriter         Буферизированный поток вывода символов  
CharArrayReader        Поток ввода, читающий символы из массива  
CharArrayWriter        Поток вывода, записывающий символы в массив  
FileReader             Поток ввода, читающий символы из файла  
FileWriter             Поток вывода, записывающий символы в файл  
FilterReader           Фильтрованный поток чтения  
FilterWriter           Фильтрованный поток запис  
InputStreamReader      Поток ввода, преобразующий байты в символы  
LineNumЬerReader       Поток ввода, подсчитывающий строки  
OutputStreamWriter     Поток вывода, преобразующий символы в байты  
PipedReader            Канал ввода  
PipedWriter            Канал вывода  
PrintWriter            Поток вывода, содержащий методы print() и println()  
PushbackReader         Поток ввода, позволяющий возвращать символы обратно в поток ввода  
Reader                 Абстрактный класс, описывающий поток ввода символов  
StringReader           Поток ввода, читающий символы из строки  
StringWriter           Поток вывода, записывающий символы в строку  
Writer                 Абстрактный класс, описывающий поток вывода символов   
```

В абстрактных классах Reader и Writer определяется ряд ключевых методов, реализуемых в других классах потоков ввода-вывода. Наиболее важными среди них являются методы read() и write(), читающие и записывающие байты данных соответственно. Оба эти метода объявлены как абстрактные в классах Reader и Writer, а в производных классах они переопределяются.

</details>

<details><summary>Предопределенные потоки данных</summary>

Класс System содержит несколько методов для получения информации о системе и текущего времени, а также три предопределенных потоковых переменных: in, out и err, которые могут быть использованы в любой части программы без привязки к конкретному экземпляру класса System.

Переменная System.out ссылается на поток стандартного вывода, по умолчанию вывод осуществляется на консоль. System.in ссылается на поток стандартного ввода, по умолчанию принимаемые данные поступают с клавиатуры. System.err ссылается на поток вывода ошибок, также по умолчанию вывод ошибок осуществляется на консоль. Эти потоки могут быть перенаправлены на другие устройства ввода-вывода, поддерживающие совместимые форматы данных.

System.in, System.out и System.err являются потоками байтовых данных типа InputStream, PrintStream и ErrorStream соответственно. Однако они обычно используются для чтения и записи символов в консоль. Вы можете использовать их как основу для более сложных операций ввода-вывода или обернуть их в классы символьных потоков для дополнительной гибкости и контроля.

</details>

<details><summary>Чтение консольного ввода</summary>

История Java и консольный ввод:
   - На заре развития Java единственным способом выполнения консольного ввода было использование потока байтовых данных.
   - В настоящее время символьный поток предпочтительнее из-за удобства интернационализации и сопровождения программы.

Java 17 и изменения:
   - В JDK 17 изменился способ получения объекта InputStreamReader, связанного с System.in.
   - Рекомендуется явно указывать набор символов, ассоциированный с консолью, при создании InputStreamReader. Набор символов определяет способ сопоставления байтов с символами. Обычно, когда набор символов не задан, применяется стандартная кодировка 
JVM.

Использование InputStreamReader и BufferedReader:
   - Для чтения консольного ввода через BufferedReader, рекомендуется использовать конструктор InputStreamReader с явным указанием набора символов, ассоциированного с консолью.
   - Можно использовать метод System.console() для получения объекта Console и его метод charset() для получения набора символов консоли.

Создание BufferedReader с использованием InputStreamReader без явного указания набора символов (до JDK 17):

```html
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class ConsoleInputExample {
    public static void main(String[] args) {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        try {
            System.out.print("Введите ваше имя: ");
            String name = br.readLine();
            System.out.println("Привет, " + name + "!");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

Создание BufferedReader с использованием InputStreamReader с явным указанием набора символов (начиная с JDK 17):
 
```html
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.Charset;

public class ConsoleInputExample {
    public static void main(String[] args) {
        InputStreamReader isr = new InputStreamReader(System.in, Charset.defaultCharset());
        BufferedReader br = new BufferedReader(isr);

        try {
            System.out.print("Введите ваше имя: ");
            String name = br.readLine();
            System.out.println("Привет, " + name + "!");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

Современный подход к чтению консольного ввода в Java включает явное указание набора символов консоли при создании InputStreamReader, что обеспечивает более надежное и удобное взаимодействие с консолью в различных приложениях.

</details>

<details><summary>Чтение символов</summary>

Чтобы получить поток ввода символов, присоединив его к консоли, следует заключить стандартный поток ввода System.in в оболочку объекта класса BufferedReader, поддерживающего буферизованный поток ввода. Ниже приведен чаще всего используемый конструктор этого класса.

```html
BufferedReader(Reader поток_чтения_вводимых_данных)  
```

десь параметр поток_чтения_вводимых_данных обозначает поток, который связывается с создаваемым экземпляром класса BufferedReader. Класс Reader является абстрактным. Одним из производных от него конкретных подклассов является класс InputStreamReader, преобразующий байты в символы. Для получения объекта типа InputStreamReader, связанного со стандартным потоком ввода System.in, служит следующий конструктор:

```html
InputStreamReader(InputStream поток_ввода)   
```

Переменная System.in ссылается на объект класса InputStream и поэтому должна быть указана в качестве параметра поток_ввода. В конечном итоге получается приведенная ниже строка кода, где создается объект типа BufferedReader, связанный с клавиатурой. После выполнения этой строки кода переменная экземпляра br будет содержать поток ввода символов, связанный с консолью через стандартный поток ввода System.in.

```html
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
```

Для чтения символа из потока ввода типа BufferedReader служит метод read(). Ниже приведена общая форма метода read().

```html
int read() throws IOException  
```

Всякий раз, когда метод read() вызывается, он читает символ из потока ввода и возвращает его в виде целочисленного значения. По достижении конца потока возвращается значение -1. Как видите, метод read() может сгенерировать исключение типа IOException.

//путь

Для чтения символьных строк с клавиатуры служит версия метода readLine(), который является членом класса BufferedReader. Его общая форма приведена ниже. Как видите, этот метод возвращает объект типа String.

```html
String readLine() throws IOException    
```

//путь

В следующем далее примере программы демонстрируется простейший текстовый редактор. С этой целью сначала создается массив объектов типа String, а затем читаются текстовые строки, каждая из которых сохраняется в элементе массива. Чтение производится до 100 строк или до тех пор, пока не будет введено слово "стоп". Для чтения данных с консоли применяется класс BufferedReader.

//путь

</details>

<details><summary>Запись данных, выводимых на консоль</summary>

Вывод данных на консоль проще всего организовать с помощью упоминавшихся ранее методов print() и println(). Эти методы определены в классе PrintStream (он является типом объекта, на который ссылается переменная System.out).

Класс PrintStream описывает поток вывода и является производным от класса OutputStream, поэтому в нем реализуется также низкоуровневый метод write(). Следовательно, метод write() можно применять для записи данных, выводимых на консоль. Ниже приведена простейшая форма метода writе(), определенного в классе PrintStream.

```html
void write(int байтовое_значение)     
```

Этот метод записывает байт, передаваемый в качестве параметра байтовое_значение. Несмотря на то что параметр * байтовое_значение* объявлен как целочисленный, записываются только 8 его младших бит. Ниже приведен короткий пример программы, где метод write() применяется для вывода на экран буквы "А" с последующим переводом строки.

```html
// Продемонстрировать применение метода System.out.write()
class WriteDemo {
   public static void main(String[] args){
       int b;
       b = 'A';
       System.out.write(b);
       System.out.print("\n");
   }
}   
```

**Класс PrintWriter**

Применение класса PrintWriter для консольного вывода упрощает интернационализацию прикладных программ. В классе PrintWriter определяется несколько конструкторов. Ниже приведен один из тех конструкторов:

```html
PrintWriter(OutputStream поток_вывода, boolean очистка)   
```

Здесь параметр поток_вывода обозначает объект типа OutputStream, а параметр очистка - очистку потока вывода всякий раз, когда вызывается (среди прочих) метод println(). Если параметр очистка принимает логическое значение true, то очистка потока вывода происходит автоматически, а иначе - вручную.

В классе PrintWriter поддерживаются методы print() и println(). Следовательно, их можно использовать таким же образом, как и в стандартном по токе вывода System.out. Если аргумент этих методов не относится к простому типу, то для объекта типа PrintWriter сначала вызывается метод toString(), а затем выводится результат.

Чтобы вывести данные на консоль, используя класс PrintWriter, следует указать стандартный поток System.out для вывода и его автоматическую очистку. Например, в следующей строке кода создается объект типа PrintWriter, который связывается с консольным выводом:

```html
PrintWriter pw = new PrintWriter(System.out, true);
```

//путь
       
</details>

</blockquote>
</details>


<details><summary>Stream API</summary>
<blockquote>

С выходом Java 8 появилась поддержка функционального программирования.
Стало возможным конструировать сложные цепочки операций над потоком данных.

Дабы не путать стримы (Stream) с I/O потоками (InputStream/OutputStream) и тредами/нитями/потоками (Thread), стоит придерживаться англоязычного именования в транслите и называть Stream стримом.

Пакет java.util.stream содержит классы для поддержки операций с потоками элементов в функциональном стиле. Ключевой абстракцией, введенной в этом пакете, является **Поток**.

**Stream API** – по сути это поток данных и последовательные операции над ними, позволяет нам обрабатывать каждый элемент коллекции эффективно и последовательно, подобно конвейеру на фабрике.

Stream API **не предлагает решения для всех возможных сценариев обработки данных.** Однако, большинство задач могут быть описаны следующим общим шаблоном:

- Источник данных.
- Выполнение преобразований.
- Сохранение результата в новую структуру данных.

Если ваша задача не соответствует этому шаблону, то, возможно, использование Stream API не будет оптимальным решением.

### Преимущества

1. Стримы избавляют программистов от написания стереотипного кода всякий раз, когда нужно сделать что-то с набором элементов. То есть благодаря стримам не приходится думать о деталях реализации.
2. Стримы поддерживают один из основных принципов хорошего проектирования — слабую связанность (low coupling). Чем меньше класс знает про другие классы — тем лучше. Алгоритму сортировки не должно быть важно, что конкретно он сортирует. Это и делают стримы.
3. С помощью стримов операции с коллекциями проще распараллелить: в императивном подходе для этого бы понадобился минимум ещё один цикл.
4. Стримы позволяют уменьшить число побочных эффектов: методы Stream API не меняют исходные коллекции.
5. Со Stream API лаконично записываются сложные алгоритмы обработки данных.

### Недостатки

1. Сложность отладки: Использование функциональных интерфейсов и лямбда-выражений может сделать код менее читаемым и усложнить процесс отладки.

2. Производительность: В некоторых случаях использование Stream API может быть менее эффективным с точки зрения производительности по сравнению с традиционным циклом for.

3. Затраты на создание объектов: При использовании Stream API могут создаваться дополнительные объекты, что может повлиять на использование памяти и производительность.

4. Ограниченная поддержка в старых версиях Java: Некоторые старые проекты или системы могут использовать более ранние версии Java, где поддержка Stream API ограничена или отсутствует.

Java Stream API представляет собой последовательность элементов данных, которую можно обрабатывать с использованием различных операций. Внутренне потоки могут использовать буферизацию, ленивые вычисления и другие оптимизации для эффективной обработки данных.

Когда создается поток, он может иметь начальное состояние, например, указатель на первый элемент данных. В процессе выполнения промежуточных и конечных операций, поток может изменять свое внутреннее состояние. Например, операции фильтрации, сортировки или отображения могут изменять порядок элементов или исключать часть из них.

Если бы поток можно было использовать повторно, это могло бы привести к несогласованности или непредсказуемым результатам из-за изменений внутреннего состояния. Создание нового потока для каждой последовательности операций обеспечивает чистоту и предсказуемость обработки данных.

<details><summary>Компоненты Stream API</summary>

Stream API состоит из набора компонентов и концепций, которые работают вместе, чтобы обеспечить потоковую обработку данных.

1. Источник (Source) - откуда приходят данные. Это может быть коллекция, массив, файл, генератор или любой другой источник данных.
2. Операции - преобразовывают и/или обрабатывают данные.
3. Поток (Stream) - последовательность элементов, подлежащих параллельной или последовательной обработке.
4. Пайплайн (Pipeline) - последовательность операций в потоке, применяемых к данным.
5. Терминал (Terminal) - место выхода данных из потока. Терминальная операция означает окончание обработки потока и возвращает результат.

Визульно показано здесь:
https://struchkov.dev/blog/ru/content/images/size/w1000/2023/06/screen-771.png

</details>

<details><summary>Способы создания стримов</summary>

| Способ создания стрима                                   | Шаблон создания                                        |
|----------------------------------------------------------|--------------------------------------------------------|
| Классический: из коллекции                               | collection.stream()                                    | 
|Из значений                                               | Stream.of(значение1,… значениеN)                       |
| Из массива                                               | Arrays.stream(массив)                                  |
| Из файла 
(каждая строка в файле будет отдельным элементом в стриме) | Files.lines(путь_к_файлу)                              |
| Из строки                                                | «строка».chars()                                       | 
| С помощью Stream.builder                                 | Stream.builder().add(...)....build()                   |
| Создание параллельного стрима                            | collection.parallelStream()                            |
| Создание бесконечных стрима с помощью Stream.iterate     | Stream.iterate(начальное_условие, выражение_генерации) |  
| Создание бесконечных стрима с помощью Stream.generate    | Stream.generate(выражение_генерации)                   | 

В принципе, кроме последних двух способов создания стрима, все не отличается от обычных способов создания коллекций. Последние два способа служат для генерации бесконечных стримов, в iterate задается начальное условие и выражение получение следующего значения из предыдущего, то есть Stream.iterate(1, n -> n + 1) будет выдавать значения 1, 2, 3, 4,… N. Stream.generate служит для генерации константных и случайных значений, он просто выдает значения соответствующие выражению, в данном примере, он будет выдавать бесконечное количество значений «a1».

[StreamAPI/BuildTests - Создание различных стримов](https://github.com/Vladlena2/BookJava/blob/main/StreamAPI/BuildTests.java "Посмотреть пример Java")

Важно отметить, что при выполнении Stream исходные данные не изменяются. В результате своей работы Stream создает новую структуру данных.

</details>

Все операции с потоками можно условно разделить на промежуточные и терминальные.

<details><summary>Промежуточные операции</summary>

Также называют конвейерныыми. 

Промежуточные операции в потоках Java описываются декларативно с использованием лямбда-выражений. Эти операции представляют собой своего рода "рецепт" обработки данных.

Однако стоит учесть, что они не выполняются немедленно после объявления. В действительности, все промежуточные операции выполняются только при вызове терминальной операции, которая запускает общую цепочку обработки.

Они возвращают другой stream, то есть работают как builder.

Промежуточные операции не должны хранить какое-либо состояние и не должны вызывать побочных эффектов.

| Метод | Описание | Пример |
|-------|----------|--------|
| filter | Отфильтровывает записи, возвращает только записи, соответствующие условию | collection.stream().filter("a1"::equals).count() |
| skip | Позволяет пропустить N первых элементов | collection.stream().skip(collection.size() - 1).findFirst().orElse("1") |
| distinct | Возвращает стрим без дубликатов (для метода equals) | collection.stream().distinct().collect(Collectors.toList()) |
| map | Преобразует каждый элемент стрима | collection.stream().map((s) -> s + "_1").collect(Collectors.toList()) |
| peek | Возвращает тот же стрим, но применяет функцию к каждому элементу стрима | collection.stream().map(String::toUpperCase).peek((e) -> System.out.print("," + e)).collect(Collectors.toList()) |
| limit | Позволяет ограничить выборку определенным количеством первых элементов | collection.stream().limit(2).collect(Collectors.toList()) |
| sorted | Позволяет сортировать значения либо в натуральном порядке, либо задавая Comparator | collection.stream().sorted().collect(Collectors.toList()) |
| mapToInt, mapToDouble, mapToLong | Аналог map, но возвращает числовой стрим (то есть стрим из числовых примитивов) | collection.stream().mapToInt((s) -> Integer.parseInt(s)).toArray() |
| flatMap, flatMapToInt, flatMapToDouble, flatMapToLong | Похоже на map, но может создавать из одного элемента несколько | collection.stream().flatMap((p) -> Arrays.asList(p.split(",")).stream()).toArray(String[]::new) |

</details>

<details><summary>Терминальные операции</summary>

| Метод       | Описание                                                     | Пример                                              |
|-------------|--------------------------------------------------------------|-----------------------------------------------------|
| findFirst   | Возвращает первый элемент из стрима (возвращает Optional)   | collection.stream().findFirst().orElse("1")        |
| findAny      | Возвращает любой подходящий элемент из стрима (возвращает Optional) | collection.stream().findAny().orElse("1")           |
| collect     | Представление результатов в виде коллекций и других структур данных | collection.stream().filter(s -> s.contains("1")).collect(Collectors.toList()) |
| count       | Возвращает количество элементов в стриме                   | collection.stream().filter("a1"::equals).count()    |
| anyMatch    | Возвращает true, если условие выполняется хотя бы для одного элемента | collection.stream().anyMatch("a1"::equals)          |
| noneMatch   | Возвращает true, если условие не выполняется ни для одного элемента | collection.stream().noneMatch("a8"::equals)         |
| allMatch    | Возвращает true, если условие выполняется для всех элементов | collection.stream().allMatch(s -> s.contains("1")) |
| min         | Возвращает минимальный элемент, в качестве условия использует компаратор | collection.stream().min(String::compareTo).get()    |
| max         | Возвращает максимальный элемент, в качестве условия использует компаратор | collection.stream().max(String::compareTo).get()    |
| forEach     | Применяет функцию к каждому объекту стрима, порядок при параллельном выполнении не гарантируется | set.stream().forEach(p -> p.append("_1"))         |
| forEachOrdered | Применяет функцию к каждому объекту стрима, сохранение порядка элементов гарантирует | list.stream().forEachOrdered(p -> p.append("_new")) |
| toArray     | Возвращает массив значений стрима                         | collection.stream().map(String::toUpperCase).toArray(String[]::new) |
| reduce      | Позволяет выполнять агрегатные функции на всей коллекцией и возвращать один результат | collection.stream().reduce((s1, s2) -> s1 + s2).orElse("0") |


</details>

<details><summary>Доп операции</summary>


Краткое описание дополнительных методов у числовых стримов

| Метод     | Описание                                             | Пример                                                  |
|-----------|------------------------------------------------------|---------------------------------------------------------|
| sum       | Возвращает сумму всех чисел                          | collection.stream().mapToInt(s -> Integer.parseInt(s)).sum() |
| average   | Возвращает среднее арифметическое всех чисел        | collection.stream().mapToInt(s -> Integer.parseInt(s)).average() |
| mapToObj  | Преобразует числовой стрим обратно в объектный       | intStream.mapToObj(id -> new Key(id)).toArray()         |

Несколько других полезных методов стримов

| Метод       | Описание                                                     |
|-------------|--------------------------------------------------------------|
| isParallel  | Узнать, является ли стрим параллельным                       |
| parallel    | Вернуть параллельный стрим, если стрим уже параллельный, то может вернуть самого себя |
| sequential  | Вернуть последовательный стрим, если стрим уже последовательный, то может вернуть самого себя |

С помощью, методов parallel и sequential можно определять какие операции могут быть параллельными, а какие только последовательными. Так же из любого последовательного стрима можно сделать параллельный и наоборот, то есть:

```html
collection.stream().
peek(...). 
parallel().
map(...). 
sequential().
reduce(...) 
```

**Внимание:** крайне не рекомендуется использовать параллельные стримы для сколько-нибудь долгих операций (получение данных из базы, сетевых соединений), так как все параллельные стримы работают c одним пулом fork/join и такие долгие операции могут остановить работу всех параллельных стримов в JVM из-за того отсутствия доступных потоков в пуле, т.е. параллельные стримы стоит использовать лишь для коротких операций, где счет идет на миллисекунды, но не для тех где счет может идти на секунды и минуты.

</details>

Понятное объяснение работы операций:
https://annimon.com/article/2778

Здесь можно посмотреть подробные примеры по различным операциям:
https://spetriuk.github.io/java/Java%20Stream%20API/

</blockquote>
</details>

