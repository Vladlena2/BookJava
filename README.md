<small>
  
## Книга "Java полное руководство - Герберт Шилдт, 12-е издание, 2022г."

<small>

#### Оглавление

<details ГЛАВА 1><summary>ГЛАВА 1. "История и эволюция языка Java"</summary>
<blockquote>
  
<details><summary>Создание языка Java</summary>
  
Главной движущей силой стала потребность в **независимом от платформы** (т.е. архитектурно-нейтральном) языке, который можно было бы использовать для построения программного обеспечении, встраиваемого в разнообразные бытовые электронные устройства, такие как микроволновые печи и пульты дистанционного управления.
Второй движущей силой стала Всемирная паутина (она же веб-сеть) т.к. веб-сеть тоже нуждалась в переносимых программах.
</details>

<details><summary> Апплет в Java</summary>

**Апплет** — это Java-приложение, которое запускается внутри веб-браузера с помощью Java-плагина. Апплеты были популярными в 1990-х и начале 2000-х годов как способ предоставления интерактивных графических приложений на веб-страницах. Они позволяли разработчикам создавать множество интересных веб-приложений, включая игры, графические редакторы и интерактивные диаграммы.

По существу, апплет позволяет переместить определенную функциональность из серверной стороны на клиентскую сторону. Напротив, апплет представляет собой динамическую самостоятельно запускающуюся программу. Такая программа является активным агентом на клиентском компьютере, но инициируется сервером.

Основные характеристики Java апплетов включают: 
- Платформонезависимость: Java апплеты могли выполняться на разных операционных системах и архитектурах благодаря тому, что они компилировались в байт-код Java и выполнялись на виртуальной машине Java (JVM). 
- Безопасность: Апплеты были ограничены в своих возможностях для обеспечения безопасности. Они могли выполняться в песочнице (sandbox), что ограничивало их доступ к ресурсам компьютера.
- Графический интерфейс: Java апплеты могли создавать графический пользовательский интерфейс с использованием библиотеки AWT (Abstract Window Toolkit) или Swing.

Связь Java-кода с браузером осуществлялась с помощью Java апплетов. Вот как это происходило: 
1. Написание Java-кода: Разработчик создавал Java-код, который выполнял определенные задачи и визуализацию интерфейса, если это требовалось.
2. Компиляция в байт-код Java: Java-код затем компилировался в байт-код Java с использованием компилятора Java. Байт-код был независим от конкретной аппаратной платформы.
3. Создание HTML-страницы: Разработчик создавал HTML-страницу, которая включала тег `<applet>`. В этом теге указывалось имя класса Java-апплета и другие параметры, такие как размеры окна, параметры безопасности и т. д. 
   Пример тега `<applet>`:
   ```html
   <applet code="MyApplet.class" width="300" height="200"></applet>
</details>

<details><summary>Магия Java: байт-код</summary>
Компилятор Java генерирует не исполняемый код, а байт-код. Байт-код представляет собой оптимизированный набор инструкций, предназначенных для выполнения так называемой виртуальной машиной Java (Java Virtual Machine - JVM), которая является частью исполняющей среды Java (Java Runtime Environment - JRE).
  
**Java Virtual Machine (JVM)** — это виртуальная машина, которая выполняет байт-код Java, созданный компилятором Java из исходного Java-кода. JVM обеспечивает платформонезависимость Java, позволяя Java-приложениям выполняться на разных операционных системах без изменений в их исходном коде.

Вот как работает JVM: 
1. Компиляция в байт-код: Исходный Java-код компилируется в байт-код Java с помощью Java-компилятора (javac). Байт-код представляет собой набор инструкций, которые являются абстрактными и не зависят от конкретной аппаратной платформы. 
2. Загрузка классов: JVM загружает байт-код Java в память по мере необходимости. Классы могут быть загружены с локального класспаса (classpath) или из удаленных источников, таких как удаленные серверы или интернет.
3. Верификация: перед выполнением классы проходят процесс верификации, в ходе которого проверяется их правильность и безопасность. Это важный этап, который защищает систему от вредоносного кода.
4. Исполнение: когда класс загружен и верифицирован, JVM начинает выполнение байт-кода Java. Виртуальная машина интерпретирует байт-код или может использовать Just-In-Time (JIT) компиляцию для перевода байт-кода в нативный машинный код для конкретной аппаратной платформы, что может улучшить производительность приложения.
5.	Управление памятью: JVM управляет памятью, выделяя и освобождая память для объектов, создаваемых во время выполнения приложения. Это включает в себя управление кучей (heap) для объектов и стеком вызовов (call stack) для управления вызовами методов и локальными переменными.
6.	Сборка мусора: JVM автоматически отслеживает объекты, которые больше не используются, и периодически освобождает память, занимаемую этими объектами, с помощью сборщика мусора (garbage collector).
7.	Управление исключениями: JVM обрабатывает исключения, которые могут возникнуть во время выполнения приложения, и предоставляет механизмы для их обработки и управления.
8.	Многозадачность: JVM обеспечивает поддержку многозадачности, позволяя выполнять несколько потоков (threads) одновременно в рамках одного процесса Java-приложения.
9.	Библиотеки Java: JVM включает в себя стандартные библиотеки Java (Java Standard Library), которые предоставляют множество классов и методов для работы с различными аспектами программирования, такими как работа с файлами, сетевое взаимодействие, графика и многое другое.

**Just-In-Time (JIT) компиляция** — это техника оптимизации выполнения кода виртуальной машины (VM) или интерпретатора, которая используется, чтобы улучшить производительность при выполнении программы. JIT компиляция предназначена для ускорения работы приложения путем преобразования некоторых частей кода, представленного в байт-коде или другом промежуточном формате, в нативный машинный код, который выполняется непосредственно на целевой аппаратной платформе. 
Вот как работает JIT компиляция: 
1.  Интерпретация и компиляция: изначально, при запуске программы, код выполняется в интерпретируемом режиме. Это означает, что инструкции байт-кода (или другого промежуточного кода) интерпретируются виртуальной машиной, что может быть медленным в сравнении с нативным машинным кодом. 
2.	Профилирование кода: во время интерпретации виртуальная машина отслеживает, какие части кода выполняются наиболее часто. Это называется профилированием кода. 
3.	Компиляция в нативный код: когда определенный фрагмент кода выполняется достаточно часто, JIT-компилятор анализирует этот код и транслирует его в нативный машинный код для конкретной аппаратной платформы. Это происходит во время выполнения программы, и только для тех участков кода, которые действительно нуждаются в оптимизации. 
4.	Кеширование: Сгенерированный нативный код кешируется, чтобы он мог быть использован при последующих вызовах того же фрагмента кода без повторной компиляции.

**Нативный машинный код** — это низкоуровневый исполняемый код, который представляет собой инструкции, понятные конкретному процессору или архитектуре компьютера. Этот код является непосредственно понятным и выполняемым процессором, без дополнительной обработки или интерпретации.

**Байт-код** представляет собой абстрактную форму кода, которая является промежуточным уровнем между исходным кодом и нативным машинным кодом. Он не зависит от конкретной аппаратной платформы, так как он представлен в виде набора инструкций и операций, которые понимает виртуальная машина (например, JVM для Java или CLR для C#). Виртуальная машина интерпретирует байт-код или компилирует его в нативный машинный код во время выполнения, адаптируя его под текущую платформу. Таким образом, байт-код обеспечивает переносимость между разными архитектурами и операционными системами.

Как все взаимосвязано:
1.	Байт-код Java: когда вы компилируете исходный Java-код с помощью компилятора Java, он создает байт-код Java. Этот байт-код представляет собой инструкции, которые не зависят от конкретной аппаратной платформы, и это делает его переносимым. 
2.	JVM — это программное обеспечение, которое является частью среды выполнения Java (Java Runtime Environment, JRE). JVM интерпретирует или JIT-компилирует байт-код Java в нативный машинный код, который может выполняться на конкретной аппаратной платформе. Это ключевой момент, который обеспечивает переносимость Java-приложений. 
3.	Изоляция нативного кода: Нативный код, который генерирует JVM, ассоциирован с аппаратной платформой и операционной системой, на которой JVM работает. Однако этот нативный код находится внутри JVM и изолирован от самой Java-программы. Java-приложение взаимодействует с нативным кодом через API, которые предоставляются JVM, и эти API переносимы и абстрагируют код Java от деталей аппаратной платформы. 
4.	Платформонезависимость: поскольку байт-код Java является переносимым и может быть выполнен на любой платформе, на которой установлена совместимая JVM, Java-приложения могут быть написаны один раз и выполняться на разных операционных системах и аппаратных платформах, где существует JVM. Это обеспечивает платформонезависимость Java.

API (Application Programming Interface) — это набор определенных правил и протоколов, которые позволяют разным программным компонентам взаимодействовать друг с другом. API определяет, какие функции и методы доступны для использования внешними приложениями, и как эти приложения могут взаимодействовать с системой, библиотекой, сервисом или операционной системой.
Примерами API могут быть следующие:
- API операционной системы, которое позволяет приложениям управлять файлами, сетевыми соединениями и другими аспектами ОС.
- API социальных сетей, которые позволяют разработчикам создавать приложения, интегрированные с социальными платформами. 
-	API библиотеки, предоставляющей математические функции для приложения. 
-	API веб-сервисов, позволяющие приложениям обмениваться данными через интернет.

Взаимодействие Java-приложения с нативным кодом происходит через Java Native Interface (JNI), который представляет собой API, предоставляющее возможность вызывать функции, написанные на нативных языках (как правило, на C или C++), из Java-приложения. Это позволяет Java-приложениям использовать библиотеки и функциональность, которая не доступна непосредственно на языке Java.

</details>

<details><summary>Сервлеты: Java на серверный стороне</summary>

  **Сервлеты** представляют собой Java-классы, которые используются для разработки динамических веб-приложений на платформе Java. Они работают на серверной стороне и предназначены для обработки HTTP-запросов и генерации HTTP-ответов. Сервлеты широко используются в веб-приложениях для создания веб-страниц, взаимодействия с базами данных, обработки форм, аутентификации и других веб-связанных задач. 

  Вот основные характеристики сервлетов: 
  1. 	Java-классы: Сервлеты представляют собой обычные классы на языке Java, которые расширяют классы или реализуют интерфейсы из Java Servlet API. Обычно, для создания сервлета, нужно создать Java-класс и переопределить методы, такие как doGet() или doPost(), для обработки HTTP-запросов. 
  2.	Жизненный цикл: у сервлетов есть жизненный цикл, который включает в себя инициализацию, обработку запросов и завершение работы. Сервлет может быть создан один раз и использоваться для обслуживания нескольких запросов, что позволяет сэкономить ресурсы сервера. 
  3.	Обработка HTTP-запросов: Главная задача сервлетов - обработка HTTP-запросов от клиентов (например, браузеров). Они могут анализировать параметры запроса, читать и записывать HTTP-заголовки, работать с сессиями пользователей и так далее. 
  4.	Генерация HTTP-ответов: Сервлеты также генерируют HTTP-ответы, которые включают в себя HTML-страницы, JSON-данные, изображения и другие ресурсы. Ответы отправляются клиентам (браузерам) в форме HTTP-сообщений. 
  5.	Поддержка многопоточности: Сервлеты автоматически поддерживают многопоточность. Они могут одновременно обслуживать несколько запросов от разных клиентов, и каждый запрос выполняется в отдельном потоке. 
  6.	Конфигурация через web.xml или аннотации: Сервлеты могут быть настроены с использованием файлов конфигурации web.xml или с помощью аннотаций (в более современных версиях Java Servlet API). Это позволяет определить URL-пути, по которым сервлеты будут доступны, а также другие параметры.

Сервлеты являются важной частью технологии Java EE (Java Platform, Enterprise Edition) и используются для создания множества веб-приложений, включая корпоративные приложения, интернет-магазины, порталы и другие веб-ресурсы. Они предоставляют программистам мощный инструмент для создания динамических и интерактивных веб-приложений, работающих на сервере Java.
  
</details>

<details><summary>Терминология языка Java</summary>
• простота; • безопасность; • переносимость; • объектная ориентация; • надежность; • многопоточность; • нейтральность к архитектуре; • интерпретируемость; • высокая производительность; • распределенность; • динамичность.

_Надежность._
Java – строго типизированный язык.
  
**Строго типизированный язык** (или сильно типизированный язык) — это язык программирования, который строго следует правилам и ограничениям, касающимся типов данных. В строго типизированных языках каждая переменная и выражение имеют строго определенный тип данных, и их использование ограничено в соответствии с этим типом.
  
Чтобы лучше понять, как обеспечивается надежность в Java, рассмотрим две главных причины отказа программ: просчеты в управлении памятью и неправильно обработанные исключительные ситуации (т.е. ошибки времени выполнения).  
Скажем, в С/С++ программист будет часто вручную выделять и освобождать динамическую память. Подход подобного рода иногда приводит к возникновению проблем, потому что программисты будут либо забывать об освобождении ранее выделенной памяти, либо, что хуже, пытаться освободить память, которая все еще задействована в другой части кода. Java практически устраняет указанные проблемы, самостоятельно управляя выделением и освобождением памяти. (На самом деле освобождение выполняется полностью автоматически, поскольку Java обеспечивает сборку мусора для неиспользуемых объектов.)
Условия для исключений в традиционных средах часто возникают в ситуациях вроде деления на ноль или отсутствия нужного файла, и справляться с ними приходится с помощью неуклюжих и трудных для чтения конструкций. Java помогает и этой области, предлагая объектно-ориентированную обработку исключений. В хорошо написанной программе на Java все ошибки времени выполнения могут - и должны - обрабатываться вашей программой.

_Интерпретируемость и высокая производительность._
Байт-код Java был тщательно спроектирован, чтобы легко транслироваться прямо в машинный код для достижения очень высокой производительности с использованием оперативного компилятора.

</details>

</blockquote>
</details>

<details ГЛАВА 2><summary>ГЛАВА 2. "Краткий обзор языка Java"</summary>
<blockquote>
  
<details><summary>Объектно-ориентированное программирование. Две парадигмы</summary>
Все компьютерные программы состоят из двух элементов: **кода и данных**. Кроме того, программа может быть **концептуально организована вокруг своего кода или своих данных**. Иными словами, одни программы пишутся исходя из того, "что происходит”; а другие - исходя из того, "что затронуто”.
  
Существуют две парадигмы, определяющие то, как строится программа:
  1. Модель, ориентированная на процессы – последовательность линейных шагов (т.е. кода), код, воздействующий на данные. При использовании этого подхода начинают возникать проблемы.
  2.	Объектно-ориентированное программирование. Позволяет организовать программу вокруг ее данных (т.е. объектов) и набора четко определенных интерфейсов к таким данным. Это данные, управляющие доступом к коду

**Абстракция** – принцип, который позволяет скрыть детали реализации объекта и выделить только самую важную информацию или функциональность.

Скажем, в состав аудиосистемы может входить радиоприемник, проигрыватель компакт-дисков и/или проигрыватель МРЗ. Суть в том, что вы управляете сложностью автомобиля (или любой другой сложной системы) за счет использования иерархических абстракций.

**Суть ООП:** Последовательность шагов процесса может стать совокупностью сообщений, передаваемых между этими объектами. Таким образом, каждый объект описывает свое уникальное поведение. Вы можете воспринимать такие объекты как конкретные сущности, которые реагируют на сообщения, указывающие им о необходимости делать что-то. 

</details>

<details><summary>Три принципа ООП</summary>
  
## Инкапсуляция 
Инкапсуляция представляет собой механизм, который связывает вместе код и обрабатываемые им данные, а также защищает их от внешнего вмешательства и неправильного использования. Инкапсуляцию можно считать защитной оболочкой, которая предотвращает произвольный доступ к коду и данным из другого кода, определенного вне оболочки. Доступ к коду и данным, находящимся внутри оболочки, строго контролируется через четко определенный интерфейс.
  
**Сила инкапсулированного кода** в том, что каждый знает, как пол учить к нему доступ, и потому может использовать его независимо от деталей реализации и без каких-либо опасений столкнуться с неожиданными побочными эффектами.

**Основой инкапсуляции** в Java является класс.
Класс определяет структуру и поведение (данные и код), которые будут общими для набора объектов. Каждый объект заданного класса содержит структуру и поведение, определенные классом, как если бы он был "отлит" в форме класса. Поэтому **объект** – экземпляр класса.

Таким образом, класс представляет собой логическую конструкцию, а объект имеет физическую реальность.

В правильно написанных программах на Java методы определяют способ использования переменных-членов, т.е. поведение и интерфейс класса определяются методами, которые работают с данными его экземпляра. 

**Целью класса** является инкапсуляция сложности.

## Наследование 
Наследование представляет собой процесс, посредством которого один объект приобретает свойства другого объекта. Оно важно, т.к. поддерживает концепцию иерархической классификации.

**Суперкласс** — это класс, который предоставляет общие свойства и методы, которые могут быть унаследованы подклассами. Суперкласс определяет базовую структуру и поведение, которые могут быть общими для нескольких классов. Это позволяет избегать дублирования кода и обеспечивает более легкое управление и сопровождение кода.

Наследование также взаимодействует с инкапсуляцией. Когда подкласс наследует суперкласс, он наследует не только его методы и свойства, но также и инкапсулированную структуру и данные.

## Полиморфизм  
_(от греческого "много форм")_

Представляет собой средство, которое позволяет использовать один интерфейс для общего класса действий.

В языке, не являющемся объектно-ориентированным, вам придется создать три разных набора стековых процедур с отличающимися именами. Но благодаря полиморфизму в Java вы можете указать общий набор стековых процедур с одинаковыми имен.

</details>

<details><summary>Компиляция программы</summary>
Файл с исходным кодом в Java официально называется единицей компиляции. По соглашению имя главного класса должно совпадать с именем файла, содержащего программу.
  
В Java исходный код программы обычно разбивается на несколько классов, каждый из которых может быть размещен в отдельном файле. Каждый файл с исходным кодом Java обычно имеет расширение .java. Однако при компиляции этого исходного кода каждый класс превращается в отдельный файл байт-кода с расширением .class. Этот байт-код является исполняемым для Java виртуальной машины (JVM). 
  
Для того чтобы JVM могла найти и выполнить нужный класс при запуске программы, следует придерживаться следующей конвенции:
1.	Имя файла с исходным кодом (.java) должно совпадать с именем класса, который он содержит.
2.	Когда вы запускаете программу Java, вы указываете имя класса, который должен быть запущен. JVM автоматически ищет соответствующий файл с расширением .class.    
</details>

<details><summary>Подробный анализ первого примера программы</summary>
  
```html 
  public srtatic void main(String[] args){ }
```
Данная строка начинает метод main(). Как объяснялось в предыдущем комментарии, с этой строки программа начнет выполняться. Обычно программа на Java начинает выполнение с вызова main(). Полностью осознать смысл каждой части строки пока невозможно, т.к. для этого нужно хорошо понимать подход Java к инкапсуляци.

Ключевое слово puЫic представляет собой модификатор доступа, который позволяет программисту управлять видимостью чл енов класса. Когда член класса предварен ключевым словом puЫic, доступ к нему может быть получен из кода за пределами класса, где он объявлен. В данном случае метод main() должен быть объявлен как puЫic, потому что при запуске программы его потребуется вызывать в коде за пределами класса.

Ключевое слово static позволяет вызывать main() без создания конкретного экземпляра класса. Причина в том, что main() вызывается машиной JVM до создания каких-либо объектов, т.к. метод main принадлежит не конкретному экземпляру класса, а самому классу.

Ключевое слово void просто сообщает компилятору, что main() не возвращает значение.

Параметры метода – args, который получает любые аргументы командной строки, присутствующие при выполнении программы.

```html 
  System.out.printl("Hello, world!");
```
System — это класс в стандартной библиотеке Java, который предоставляет доступ к системным ресурсам и переменным окружения.

out — это объект типа PrintStream, который представляет стандартный вывод (обычно консоль). Он предоставляет методы для вывода данных. 

println — это метод объекта PrintStream, который используется для вывода текста или значения и добавляет перевод строки (новую строку) в конце вывода. Это означает, что следующий вывод будет на новой строке.

Если за место текста указать переменную, то на самом деле ее значение сначала преобразуется из целочисленного (или другой тип данных) в эквивалентное строковое и затем объединяется с предшествующей ему строкой.

</details>

<details><summary>Доп.</summary>
  
**Операции инкремента и декремента** — это арифметические операции, которые увеличивают (инкремент) или уменьшают (декремент) значение переменной на 1.
  
Блок кода создан, то становится логической единицей, которую можно применять в любом месте, где разрешено использовать одиночный оператор. Главная причина их существования - создание логически неразрывных единиц кода.

В Java **литералы** — это константные значения, которые представляют данные определенных типов.

</details>

</blockquote>
</details>

<details ГЛАВА 3><summary>ГЛАВА 3. "Типы данных, переменные и массивы"</summary>
<blockquote>
  
<details><summary>Типы данных</summary>
  
<details><summary>Целые числа</summary>

Во многих других языках программирования поддерживаются как целые числа со знаком(signed), так и целые числа без знак(unsigned), но разработчики Java решили, что целые числа без знака не нужны. В частности, они считали, что понятие без знака использовалось в основном для указания поведения старшего бита, который определяет знак целочисленного значения. В главе 4 вы увидите, что Java подругому управляет смыслом старшего бита, добавляя специальную операцию **"беззнакового сдвига вправо"**: таким образом, необходимость в целочисленном типе без знака попросту отпала.

**Беззнаковый сдвиг вправо** (unsigned right shift) - это операция, которая позволяет сдвигать биты числа вправо без учета его знака. В Java, этот механизм предоставляется оператором ">>>" и применяется к целым числам (int и long). Он используется для выполнения арифметических сдвигов битов числа, при которых самый старший бит (знаковый бит) не учитывается, и новые биты заполняются нулями.

Пример: 
```html 
int number = -8; // Бинарное представление: 11111111111111111111111111111000
int result = number >>> 1; // Сдвиг на 1 позицию вправо 
```

**Знаковый сдвиг вправо** (signed right shift) для целочисленных типов данных. Этот оператор выполняет сдвиг битов числа вправо на заданное количество позиций, при этом заполняет левую сторону (старшие биты) копией самого левого бита (знакового бита) перед сдвигом.

Пример: 
```html 
int x = -10; // Например, число -10 в двоичной системе: 11111111111111111111111111110110
x = x >> 2; // Знаковый сдвиг вправо на 2 позиции, получим 11111111111111111111111111111101
```

Ширина (или разрядность) целочисленного типа не должна трактоваться как объем потребляемой им памяти, а скорее как поведение, которое он определяет для переменных и выражений данного типа. 

Переменные типа byte особенно удобны при работе с потоком данных из сети или файла. Они также полезны, коrда приходится иметь дело с низкоуровневыми двоичными данными, которые моrут быть несовместимыми напрямую с другими встроенными типами Java.
</details>

<details><summary>Типы с плавающей точкой </summary>

В Java реализован стандартный (IEEE-754) набор типов и операций с плавающей точкой. Существуют две разновидности типов с плавающей точкой.

Тип float определяет значение одинарной точности.
Значение двойной точности.

</details>

<details><summary>Символы</summary>

Для хранения символов в Java используется тип данных char. Важно понять один ключевой момент: для представления символов в Java применяется Unicode. Кодировка Unicode определяет полностью международный набор 
символов, с помощью которого можно представить все символы, встречающиеся во всех естественных языках. Он объединяет десятки наборов символов, таких как романский, греческий, арабский, кириллический, иврит, катакана, ханrул и многие другие. Во время создания Java для Unicode требовалось 16 бит. Таким образом, в Java тип char является 16-битным с диапазоном значений от О до 65 535. Отрицат ельных значений char не бывает. Стандартный набор символов, известный как ASCII, по-прежнему находится в диапазоне от О до 127, а расширенный 8-битный набор символов, ISO-Latin-1 - в диапазоне от О до 255. Поскольку язык Java предназначен для написания программ, используемых по всему миру, при представлении символов имеет смысл применять Unicode. Конечно, использование Unicode несколько неэффективно для таких языков, как английский, немецкий, испанский или французский, символы которых могу т легко умещаться в пределах 8 бит. Но такова цена, которую приходится платить за глобальную переносимость.

 Дополнительную информацию о Unicode можно найти на веб-сайте http://www.unicode.org. 

[Chapter03/TypeChar - Работа с типом данных char](https://github.com/Vladlena2/BookJava/blob/main/Chapter3/TypeChar.java "Посмотреть пример Java")

Обратите внимание, что переменной chl присвоено значение 88, которое является кодом ASCII (и Unicode), соответствующим букве Х. Как уже упоминалось, набор символов ASCII занимает первые 127 значений в наборе символов Unicode. По этой причине все "старые уловки'; которые вы могли использовать с символами в других языках, будут работать и в Java.

</details>

Отличие литералов от обычных переменных заключается в том, что литералы представляют фиксированные, неизменяемые значения, заданные непосредственно в исходном коде программы, в то время как переменные представляют хранимые значения, которые могут изменяться в процессе выполнения программы.

<details><summary>Целочисленные литералы</summary>

Любое целочисленное значение является целочисленным литералом. 

В Java, присвоение литеральных значений переменным типов byte и short, находящимся в пределах допустимого диапазона для этих типов, не вызывает ошибку компиляции. Это связано с тем, что литералы, которые входят в допустимый диапазон для byte или short, могут быть неявно преобразованы в эти типы без необходимости явного приведения.

Что касается литералов типа long, то в Java литералы long должны быть явно помечены суффиксом L или l (буква "эль" в верхнем или нижнем регистре), чтобы компилятор понимал, что это именно литерал типа long. Например: 
```html 
long myLong = 9223372036854775807L; // Явно указан литерал типа long с суффиксом "L"
```
Без суффикса L, компилятор может рассматривать литерал как int, и если значение литерала выходит за пределы допустимого диапазона для int, то это вызовет ошибку компиляции. Добавление суффикса L явно указывает компилятору, что литерал относится к типу long.

Указывать целочисленные литералы можно также в двоичной форме, добавляя к значению префикс ОЬ или 0В. Скажем, вот как з адать десятичное значение 10 с помощью двои чного литерала:
```html 
int х = ОЫОlО; 
```
Помимо прочего, добавление двои чных литералов упрощает ввод значений, применяемых в качестве битовых масок. Десяти чное (или шестнадцатери чное) представление значения визуально не передает смысл битовой маски, а двои чный литерал его передает

</details>

<details><summary>Литералы с плавающей точкой</summary>

В научной форме записи числа с плавающей точкой используется стандартный формат, который включает само число и степень, на которую это число умножается. Это формат, который широко используется в научных и инженерных расчетах для представления очень больших или очень маленьких чисел.

Этот формат выглядит следующим образом:
```html 
Число * 10^Показатель_степени
```
- Число - это само число с плавающей точкой, которое вы хотите представить.
- 10 - основание, которое всегда остается неизменным и равно 10, так как мы используем десятичную систему счисления.
- Показатель_степени - это степень 10, на которую число умножается. Этот показатель обозначается буквой "E" или "е", за которой следует целое число. Если это число положительное, то оно указывает на количество десятичных разрядов, на которое нужно сдвинуть десятичную точку вправо. Если число отрицательное, то десятичная точка сдвигается влево на соответствующее количество разрядов.

Примеры:
- 6.022E23 (6.022 * 10^23) - это означает, что число 6.022 умножается на 10 в 23 степени.
- 3.14159E-5 (3.14159 * 10^-5) - это означает, что число 3.14159 умножается на 10 в -5 степени, что эквивалентно делению на 10^5.
- 2e+100 (2 * 10^100) - это означает, что число 2 умножается на 10 в 100 степени.

Литералы с плавающей точкой в Java по умолчанию имеют тип douЫe. 
Для указания литерала типа float к константе необходимо добавить букву F 
или f. Можно также явно указывать литерал douЫe, добавляя букву О или d, 
хотя поступать так излишне. Назначаемый по умолчанию тип douЫe занимает 64 бита памяти, а меньший тип float требует только 32 бита.

Шестнадцатеричные литералы с плавающей точкой в Java записываются с использованием буквы "P" или "p", и они представляют числа в форме, похожей на научную нотацию, но с учетом степени двойки. Важно отметить, что это специфичный формат, который не так часто используется.
Пример:
```html 
0x12.2p2 представляет шестнадцатеричный литерал с плавающей точкой.
```

Разберем этот пример:

- 0x12.2 - это шестнадцатеричное число, которое представляет значение в шестнадцатеричной системе счисления. Здесь 0x указывает, что число записано в шестнадцатеричной форме. 0x12.2 представляет значение, которое равно 18.125 в десятичной системе.
- p2 - это обозначение двоичного показателя степени, где "2" указывает, что число умножается на 2 во второй степени, то есть на 4.

Итак, 0x12.2p2 означает, что значение 18.125 (из шестнадцатеричного числа) умножается на 4 (из двоичного показателя степени), и итоговое значение равно 72.5 в десятичной системе счисления.

</details>

<details><summary>Булевские литералы</summary>
  
Значение типа boolean может иметь только 
два логических значения: true и false. Значения true и false не преобразуются в какое-то числовое представление. Литерал true в Java не равен 1, а литерал false не равен О, т.к. разные типы данных.
  
</details>

<details><summary>Символьные литералы</summary>

В Java можно представить символы в восьмеричной или шестнадцатеричной форме с использованием обратной косой черты (\). Это предоставляет возможность вставлять специальные символы или символы, которые не могут быть набраны с клавиатуры, непосредственно в строковые литералы. Вот как это работает:

Восьмеричная форма записи:
- Для представления символа в восьмеричной форме используйте обратную косую черту (\), за которой следует трехзначное восьмеричное число (от 000 до 377).
Например, '\\141' представляет букву 'а', где 141 - это восьмеричное представление символа 'а'.
Шестнадцатеричная форма записи:
- Для представления символа в шестнадцатеричной форме используйте обратную косую черту и букву 'u' (\u), за которой следуют четыре шестнадцатеричных символа.
Например, '\u0061' представляет символ 'а' из набора символов ISO-Latin-1, где 0061 - это шестнадцатеричное представление символа 'а'.

**Управляющие последовательности символов**

|Управляющая последовательность|Описание|
|:-----------------------------|:-------|
|\ddd|Восьмеричный символ ( ddd) |
|\uxxxx|Шестнадцатеричный символ в Юникоде (.хххх)|
|\'|Одинарная кавычка|
|\"|Двойная кавычка|
|'\'|Обратная косая черта|
|\r|Возврат каретки|
|\n|Новая строка (или перевод строки)|
|\f|Подача страницы|
|\t|Табуляция|
|\b|Возврат на одну позицию ("забой")|

</details>

<details><summary>Строковые литералы</summary>

Как вам может быть известно, в некоторых других языках строки реализуются в виде 
массивов символов. Тем не менее, в Java ситуация иная. Строки на самом деле являются объектными типами. Как вы увидите далее в книге, по причине реализации строк как объектов 
Java обладает обширными возможностями обработки строк, которые характеризуются мощью и простотой использования.
  
</details>
</details>

<details><summary>Переменные</summary>
Переменная служит базовой единицей хранения в программе на Java.

Область видимости, определяемая методом, начинается с его открывающей фигурной скобки. Однако если у метода есть параметры, то они тоже входят в область видимости метода. Область видимости метода заканчивается 
закрывающей фигурной скобкой. Такой блок кода называется телом метода. 

Необходимо запомнить еще один важный момент: переменные создаются 
при входе в их область видимости и уничтожаются при выходе из их области 
видимости. Другими словами, переменная не будет хранить свое значение 
после того, как покинет пределы области видимости. Следовательно, переменные, объявленные в методе, не сохраняют свои значения между вызовами 
этого метода. Кроме того, переменная, объявленная внутри блока, утратит 
свое значение при выходе из блока. Таким образом, время жизни переменной 
ограничено ее областью видимости. 

Когда значение одного типа присваивается переменной другого типа, **автоматическое преобразование** типов происходит в случае удовлетворения следующих двух условий: 
• два типа совместимы; 
• целевой тип больше исходного типа.

**Сужающее преобразование:** требует явного указания, когда тип данных менее широкий, чем целевой тип. Например, преобразование int в byte:
```html 
int x = 300;
byte y = (byte) x; // Сужающее преобразование с явным указанием.
```
Если значение выходит за пределы диапазона целевого типа, оно усекается (по модулю диапазона).

**Усечение при преобразовании с плавающей точкой**: При преобразовании из числа с плавающей точкой в целое число дробная часть усекается.

В следующей программе демонстрируется несколько преобразований типов, требующих приведений:
[Chapter03/Conversion - Преобразования](https://github.com/Vladlena2/BookJava/blob/main/Chapter3/Conversion.java "Посмотреть пример Java")

Вот вывод, генерируемый программой: 
```html 
Преобразование i nt в byte. 
i и Ь: 257 1 
Преобразование douЫe в int . 
d и i: 32 3.142 323 
Преобра зова ние douЬle в byte . 
d и Ь: 32 3.142 67 
```
Давайте обсудим каждое преобразование. Когда значение 257 приводится к типу byte, результатом будет остаток от деления 2 57 на 256 (диапазон 
byte), который в данном случае равен 1. Когда значение переменной d преобразуется в тип int, его дробная часть утрачивается. Когда значение переменной d преобразуется в тип byte, его дробная часть теряется, а значение 
уменьшается по модулю 256, что в этом случае дает 67. 

В Java происходит автоматическое приведение типов, когда операнды арифметических выражений повышаются до определенного уровня (целевого типа), чтобы обеспечить точность и предотвратить потерю данных в результате вычислений. Этот процесс называется преобразованием типов при выполнении (widening, promotion). Он обеспечивает сохранность данных и правильное выполнение арифметических операций.

При выполнении арифметических операций, например, умножения (*), операнды автоматически повышаются до целевого типа. По умолчанию, в Java целевым типом для целых чисел является int. Это означает, что если вы выполняете арифметическую операцию между byte и int, byte будет повышен до int, и результат также будет иметь тип int. Даже если результат выражения может уместиться в byte, он все равно будет иметь тип int.
```html 
byte a = 50;
byte b = 2;
byte result = a * b; // Ошибка компиляции, так как a и b автоматически повышаются до int, и результат также имеет тип int.
```
В данном примере, результат выражения a * b имеет тип int, и поэтому его нельзя присвоить переменной byte без явного приведения (сужения типа).

Это сделано для обеспечения точности и предотвращения потери данных в процессе вычислений. Если вам нужно сохранить результат в переменной типа byte, вы можете явно выполнить приведение типа:
```html 
byte result = (byte) (a * b); // Приведение типа к byte.
```

В Java определено несколько правил повышения типов, которые применяются к выражениям. Вот как они выглядят. Первым делом все значения byte, 
short и char повышаются до int, как только что было описано. Если один 
операнд имеет тип long, то все выражение повышается до long. Если один 
операнд имеет тип float, тогда все выражение повышается до float. Если 
какой-либо из операндов имеет тип douЫe, то результат будет иметь тип 
double. 
</details>

<details><summary>Массивы</summary>
  
**Массив** - это группа переменных одного типа, к которой можно обращаться по общему имени. Можно создавать массивы любого типа с одним или большим количеством измерений.

<details><summary>Одномерные массивы</summary>
Одномерный массив по существу представляет собой список переменных одного типа. 

```html 
переменная-типа-массива = new тип [размер]; 
```
new - это специальная операция, которая выделяет память. 

Здесь тип указывает тип размещаемых в памяти данных, размер устанавливает количество элементов в массиве, а переменная-типа-массива представляет собой переменную, связанную с массивом. То есть, чтобы использовать 
new для размещения массива, вы должны указать тип и количество элементов в 
массиве. 

```html 
month_days = new int [12]; 
```
После выполнения этого оператора month_days будет ссылаться на массив 
из 12 целых чисел. Вдобавок все элементы в массиве будут инициализированы нулем. Имеет смысл повторить: получение массива - двухэтапный процесс. Во-первых, вы обязаны объявить переменную нужного типа массива. Во-вторых, вы должны выделить память, в которой будет храниться массив, с применением операции new и назначить ее переменной типа массива. Таким образом, в Java все массивы размещаются в памяти динамически

[Chapter03/Array - Продемонстрировать применение одномерного массива](https://github.com/Vladlena2/BookJava/blob/main/Chapter3/Array.java "Посмотреть пример Java")

[Chapter03/CountDayArray - Усовершенствованная версия предыдущей программы](https://github.com/Vladlena2/BookJava/blob/main/Chapter3/CountDayArray.java "Посмотреть пример Java")


</details>

<details><summary>Многомерные массивы</summary>
Многомерные массивы в Java реализованы как массивы массивов.

[Chapter03/DuoArray - Пример двумерного массива](https://github.com/Vladlena2/BookJava/blob/main/Chapter3/DuoArray.java "Посмотреть пример Java")

[Chapter03/ThreeArray - Пример трехмерного массива](https://github.com/Vladlena2/BookJava/blob/main/Chapter3/ThreeArray.java "Посмотреть пример Java")
  
Хотя в такой ситуации индивидуальное размещение массивов второго измерения не дает каких-то преимуществ, в других случаях такие преимущества 
могут быть. Скажем, при выделении памяти под измерения по отдельности 
вам не нужно размещать одинаковое количество элементов для каждого измерения. Как утверждалось ранее, поскольку многомерные массивы на самом 
деле являются массивами массивов, длина каждого массива находится под 
вашим контролем. Например, в следующей программе создается двумерный 
массив, в котором размеры массивов во втором измерении не равны:

[Chapter03/TwoDAgain - Резервирование памяти вручную для массива с разной размерностью второго измерения]([https://github.com/Vladlena2/BookJava/blob/main/Chapter3/TwoDAgain.java "Посмотреть пример Java")

Ст упенчатые (или нерегулярные) многомерные массивы могут оказаться 
неподходящими для многих приложений, потому что они противоречат тому, 
что люди ожидают найти при встрече с многомерным массивом. Однако в некоторых ситуациях нереrу лярные массивы можно эффективно использовать. 
Скажем, если вам нужен очень большой разреженный двумерный массив (т.е. 
такой, rде задействованы не все элементы), тогда нерегулярный массив может стать идеальным решением

Также обратите внимание, что внутри инициализаторов массивов можно применять выражения и литеральные значения. 

Существует вторая форма объявления массива:
```html 
тип имя-переменной[ ];
char twodl[][] = new char[3][4] ;  
```
Эта альтернативная форма объявления обеспечивает удобство при преобразовании кода из С/С++ в Java. Кроме того, она позволяет объявлять в одном операторе объявления и переменные с типами массивов, и переменные 
с типами, отличающимися от массивов. В настоящее время альтернативная 
форма используется реже, но знать ее по-прежнему важно, поскольку в Java 
разрешены обе формы объявления массивов. 

</details>
</details>

<details><summary>Знакомство с выведением типов локальных переменных</summary>
  
В Java, начиная с версии 10, была внедрена возможность автоматического выведения типов локальных переменных. Это означает, что в некоторых случаях компилятор может определить тип переменной на основе значения, которое ей присваивается. Это упрощает объявление переменных и делает код более читаемым и компактным.

```html 
var variableName = assignedValue;
```
- var: ключевое слово, которое заменяет объявление типа переменной.
- variableName: имя переменной.
- assignedValue: значение, которое присваивается переменной.

Примеры использования:

1. Инференция типа с примитивами
```html 
var number = 10; // number имеет тип int.
var pi = 3.14159; // pi имеет тип double.
```
2. Инференция типа с объектами
```html 
var message = "Hello, World!"; // message имеет тип String.
var list = new ArrayList<Integer>(); // list имеет тип ArrayList<Integer>.
```
3. Инференция типа в циклах
```html 
var numbers = new int[] { 1, 2, 3, 4, 5 };
for (var number : numbers) {
    // number имеет тип int внутри цикла.
}
```
4. Смешанное использование с объявлением типа
```html 
var x = 5; // x имеет тип int.
int y = 10;
var result = x + y; // result имеет тип int.
``` 
5. Инференция типа с массивами
```html 
var numbers = new int[] { 1, 2, 3, 4, 5 }; // numbers имеет тип int[].
var names = new String[] { "Alice", "Bob", "Charlie" }; // names имеет тип String[].
``` 
6. Смешанное использование инференции типа и объявления типа
```html 
var scores = new int[] { 90, 85, 78 };
int[] grades = { 88, 92, 76 };
```

**Ограничения.** Можно 
объявлять только одну переменную за раз, для переменной нельзя использовать null в качестве инициализатора и объявляемая переменная не может 
присутствовать в выражении инициализатора. Хотя с применением var можно объявить тип массива, ключевое слово var нельзя использовать с инициализатором массива. 
Как отмечалось ранее, ключевое слово var не разрешено применять для 
имени класса. Его также не допускается использовать в качестве имени других ссылочных типов, включая интерфейс, перечисление или аннотацию, 
либо в качестве имени параметра обобщенного типа. Выведение типов локальных переменных нельзя применять для объявления типа исключения, перехваченного оператором 
catch. Кроме того, ни лямбда-выражения, ни ссылки на методы не разрешено использовать в качестве инициализаторов.
</details>

</blockquote>
</details>

<details ГЛАВА 4><summary>ГЛАВА 4. "Операции"</summary>
<blockquote>

<details><summary>Арифметические операции</summary>

Основные арифметические операции - сложение, вычитание, умножение 
и деление - ведут себя так, как и следовало ожидать для всех числовых типов. Унарный минус инвертирует свой единственный операнд. Унарный плюс 
просто возвращает значение своего операнда. Помните, что когда операция 
деления применяется к целочисленному типу, дробная часть к результату не 
присоединяется.

[Chapter04/BasicMath - Продемонстрировать основные арифметические операции](https://github.com/Vladlena2/BookJava/blob/main/Chapter4/BasicMath.java "Посмотреть пример Java")

[Chapter04/Modulus - Операция деления по модулю "%" (возвращает остаток от деления)](https://github.com/Vladlena2/BookJava/blob/main/Chapter4/Modulus.java "Посмотреть пример Java")

Составные операции присваивания обеспечивают два преимущества. Во-первых, они уменьшают объем набираемоrо кода, потому что являются "сокращенной формой" для своих длинных эквивалентов. Во-вторых, в некоторых случаях они более эффективны, чем их длинные эквиваленты. По указанным причинам составные операции присваивания часто используются в профессионально написанных программах на Java. 

[Chapter04/OpEquals - Составные операции с присваиванием](https://github.com/Vladlena2/BookJava/blob/main/Chapter4/OpEquals.java "Посмотреть пример Java")

Операции инкремента и декремента. Приведенные операции уникальны тем, что могут встречаться и в постфиксной форме, когда они следуют за операндом, как было только что показано, и в префиксной форме, когда они предшествуют операнду. В предшествующих примерах никаких отличий между префиксной и постфиксной формами 
не было. Однако когда операторы инкремента и/или декремента входят в состав более крупного выражения, то между этими двумя формами проявляется тонкая, но важная разница. В префиксной форме операнд инкрементируется или декрементируется перед получением значения для использования 
в выражении. В постфиксной форме предыдущее значение извлекается для 
применения в выражении, после чего модифицируется операнд. Например:

```html 
х = 42; 
у = ++х;
равно
х = х + 1; 
у = х; 
```

```html 
х = 42; 
у = х++; 
равно
у = х; 
х = х + 1;
```
</details>

<details><summary>Побитовые операции</summary>

**Поразрядные операции в Java**
```  
"~"    - Поразрядная унарная операция НЕ  
"&"    - Поразрядная логическая операция И  
"|"    - Поразрядная логическая операция ИЛИ  
"^"    - Поразрядная логическая операция исключающее ИЛИ  
">>"   - Сдвиг вправо  
">>>"  - Сдвиг вправо с заполнением нулями  
"<<"   - Сдвиг влево  
"&="   - Поразрядная логическая операция И с присваиванием  
"|="   - Поразрядная логическая операция ИЛИ с присваиванием  
"^="   - Поразрядная логическая операция исключающее ИЛИ с присваиванием  
">>="  - Сдвиг вправо с присваиванием  
">>>=" - Сдвиг вправо с заполнением нулями и присваиванием  
"<<="  - Сдвиг влево с присваиванием  
```

В Java используется кодировка, известная как доnоанение до двух или 
доnоАнumеАьный код, которая предусматривает представление отрицательных 
чисел путем инвертирования (замены единиц на нули и наоборот) всех битов в значении и последующего добавления единицы к результату. Например, 
для представления -42 инвертируются все биты в 42, или 00101010, что дает 
1 1010101, после чего к результату добавляется 1, давая в итоге 1 1010110, или 
-42. Чтобы декодировать отрицательное число, необходимо инвертировать 
все биты и добавить 1. Например, -42, или 1 10101 10, в результате инвертирования дает 00101001, или 41, а после добавления 1 получается 42

Особенности представления нуля и отрицательных чисел для значений типа byte (и других целочисленных типов).

Для представления нуля в дополнительном коде, инвертируете все биты, и в результате получаете "11111111". Это инвертированное представление нуля, которое обычно не используется в целочисленной арифметике.

Для решения этой проблемы и представления отрицательных значений используется дополнение до двух. Когда к инвертированному значению добавляется 1, возникает следующее:

"11111111" (инвертированное значение) + 1 = "100000000"
Однако, восьмой бит (самый левый бит) в byte не умещается, и он обрезается. Таким образом, "100000000" на самом деле становится "00000000" в byte, что является представлением нуля в дополнительном коде до двух. Это "ноль" совпадает с нулем, и весьма удобно для работы в целочисленной арифметике.

Этот метод представления нуля и отрицательных чисел позволяет правильно работать с арифметикой и легко определять граничные случаи.

Во избежание неприятных сюрпризов 
просто помните, что старший бит определяет знак целого числа независимо 
от того, как он был установлен. 

[Chapter04/BitLogic - Продемонстрировать применение поразрядных логических операций](https://github.com/Vladlena2/BookJava/blob/main/Chapter4/BitLogic.java "Посмотреть пример Java")

**Сдвиг влево**

Здесь число устанавливает количество позиций для сдвига влево значения. 
То есть операция << перемещает все биты в указанном значении влево на 
количество битовых позиций, заданное в числе. При каждом сдвиге влево 
старший бит смещается (и утрачивается), а справа вставляется ноль. Это означает, что когда к операнду int применяется сдвиг влево, биты теряются, 
как только они сдвигаются за битовую позицию 31. В случае операнда типа 
long биты утрачиваются после битовой позиции 63. 
При сдвиге значений byte и short автоматическое повышение типов в 
Java приводит к неожиданным результатам. Как вы знаете, во время вычисления выражения значения byte и short повышаются до int. Кроме того, результат такого выражения тоже имеет тип int. Это означает, что результатом 
сдвига влево значения byte или short будет значение int, а биты, сдвинутые 
влево, не будут утрачены до тех пор, пока они не сместятся за битовую позицию 31. Вдобавок отрицательное значение byte или short при повышении до 
int будет расширено знаком. Таким образом, старшие биты будут заполнены 
единицами. По указанным причинам выполнение сдвига влево значения byte 
или short подразумевает необходимость отбрасывания старших байтов из 
результата типа int. Например, при сдвиге влево значения byte оно сначала 
повышается до int, после чего сдвигается. Если нужно получить результат 
сдвинутого значения byte, то придется отбросить три старших байта результата. Самый простой способ решить задачу - преобразовать результат обратно в byte.

**Сдвиг вправо**

При выполнении сдвига вправо старшие (крайние слева) биты, открытые 
сдвигом, заполняются предыдущим содержимым старшего бита. Это называется расширением знака и служит для сохранения знака отрицательных чисел 
при их сдвиге вправо. Например, -8 >> 1 равно -4, что в двоичном виде выглядит так: 

```html 
1111 1000 -8 
>> 1 
11111 100 -4 
```

Интересно отметить, что в случае сдвига вправо значения -1 результат 
всегда остается -1, т.к. расширение знака будет приводить к большему количеству единиц в старших битах. 
Иногда расширять знаки значений при сдвиге вправо нежелательно. 

Скажем, в приведенной далее программе значение byte преобразуется в 
шестнадцатеричное строковое представление. Обратите внимание, что сдвинутое значение маскируется с помощью операции И с 0x0f для отбрасывания 
любых битов, дополненных знаком, чтобы значение можно было использовать в качестве индекса в массиве шестнадцатеричных символов. 

[Chapter04/HexByte - Маскирование двоичных разрядов расширения знака](https://github.com/Vladlena2/BookJava/blob/main/Chapter4/HexByte.java "Посмотреть пример Java")

**Беззнаковый сдвиг вправо**
Как только что объяснялось, операция >> автоматически заполняет старший бит его предыдущим содержимым каждый раз, когда происходит сдвиг, 
сохраняя знак значения. Тем не менее, иногда это нежелательно. Например, 
при выполнении сдвига чего-то, что не представляет собой числовое значение, расширение знака может оказаться ненужным. Такая ситуация часто встречается при работе с пиксельными значениями и графикой. В ситуациях 
подобного рода обычно требуется помещать в старший бит ноль вне зависимости от того, каким было его начальное значение. Прием известен как беззнаковый сдвиг и предусматривает применение операции беззнакового сдвига 
вправо, >>>, которая всегда задвигает нули в старший бит. 
аво, >>>, которая всегда задвигает нули в старший бит. 

В следующем фрагменте кода демонстрируется работа операции >>>. 
Здесь значение а устанавливается в -1, что приводит к установке всех 32 бит 
в 1. Затем значение сдвигается вправо на 24 позиции с заполнением старших 
24 бит нулями и игнорированием расширения знака. В итоге а устанавливается в 255. 

```html 
int a = -1; 
а = а >>> 24;
```

Ниже показана та же самая операция в двоичной форме с целью дополнительной иллюстрации того, что происходит:
```html 
11111111 11111111 11111111 11111111 -1 в двоичном виде
>>24 
00000000 00000000 00000000 11111111 255 в двоичном виде
```
Операция >>> часто не настолько полезна, как хотелось бы, поскольку 
она имеет смысл только для 32- и 64-битных значений. Вспомните, что при 
вычислении выражений меньшие значения автоматически повышаются до 
int. В итоге происходит расширение знака, и сдвиг будет выполняться над 
32-битным, а не 8- или 16-битным значением. То есть можно ожидать, что 
беззнаковый сдвиг вправо значения byte заполнит нулями, начиная с бита 7. 
Но это не так, поскольку на самом деле сдвигается 32-битное значение. 
Эффект демонстрируется в следующей программе:


[Chapter04/ByteUShift - Сдвиг влево значения типа byte](https://github.com/Vladlena2/BookJava/blob/main/Chapter4/ByteUShift.java "Посмотреть пример Java")

В показанном ниже выводе программы видно, что при работе с байтами 
операция >>> ничего не делает. Для данной демонстрации переменной Ь присваивается произвольное отрицательное значение типа byte. Затем переменной с присваивается значение Ь типа byte, сдвинутое вправо на четыре позиции, которое равно Oxff из-за ожидаемого расширения знака. Далее 
переменной d присваивается значение Ь типа byte с беззнаковым сдвигом 
вправо на четыре позиции, которым вопреки ожидаемому OxOf будет Oxff 
по причине расширения знака, происшедшего при повышении Ь до int перед сдвигом. Последнее выражение устанавливает переменную е в значение 
Ь типа byte, маскированное до 8 бит с помощью операции И, после чего 
сдвинутое вправо на четыре позиции, что дает ожидаемое значение OxOf. 
Обратите внимание, что операция беззнакового сдвига вправо не использовался для переменной d, т.к. состояние знакового бита после операции И 
было известно. 

Сравнение знакового и беззнакового сдвига:

```html 
int value = -8;  // Значение -8
int result = value >> 1;  // Знаковый сдвиг вправо на 1 бит
System.out.println("Результат: " + result);
```
В этом примере, value равно -8, а value >> 1 сдвигает значение на 1 бит вправо. Ожидается, что результат будет -4, потому что знаковый сдвиг сохраняет знак (в данном случае, отрицательный).

```html 
int value = -8;  // Значение -8
int result = value >>> 1;  // Беззнаковый сдвиг вправо на 1 бит
System.out.println("Результат: " + result);
```
Результат беззнакового сдвига >>> будет положительным числом 2147483644, что произошло из-за того, что знаковый бит был сброшен. Это демонстрирует разницу между знаковым и беззнаковым сдвигами. В контексте данного вопроса о беззнаковых сдвигах, можно сказать, что они "избегают влияния знакового бита".

</details>

<details><summary>Операции отношения</summary>

**Операции отношения(сравнения)**
```
"=="   - Равно  
"!="   - Не равно  
">"    - Больше
"<"    - Меньше  
">="   - Больше или равно  
"<="   - Меньше или равно
```

Результатом этих операций является значение boolean. Операции отношения чаще всего используются в выражениях, управляющих оператором i f и 
различными операторами циклов. 

Как уже упоминалось, результатом операции отношения будет значение 
boolean. Например, следующий фрагмент кода совершенно корректен:

```html 
int а= 4; 
int Ь = 1; 
boolean с = а < Ь;
```
В данном случае в переменной с сохраняется результат выполнения а<Ь 
(равный false). 

Если ранее вы работали с С/С++, то обратите внимание, что в программах 
на С/С++ весьма распространены следующие виды операторов:

```html 
int done; 
// ... 
if ( ! done ) // Допустимо в С/ С++ ,  
if ( done) // но не в Java
```

В коде Java такие операторы должны быть записаны так, как показано ниже: 

```html 
if ( done == О ) // Стиль Java . 
if (done != О) 
```
Причина в том, что истинное и ложное значения в Java определены не так, 
как в С/С++. В языках С и С++ истинным является любое ненулевое значение, а ложным - ноль. В Java true и false представляют собой нечисловые значения, которые никак не связаны с нулем или ненулевым значением. 
Следовательно, для проверки на предмет равенства или неравенства нулю 
должна явно применяться одна или несколько операций отношения. 

**Логические операции**
```
&  - Логическая операция И  
|  - Логическая операция ИЛИ  
^  - Логическая операция исключающее ИЛИ  
|| - Укороченная логическая операция ИЛИ  
&& - Укороченная логическая операция И  
!  - Логическая унарная операция НЕ  
&= - Логическая операция И с присваиванием  
|= - Логическая операция ИЛИ с присваиванием  
^= - Логическая операция исключающее ИЛИ с присваиванием  
== - Равенство  
!= - Неравенство  
?: - Тернарная условная операция типа если"., то"., иначе".
```

В языке Java померживаются две интересные булевские операции, отсутствующие в ряде других языков программирования. Речь идет о вспомогательных версиях булевских операций И и ИЛИ, широко известные как 
короткозамкнутые логические операции. В табл. легко заметить, что результатом операции ИЛИ будет true, когда А имеет значение t rue вне зависимости от значения В. Аналогично операция И дает результат false, когда 
А равно false безотносительно к тому, какое значение имеет В. В случае применения форм || и && вместо форм | и & указанных операций Java правый 
операнд не будет вычисляться в ситуации, когда результат выражения может 
быть определен только левым операндом. Это очень полезно, когда правильное функционирование предусматривает зависимость правого операнда от 
левого. В приведенном ниже фрагменте кода показано, как можно использовать в своих интересах короткозамкнутое логическое вычисление, чтобы 
убедиться в допустимости операции деления до ее выполнения:

```html 
if (denom 1 = О && num / denom > 10)
```

Поскольку применяется короткозамкнутая форма операции И (&&), нет 
риска вызвать исключение во время выполнения, когда переменная denom 
равна нулю. Если бы данная строка кода была написана с использованием 
односимвольной версии операции &, то вычислялись бы обе стороны выражения, приводя к исключению во время выполнения, когда значение denom 
равно нулю. 
Стандартная практика предусматривает применение короткозамкнутых 
форм И и ИЛИ в случаях, связанных с булевской логикой, оставляя односимвольные версии исключительно для побитовых операций. Однако из этого правила есть исключения. Например, взгляните на оператор следующего 
вида: 

```html 
if (c==1 & е++ < 100) d = 100;
```
 
Здесь использование версии & гарантирует, что операция инкремента будет применена к е независимо от того, имеет переменная с значение 1 или нет.

## Операция ?

В Java предусмотрена специальная тернарная операция, которая способна 
з аменить определенные виды операторов "если-то-иначе': Она обозначается 
с помощью знака ?.

Вот общий вид операции ?: 

```html 
выражение1 ? выражение2 : выражениеЗ
```

десь выражение1 может быть л юбым выражением, результатом которого является значение boolean. Если результатом выражения1 является true, 
тогда вычисляется выражение2, а иначе выражениеЗ. Результатом операции ? 
будет результат вычисленного выражения. Типы результатов выражения2 и 
выражениеЗ должны быть одинаковыми (или совместимыми) и не могут быть 
void. Ниже показан пример применения операции ?: 

```html 
ratio = denom == О ? О : num / denom; 
```

При вычислении этого выражения присваивания сначала просматривается 
выражение слева от вопросительного знака. Если значение denom равно нулю, 
тогда вычисляется выражение между вопросительным знаком и двоеточием 
и используется в качестве значения всего выражения ?. Если значение denom 
не равно нулю, то вычисляется выражение после двоеточия и становится значением всего выражения ?. Затем результат операции ? присваивается переменной ratio. 

[Chapter04/Ternary - Продемонстрировать применение тернарной операции "?"](https://github.com/Vladlena2/BookJava/blob/main/Chapter4/Ternary.java "Посмотреть пример Java")

## Старшинство операций

Вот некоторые основные операторы Java, упорядоченные по приоритету (от более высокого приоритета к более низкому):

1. Постфиксные операторы: expr++, expr-- (например, инкремент и декремент).
2. Префиксные операторы: ++expr, --expr, +expr, -expr, !expr, ~expr (например, инкремент, декремент, унарный плюс, унарный минус и т. д.).
3. Умножение и деление: *, /, % (умножение, деление и остаток от деления).
4. Сложение и вычитание: +, -.
5. Сдвиги: <<, >>, >>> (побитовые сдвиги влево и вправо).
6. Отношения: <, >, <=, >=, instanceof.
7. Равенство: ==, !=.
8. Побитовое "И": &.
9. Побитовое "ИЛИ": |.
10. Побитовое "Исключительное ИЛИ": ^.
11. Логическое "И" (AND): &&.
12. Логическое "ИЛИ" (OR): ||.
13. Условный оператор: ? :.
14. Присваивание: =, +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=, >>>=.
15. Выражение запятой: , (для последовательного выполнения выражений).

Если операции имеют одинаковый приоритет, то их выполнение определяется ассоциативностью (слева направо или справа налево). Например, операции сложения и вычитания выполняются слева направо, поэтому a + b - c будет интерпретировано как (a + b) - c.

И еще один момент: круглые скобки (избыточные или нет) не ухудшают 
производительность программы. Таким образом, добавление круглых скобок 
для уменьшения неоднозначности не повлияет отрицательно на вашу программу.

</details>

</blockquote>
</details>

<details ГЛАВА 5><summary>ГЛАВА 5. "Управляющие операторы"</summary>
<blockquote>

<details><summary>Операторы выбора</summary>

## Оператор switch 

Как функционирует традиционный оператор switch: з начение 
выражения сравнивается с каждым значением в операторах case. Если совпадение найдено, то выполняется кодовая последовательность, следующая 
за оператором case. Если ни одна из констант не соответствует значению 
выражения, тогда выполняется оператор default. Однако оператор default 
необязателен. Если ни один из операторов case не дает совпадения, а оператор default отсутствует, то дальнейшие действия не предпринимаются.

Иногда желательно иметь несколько case без операторов break 
между ними. 

[Chapter05/MissingBreak - Продемонстрировать применение case без операторов break ].(https://github.com/Vladlena2/BookJava/blob/main/Chapter5/MissingBreak.java "Посмотреть пример Java")

Ниже демонстрируется его более реалистичное использование в 
переработанной программе определения принадлежности месяца к временам 
года. Теперь в нем применяется оператор switch для обеспечения более эффективной реализации. 

[Chapter05/Switch - Продемонстрировать более реалистичное использование case без операторов break ].(https://github.com/Vladlena2/BookJava/blob/main/Chapter5/Switch.java "Посмотреть пример Java")

Возможность применения строк в операторе switch упрощает код во многих ситуациях. Скажем, использовать switch на основе строк эффективнее 
по сравнению с эквивалентной последовательностью операторов if/еlsе. 
Тем не менее, выполнение оператора switch по строкам может оказаться более затратным, чем по целым числам. Таким образом, лучше всего применять 
switch на основе строк только в тех случаях, когда управляющие данные уже 
представлены в строковой форме. Другими словами, не используйте строки в 
switch без настоятельной необходимости. 

Вы можете применять switch как часть последовательности операторов 
внешнего switch. Он называется вложенным оператором switch. Поскольку 
оператор swi tch определяет собственный блок, между константами case 
во внутреннем switch и во внешнем switch конфликты не возникают. 

Подводя итоги, важно отметить три особенности оператора switch. 

• Оператор switch отличается от if тем, что он может проверять только 
на предмет равенства, тогда как оператор if способен оценивать логическое выражение любого вида. То есть switch ищет только совпадение 
значения выражения с одной из констант в операторах case. 

• Никакие две константы case в одном switch не могут иметь одинаковые значения. Разумеется, один оператор switch и включающий его 
внешний switch могут иметь общие константы case. 

• Оператор switch обычно более эффективен, чем набор вложенных операторов i f. 
Последний пункт особенно интересен, потому что он дает представление о 
том, как работает компилятор Java. При компиляции оператора switch компилятор Java проверит каждую константу case и создаст "таблицу переходов'; 
которую будет использовать для выбора пути выполнения в зависимости от 
значения выражения. Следовательно, есл и вам нужно делать выбор среди 
большой группы значений, то оператор switch будет работать намного быстрее, чем эквивалентная логика, реализованная с применением последовательности if-else. Компилятор способен добиться этого, т.к. ему известно, 
что все константы case имеют один и тот же тип и просто должны сравниваться на равенство с выражением switch. Что касается подобного знания 
длинного списка выражений if, то компилятор им не располагает.

</details> 

<details><summary>Операторы выбора</summary>

## Цикл while 

Тело цикла while (или любого дpyroro цикла Java) может быть пустым. 
Дело в том, что в Java синтаксически допустим пустой оператор (состоящий 
только из точки с запятой). Взгляните на следующую программу: 

[Chapter05/NoBody - Продемонстрировать пустой while](https://github.com/Vladlena2/BookJava/blob/main/Chapter5/NoBody.java "Посмотреть пример Java")

Рассмотрим, как работает этот цикл while. Значение i инкрементируется, 
а значение j декрементируется. Затем значения i и j сравниваются друг с 
другом. Если новое з начение i все еще меньше нового значения j, тогда цикл 
повторяется. Если значение i больше или равно значения j, то цикл останавливается. После выхода из цикла переменная i будет хранить значение, которое находится посередине между исходными значениями i и j. (Конечно, такая процедура работает только тогда, когда i меньше j .) Понятно, что здесь 
нет необходимости иметь тело цикла; все действие происходит внутри самого условного выражения. В профессионал ьно написанном коде на Java короткие циклы часто кодируются без тел, коrда управляющее выражение способно самостоятельно обрабатывать все детали. 

Как вы только что видели, если условное выражение, управляющее циклом 
while, изначально ложно, то тело цикла вообще не будет выполнено. Однако 
иногда тело цикла желател ьно выполнить хотя бы один раз, даже если изначально условное выражение ложно. Другими словами, бывают случаи, когда 
вы хотели бы проверять выражение завершения в конце цикла, а не в ero начале. К счастью, в Java есть цикл, который делает именно это: do-while.

## Цикл for 

Рассмотрим работу цикла for. При первом запуске цикла выполняется 
часть инициализация цикла. В общем случае она представляет собой выражение, которое устанавливает значение переменной управления циклом, которая действует в качестве счетчика, управляющего циклом. Важно понимать, 
что инициализирующее выражение выполняется только один раз. Затем вычисляется условие, которое должно быть булевским выражением. Как правило, оно сравнивает переменную управления циклом с целевым значением. 
Есл и условие истинно, тогда выполняется тело цикла, а если ложно, то цикл 
завершается. Далее выполняется часть итерация цикла, которая обычно является выражением, инкрементирующим или декрементирующим перенную управления циклом. После этого цикл повторяется, при каждом проходе 
вычисляя условное выражение, выполняя тело цикла и вычисляя выражение 
итерации. Такой процесс происходит до тех пор, пока управляющее выражение не станет ложным. 


При объявлении переменной внутри цикла for следует помнить об одном 
важном аспекте: область видимости этой переменной ограни чена циклом 
for. За пределами цикла for переменная перестает существовать. Если переменную управления циклом необходимо применять в другом месте программы, тогда объявлять ее внутри оператора for нельзя.

Чтобы позволить двум и более переменным управлять циклом for, в части инициализация и итерация цикла for разрешено 
включать несколько операторов, разделяя их запятыми. 

Есть еще одна интересная разновидность цикла for, в которой может отсутствовать либо часть инициализация, либо часть итерация, либо то и другое, как демонстрируется в следующей программе

## Цикл for-each

Общая форма версии "for-each" цикла for выглядит следующим образом: 
for ( тип переменная-итерации : коллекция) блок-операторов 
Здесь тип указывает тип, а переменная-итерации - имя переменной 
итерации, которая будет получать элементы из коллекции по одному за 
раз, от начала до конца. Коллекция, по которой проходит цикл, указывается в коллекции. Существуют различные типы коллекций, которые можно использовать с for, но в настоящей главе применяется только массив.
На каждой итерации цикла из коллекции из влекается очередной элемент и сохраняется в 
переменной-итерации. Цикл повторяется до тех пор, пока не будут получены 
все элементы коллекции. 
Поскольку переменная итерации получает з начения из коллекции, тип 
обязан совпадать или быть совместимым с типом элементов, хранящихся в коллекции. Таким образом, при проходе по массивам тип должен быть совместимым с типом элементов массива.

Чтобы понять мотивы создания цикла в стиле "for-each'; рассмотрим тип 
цикла for, который он призван заменить. В следующем фрагменте кода для 
вычисления суммы значений в массиве применяется традиционный цикл for:
```html 
int [] nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 1 0 } ; 
int sum = О; 
for ( int i=0 ; i < 10 ; i++ ) sum += nums [i]; 
```

Стиль "for-each" цикла for позволяет автоматизировать предыдущий цикл. 
В частности, он избавляет от необходимости устанавливать счетчик циклов, 
указывать начальное и конечное значение и вручную индексировать массив. 
Взамен он автоматически проходит по всему массиву, получая по одному элементу за раз, последовательно, от начала до конца. Например, вот предыдущий фрагмент, переписанный с применением версии цикла for в стиле "for-each": 
```html 
int [] nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 } ; 
int sum = О; 
for ( int х: nums ) sum += х;
```

При каждом проходе цикла переменной х автоматически присваивается 
значение, равное очередному элементу в nums. Таким образом, на первой итерации х содержит 1, на второй - 2 и т.д. Синтаксис не только стал проще, но 
он также предотвращает возникновение ошибок выхода за границы массива.

Существует один аспект, касающийся цикла for в стиле "for-each'; который важно понимать. Его переменная итерации доступна только для чтения, 
хотя она связана с лежащим в основе массивом. Присваивание значения переменной итерации не влияет на лежащий в основе массив. Другими словами, 
изменить содержимое массива, присваивая переменной итерации новое значение, не удастся. 

Расширенная версия for работает также и с мноrомерными массивами. 
Но не забывайте о том, что мноrомерные массивы в Java представляют собой массивы массивов. (Например, двумерный массив - это массив одномерных массивов.) Данный факт важен при проходе по многомерному массиву, 
поскольку на каждой итерации получается очередной массив, а не индивидуальный элемент. Кроме тоrо, переменная итерации в цикле for должна быть 
совместимой с типом пол учаемоrо массива. Например, в случае двумерноrо 
массива переменная итерации должна быть ссылкой на одномерный массив.

```html 
for (int [] х : nums ) { 
for ( i nt у: х) { 
System.out.println ( " Знaчeниe : "+у); 
sum += у; 
System.out.println ( "Сумма : " + sum ) ; 
```

Обратите внимание на то, как объявлена переменная х. Она является 
ссылкой на одномерный массив целых чисел. Необходимость в таком объявлении связана с тем, что на каждой итерации цикла for получается очередной массив из nums, начиная с массива nums[0]. Затем во внутреннем цикле 
for производится проход по каждому из этих массивов с отображением значения каждого элемента. 

Выведение типов локальных 
переменных можно применять в цикле for при объявлении и инициализации 
переменной управления циклом внутри традиционноrо цикла for или при 
указании переменной итерации в цикле for в стиле "for-each': В следующей 
проrрамме демонстрируются примеры каждою случая: 

[Chapter05/TypeInFerenceInFor - Продемонстрировать пустой while](https://github.com/Vladlena2/BookJava/blob/main/Chapter5/TypeInFerenceInFor.java "Посмотреть пример Java")

</details> 

<details><summary>Операторы перехода</summary>

В Java поддерживаются три оператора перехода: break, continue и return. 

Помимо обсуждаемых здесь операторов перехода в Java есть еще один способ, с 
помощью котороrо можно изменить поток выполнения программы: через обработку 
исключений. Обработка исключений обеспечивает структурированный подход, с помощью 
которого программа может перехватывать и обрабатывать ошибки во время выполнения. 
Он поддерживается ключевыми словами try, catch, throw, throws и finally. По 
существу механизм обработки исключений позволяет программе выполнять нелокальный 
переход. Поскольку обработка исключений является обширной темой, она обсуждается 
отдельно в главе 1О. 

## Оператор break

Оператор break в языке Java применяется в трех ситуациях. Во-первых, 
как вы видели, он завершает последовательность операторов в операторе 
swi tch. Во-вторых, его можно использовать для выхода из цикла. В-третьих, 
его можно применять как "цивилизованную" форму перехода в стиле "goto'.

Однако будьте осторожны. Слишком большое количество операторов break 
способно деструктурировать код. Во-вторых, оператор break, завершающий 
switch, влияет только на этот оператор switch, но не на любые объемлющие 
циклы. 

Оператор break не задумывался как обычное средство завершения цикла. Для этой цели 
предназначено условное выражение цикла. Оператор break должен применяться для 
прекращения работы цикла только в случае возникновения какой-то особой ситуации. 

В дополнение к применению с оператором switch и циклами оператор 
break также может использоваться сам по себе, чтобы обеспечить "цивилизованную" форму перехода в стиле "goto': В языке Java нет оператора "goto'; т.к. 
он обеспечивает возможность ветвления произвольным и неструктурированным образом, что обычно затрудняет понимание и сопровождение кода, опирающегося на переходы в стиле "goto': Кроме того, "goto" препятствует некоторым оптимизациям со стороны компилятора. Тем не менее, есть несколько 
мест, где переходы в стиле "goto" будут ценной и законной конструкцией для 
управления потоком. Например, переход в стиле "goto" может быть полезен 
при выходе из глубоко вложенных циклов. Для обработки таких ситуаций в 
Java определена расширенная форма оператора break. С применением такой 
формы break можно, например, выходить из одного или нескольких блоков 
кода, которые не обязательно должны являться частью цикла или переключателя, а могут быть любыми. Более того, можно точно указывать, где будет 
возобновлено выполнение, т.к. расширенная форма оператора break работает с меткой. Как вы увидите, break обеспечивает преимущества перехода в 
стиле "goto" без присущих ему проблем. 

Чаще всего метка представляет собой имя маркера, идентифицирующего 
блок кода. Блок кода может быть как автономным, так и блоком, являющимся целью другого оператора. При выполнении расширенной формы оператора break поток управления покидает блок, указанный в break. Снабженный 
меткой блок должен охватывать оператор break, но не обязательно быть тем, 
который содержит в себе этот break непосредственно. Отсюда следует, на пример, что оператор break с меткой можно использовать для выхода из набора вложенных блоков. Но применять break для передачи управления из 
блока, который не охватывает данный оператор break, нельзя. 
Чтобы назначить блоку имя, необходимо поместить в его начало метку. 
Метка - это любой допустимый идентификатор Java, за которым следует 
двоеточие. После пометки блока метку можно использовать в качестве цели 
оператора break, что приведет к возобновлению выполнения после конца 
помеченного блока. Например, в показанной далее программе реализованы 
три вложенных блока, каждый со своей меткой. Оператор break передает 
управление вперед, за конец блока с меткой second, пропуская два оператора 
println(). 

[Chapter05/BreakLoop4 - Продемонстрировать пустой while](https://github.com/Vladlena2/BookJava/blob/main/Chapter5/BreakLoop4.java "Посмотреть пример Java")

Имейте в виду, что использовать оператор break с меткой, которая определена не для охватывающего блока, не разрешено. Например, следующая 
программа содержит ошибку и компилироваться не будет: 

```html 
// Эта программа содержит ошибку . 
class BreakErr { 
public static void main(String[] args ) 
one: for (int i=O ; i<З ; i++ ) { 
System.out.print( " Пpoxoд " + i + "· " ) ; 
for (int j = O; j<lOO; j ++) { 
if (j == 10) break one ; // ОШИБКА 
System.out.print (j +" " ) ; 
}
}
}
```

Поскольку цикл, помеченный как one, не охватывает оператор break, передать управление из этого блока невозможно

## Оператор continue

Иногда необходимо обеспечить, чтобы итерация цикла выполнилась 
раньше, до достижения конца тела. То есть выполнение цикла должно продолжаться, но без обработки остатка кода в его теле для конкретной итерации. По сути, это переход в конец цикла. Такое действие реализует оператор 
continue. В циклах while и do-while оператор conti nue передает управление напрямую условному выражению, управляющему циклом. В цикле for 
управление передается сначала итерационной части оператора for, а затем 
условному выражению. Для всех трех циклов любой промежуточный код 
пропускается. 

Как и в случае с break, в операторе continue можно указывать метку для 
описания того, какой объемлющий цик л необходимо продолжить.

## Оператор return 

Последний управляющий оператор - return. Он применяется для явного 
возвращения из метода, т.е. управление программой передается обратно вызывающей стороне. Таким образом, return классифицируется как оператор 
перехода. Хотя подробное обсуждение оператора return следует отложить 
до обсуждения методов в главе 6, здесь представлен его краткий обзор. 
Оператор re turn можно использовать в любом месте метода, чтобы 
возвратить управление вызывающей стороне. Таким образом, оператор 
return немедленно завершает выполнение метода, в котором он находится. 


</details> 

</blockquote>
</details>

<details ГЛАВА 6><summary>ГЛАВА 6. "Введение в классы"</summary>
<blockquote>

Класс лежит в самом центре Java. Он представляет собой логическую конструкцию, на которой построен весь язык Java, потому что она определяет 
форму и природу объекта. Таким образом, класс формирует основу для объектно-ориентированного программирования (ООП) на Java. Любая концепция, которую вы хотите реализовать в программе на Java, должна быть инкапсулирована внутри класса
  
<details><summary>Основы классов</summary>

Вероятно, наиболее важная характеристика класса заключается в том, что 
он определяет новый тип данных. После определения новый тип можно применять для создания объектов такого типа. Следовательно, класс - это шаблон для объекта, а объект - это экземпляр класса. Так как объект является 
экземпляром класса, вы часто будете видеть, что слова объект и экземпляр 
используются взаимозаменяемо. 

При определении класса вы объявляете его точную форму и природу, для 
чего указываете данные, которые он содержит, и код, который работает с этими данными. Код класса определяет интерфейс к своим данным.

Данные, или переменные, определенные в классе, называются переменными 
экземпляра. Код содержится внутри методов. В совокупности методы и переменные, определенные в классе, называются членами класса. В большинстве 
классов переменные экземпляра обрабатываются и доступны с помощью методов, определенных для этого класса. Таким образом, как правило, именно 
методы определяют, как можно использовать данные класса. 

```html 
class Вох { 
douЫe width; 
douЫe height; 
douЫe depth; 
}
```

Как утверждалось выше, класс определяет новый тип данных. В рассматриваемом случае новый тип данных называется Вох. Имя класса будет использоваться для объявления объектов типа Вох. Важно помнить, что объявление класса создает только шаблон, но не фактический объект. Таким образом, предыдущий код не создает никаких объектов типа Вох. 
Чтобы действительно создать объект Вох, будет применяться оператор 
следующего вида: 

```html 
Вох mybox = new Вох ( ); // создать объект Вох по имени mybox
```

[Chapter06/BoxDemo - Программа, использующая класс Box](https://github.com/Vladlena2/BookJava/blob/main/Chapter6/BoxDemo.java "Посмотреть пример Java")

</details> 

<details><summary>Объекты</summary>

Как только что объяснялось, создание класса означает создание нового типа данных, который можно применять для объявления объектов этого 
типа. Однако получение объектов класса представляет собой двухэтапный 
процесс. Во-первых, потребуется объявить переменную типа класса. Такая 
переменная не определяет объект, а просто может ссылаться на объект. Во-вторых, необходимо получить физическую копию объекта и присвоить ее 
этой переменной, для чего служит операция new. Операция new динамически (т.е. во время выполнения) выделяет память для объекта и возвращает 
ссылку на нее, которая по существу является адресом в памяти объекта, выделенной new. Затем ссылка сохраняется в переменной. Таким образом, в Java 
все объекты класса должны размещаться динамически. 

```html 
Вох mybox = new Вох ( ); // создать объект Вох по имени mybox
```

В первой строке переменная mybox объявляется как ссылка на объект типа 
Вох. Пока что mybox не ссылается на фактический объект. Во второй строке 
объекта размещается в памяти и ссылка на него присваивается mybox. После 
выполнения второй строки переменную mybox можно использовать, как если 
бы она была объектом Вох. Но на самом деле mybox просто содержит адрес 
памяти фактического объекта Вох. 

## Подробный анализ операции new 

Важно понимать, что операция new выделяет память для объекта во время 
выполнения. Преимущество этого подхода состоит в том, что ваша программа может создать столько объектов, сколько требуется во время ее выполнения. Однако поскольку память конечна, возможно, что new не сможет выделить память под объект из-за нехватки памяти. В такой ситуации возникает 
исключение времени выполнения. (Вы узнаете, как обрабатывать исключения, в главе 10.) В примерах программ, приводимых в книге, вам не придется 
беспокоиться о нехватке памяти, но нужно будет учитывать эту возможность 
в реальных программах, которые вы будете писать.

Давайте еще раз подчеркнем **различие между классом и объектом**. Класс создает новый тип данных, который можно применять для создания объектов. То есть класс создает логическую инфраструктуру, определяющую отношения между его членами. При объявлении объекта класса создается экземпляр этого класса. Таким образом, класс является логической конструкцией, 
а объект имеет физическую реальность (занимает место в памяти).

## Присваивание для переменных ссылок на объекты 

```html 
Вох b1 = new Вох(); 
Вох Ь2 = b1; 
```

После выполнения данного фрагмента кода переменные b1 и Ь2 будут 
ссылаться на тот же самый объект. Присваивание переменной Ь2 значения b1 
не привело к выделению памяти или копированию какой-либо части исходного объекта. Оно просто заставляет Ь2 ссылаться на тот же объект, что и b1. 
Таким образом, любые изменения, внесенные в объект через переменную Ь2, 
повлияют на объект, на который ссылается b1, поскольку это один и тот же объект.

Хотя переменные b1 и Ь2 относятся к тому же самому объекту, они никак 
не связаны друг с другом. Например, последующее присваивание переменной 
b1 значения nul b1 просто отсоединит Ы от исходного объекта, не затрагивая объект и переменную Ь2.

</details> 

<details><summary>Введение в методы</summary>

Хотя совершенно нормально создавать класс, содержащий только данные, 
такое случается редко. Большую часть времени вы будете использовать методы для доступа к переменным экземпляра, которые определены классом. В действительности методы определяют интерфейс для большинства классов, что позволяет разработчику класса скрыть конкретную реализацию внутренних структур данных за более привлекател ьными абстракциями методов. 

Когда доступ к переменной экземпляра осуществляется кодом, который не входит в состав класса, где определена данная переменная 
экземпляра, то его придется делать через объект с использованием операции 
точки. Тем не менее, когда к переменной экземпляра обращается код, который входит в состав того же класса, что и переменная экземпляра, то на переменную можно ссылаться напрямую. То же самое относится и к методам.

**Параметр** - это переменная, определенная методом, которая получает 
значение при вызове метода. Например, в методе square () параметром является i. 

**Аргумент** - это значение, которое передается методу при его вызове. Например, вызов square (1ОО) передает в качестве аргумента значение 100, которое получает параметр i внутри square(). 

Скажем, довольно легко забыть установить какой-то размер. Во-вторых, в хорошо спроектированных программах на Java доступ к переменным экземпляра должен осуществляться только через методы, определенные их классом

Таким образом, более эффективный подход к установке размеров коробки предусматривает создание метода, который принимает размеры коробки в своих параметрах и соответствующим образом устанавливает каждую переменную экземпляра. 

[Chapter06/BoxDemo3 - В этой программе применяется метод с параметрами](https://github.com/Vladlena2/BookJava/blob/main/Chapter6/BoxDemo3.java "Посмотреть пример Java")

</details> 

<details><summary>Конструкторы</summary>

Конструктор инициализирует объект немедленно после создания. Причина в том, что неявным возвращаемым типом конструктора класса является сам класс. Задача конструктора - инициализировать внутреннее состояние объекта, чтобы код, создающий экземпляр, немедленно получил в свое распоряжение полностью инициализированный и пригодный для использования объект.

Теперь вы понимаете, зачем нужны скобки после имени класса. На самом 
деле происходит вызов конструктора класса. Таким образом, в следующей 
строке:

```html 
Вох myboxl = new Вох(); 
```

Фрагмент new Вох() вызывает конструктор Вох (). Если конструктор для 
класса не определяется явно, тогда компилятор Java создает стандартный конструктор. Вот почему предыдущая строка кода работала в более ранних 
версиях класса Вох, в которых конструктор не определялся. При использовании стандартного конструктора все неинициализированные переменные 
экземпляра будут иметь стандартные значения, которые для числовых типов, 
ссылочных типов и логических значений равны соответственно нулю, null и 
false. Стандартного конструктора часто оказывается достаточно для простых классов, но для более сложных классов он обычно не подходит. После 
определения собственного конструктора стандартный конструктор больше 
не применяется. 

[Chapter06/BoxDemo4 - В классе Box4 применяется параметрзованный конструктор](https://github.com/Vladlena2/BookJava/blob/main/Chapter6/BoxDemo4.java "Посмотреть пример Java")

[Chapter06/BoxDemo5 - В этой программе применяется метод с параметрами](https://github.com/Vladlena2/BookJava/blob/main/Chapter6/BoxDemo5.java "Посмотреть пример Java")

## Ключевое слово this

Иногда метод должен ссылаться на объект, на котором он вызывается. 
Для этого в Java определено ключевое слово this. Его можно использовать 
внутри любого метода для ссылки на текущий объект, т.е. this всегда будет 
ссылкой на объект, на котором был вызван метод. Ключевое слово this можно применять везде, где разрешена ссылка на объект типа текущего класса. 
Чтобы лучше понять, на что ссылается this, взгляните на приведенную 
ниже версию конструктора Вох(): 

```html 
// Избыточное исполь зование this. 
Box (double w, double h, double d){
this.width = w; 
this.height = h; 
this.depth = d;
}
```

## Сокрытие переменных экземпляра

Как вы з наете, в Java запрещено объявлять две локальные переменные с 
одинаковыми именами внутри той же самой или объемлющей облас ти видимости. Интересно отметить, что у вас могут быть локальные переменные, 
в том числе формальные параметры методов, имена которых совпадают с 
именами переменных экземпляра класса. Однако когда локальная переменная имеет такое же имя, как у переменной экземпляра, то локальная переменная скрывает переменную экземпляра. Вот почему width, height и depth не использовались в качестве имен параметров конструктора Вох() внутри класса Вох. Если бы они были выбраны, то имя width, например, ссылалось 
бы на формальный параметр, скрывая переменную экземпляра width. Хотя 
обычно проще применять отличающиеся имена, есть и другой выход из такой ситуации. Поскольку клю чевое слово this позволяет ссылаться прямо 
на объект, его можно использовать для устранения любых конфликтов имен, 
которые могут возникать между переменными экземпляра и локальными переменными. Например, вот еще одна версия конструктора Вох(), в которой 
имена width, height и depth применяются для параметров, а посредством 
this организуется доступ к переменным экземпляра с теми же именами: 

```html 
// Использование this для устранения конфликтов имен. 
Box (double width , double height , double depth) { 
this.width = width; 
this.height = height; 
this.depth = depth ;
}
```

Есть одно предостережение: использование this в таком контексте иногда 
может сбивать с толку. Некоторые программисты стараются не применять 
для локальных переменных и формальные параметров такие имена, которые 
приводят к сокрытию переменных экземпляра. Раз умеется, другие программисты уверены в обратном: они полагают, что использование тех же самых 
имен делает код яснее и применяют this для преодоления сокрытия переменных экземпляра. То, какой подход вы выберете - дело личного вкуса.

</details> 

<details><summary>Сборка мусора</summary>

Поскольку объекты динами чески размещаются в памяти с помощью операции new, вас может интересовать, каким образом такие объекты уни чтожаются, и занимаемая ими память освобождается с целью последующего выделения. В языках, подобных традиционному С++, динами чески размещенные объекты необходимо освобождать вру чную с помощью операци и delete. 
В Java используется другой подход; освобождение померживается автоматически. Методика, которая позволяет это делать, называется сборкой мусора. 
Она работает следующим образом: когда ссылок на объект не существует, то 
с читается, что такой объект больше не нужен, и занимаемая им память может 
быть освобождена. Нет необходимости явно уни чтожать объекты. Сборка 
мусора происходит нерегулярно (если вообще происходит) во время выполнения программы. Она не инициируется просто потому, что существует один или несколько объектов, которые больше не использ уются. Кроме того, в разных реализациях исполняющей среды Java будут применяться варьирующиеся подходы к сборке мусора, но по большей части вам не придется думать о ней при написании своих программ. 

</details> 

<details><summary>Класс Stack</summary>

Стек сохраняет данные по принципу "последний пришел - первым обслужен'; т.е. 
стек подобен стопке тарелок на столе: первая тарелка, поставленная на стол, 
используется последней. Стеки управляются с помощью двух операций, традиционно называемых помещением и извлечением. Чтобы сохранить элемент на верхушке стека, будет применяться помещение. Чтобы взять элемент из стека, будет использоваться извлечение. Как вы увидите, инкапсулировать полный механизм стека несложно.

[Chapter06/Stack - Реализация класса Stack](https://github.com/Vladlena2/BookJava/blob/main/Chapter6/Stack.java "Посмотреть пример Java")

[Chapter06/TestStack - Применение класса Stack](https://github.com/Vladlena2/BookJava/blob/main/Chapter6/TestStack.java "Посмотреть пример Java")

</details> 
  
</blockquote>
</details>

<details ГЛАВА 7><summary>ГЛАВА 7. "Подробный анализ методов и классов"</summary>
<blockquote>

<details><summary>Перегрузка методов</summary>
  
Язык Java разрешает определять в одном классе два и более метода, которые имеют одно и то же имя, если их объявления параметров отличаются. 
В таком случае говорят, что методы перегружены, а сам процесс называется 
перегрузкой методов. Перегрузка методов - один из способов помержки полиморфизма в Java.

При вызове перегруженноrо метода компилятор Java использует тип и/или 
количество аргументов в качестве ориентира, чтобы определить, какую версию переrруженноrо метода фактически вызывать. Таким образом, перегруженные методы должны отличаться типом и/или количеством параметров. 
Хотя перегруженные методы могут возвращать разные типы, одного типа 
возвращаемого значения недостаточно, чтобы различить две версии метода. 
Коrда компилятор Java встречает вызов переrруженноrо метода, он просто 
выполняет версию метода, параметры которой соответствуют аргументам, 
указанным в вызове.

Ниже приведен простой пример, иллюстрирующий перегрузку методов:

[Chapter07/OverloadDemo - Продемонстрировать перегрузку методов](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/OverloadDemo.java "Посмотреть пример Java")

При вызове перегруженного метода компилятор Java ищет соответствие 
между аргументами, используемыми для вызова метода, и параметрами метода. Однако это совпадение не всегда должно быть точным. В некоторых случаях 
автоматическое преобразование типов в Java может играть роль в распознавании перегруженных методов. Например, взгляните на следующую программу: 

[Chapter07/OverloadDemo2 - Применить автоматическое преобразование типов к перегрузке](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/OverloadDemo2.java "Посмотреть пример Java")

Легко заметить, что в данной версии OverloadDemo метод test(int) не 
определен. Тогда при вызове test() с целочисленным аргументом внутри 
Overload подходящая версия метода не будет найдена. Тем не менее, компилятор Java способен автоматически преобразовывать целое число в число 
типа double, и такое преобразование можно использовать для распознавания 
вызова. Поэтому после того, как test(int) не найден, компилятор Java повышает i до double и затем вызывает test(douЬle) . Конечно, если бы версия 
test(int) была определена, то именно она была бы вызвана. Компилятор 
Java задействует свои автомати ческие преобразования типов только при отсутствии точного совпадения. 
Перегрузка методов поддерживает полиморфизм, т.к. он представляет собой один из способов, которым в Java реализуется парадигма "один интерфейс, несколько методов": Давайте выясним, каким образом. В языках, не 
поддерживающих перегрузку методов, каждому методу должно быть назначено уникальное имя. Однако часто вам потребуется реализовать по существу один и тот же метод для разных типов данных. Рассмотрим функцию для абсолютного значения. В языках, не померживающих перегрузку, обычно существует три или более версий такой функции, каждая из которых имеет 
слегка отличающееся имя. Например, в языке С функция abs() возвращает 
абсолютное значение целого числа, labs() - абсолютное значение длинного 
целого числа, а fabs() - абсолютное значение значения с плавающей точкой. Поскольку перегрузка в С не поддерживается, каждая функция имеет собственное имя, хотя все три функции выполняют, по сути, одну и ту же 
работу, что делает ситуацию концептуально более сложной, чем она есть на 
самом деле. Хотя базовая концепция каждой функции одна и та же, вам нужно запомнить все три имени. В языке Java ситуация подобного рода не возникает, потому что каждый метод для абсолютного значения может иметь одно и то же имя. Действительно, стандартная библиотека классов Java включает метод получения абсолютного значения, называемый abs(). Этот метод перегружен в классе Math для обработки всех числовых типов. Компилятор Java 
определяет, какую версию abs() вызывать, основываясь на типе аргумента. 

Ценность перегрузки обусловлена тем, что она позволяет получить доступ 
к связ анным методам с применением общего имени. Таким образом, имя abs 
представляет выполняемое общее действие. Выбор правильной конкретной 
версии в сложившихся обстоятельствах возлагается на компилятор. Вам как 
программисту достаточно лишь запомнить общую выполняемую операцию. 
Благодаря полиморфизму несколько имен были сведены в одно.

В случае перегрузки метода каждая его версия может выполнять любые 
желаемые действия. Нет правила, утверждающего о том, что перегруженные 
методы должны быть связаны друг с другом. Тем не менее, со стилистической точки зрения перегрузка методов подразумевает наличие взаимоотношения между ними. Таким образом, хотя и допускается использовать одно и то же имя для перегрузки несвяз анных методов, вы не должны поступать так. Скажем, вы можете выбрать имя sqr при создании методов, возвращающих 
квадрат целого числа и квадратный корень значения с плавающей запятой. 
Но эти две операции принципиально разные. Применение перегрузки метода 
в подобной манере противоречит его первоначальной цели. На практике следует перегружать только тесно связанные операции. 

</details> 

<details><summary>Перегрузка конструкторов</summary>

Наряду с перегрузкой обычных методов можно также выполнять перегрузку методов-конструкторов.
В качестве параметров объекты чаще всего употребляются в конструкторах. Нередко новый объект приходится создавать таким образом, чтобы он первоначально ничем не отличался от уже существующего объекта. Для этого придется определить конструктор, принимающий в качестве параметра объект своего класса. Например, очередная версия класса Вох позволяет инициализировать один объект другим.

[Chapter07/BoxDemo01 - В этой версии класса Вох один объект допускается инициализировать другим объектом](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/BoxDemo01.java "Посмотреть пример Java")

</details> 

<details><summary>Использование объектов в качестве параметров</summary>

До сих пор в качестве параметров методов применялись только простые 
типы. Однако передача объектов методам является правильной и распространенной практикой. Например, возьмем показанную далее короткую программу: 

[Chapter07/PassOb - Передача объектов методам](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/PassOb.java "Посмотреть пример Java")

Как видите, метод equalTo() внутри Test сравнивает два объекта на 
предмет равенства и возвращает результат, т.е. он сравнивает вызывающий 
объект с тем, который ему передается. Если они содержат одинаковые значения, тогда метод возвращает true. В противном случае возвращается false. 
Обратите внимание, что параметр о в equalTo() указывает Test в качестве 
своего типа. Хотя Test - тип класса, созданный программой, он используется точно так же, как и встроенные типы Java. 

Одно из наиболее распространенных применений параметров объекта 
связано с конструкторами. Часто требуется создать новый объект так, чтобы 
он изначально был таким же, как какой-то существующий объект. Для этого необходимо определить конструктор, который принимает объект своего 
класса в качестве параметра. Например, следующая версия Вох позволяет одному объекту инициализировать другой: 

[Chapter07/OverloadCons2 - Конструктор, который принимает объект своего 
класса в качестве параметра](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/OverloadCons2.java "Посмотреть пример Java")

</details> 

<details><summary>Подробный анализ передачи аргументов</summary>

Говоря в общем, в языках программирования существуют два способа, которыми можно передавать аргумент подпрограмме. Первый способ - вызов 
по значению, при котором в формальный параметр подпрограммы копируется 
значение аргумента, поэтому изменения, вносимые в параметр подпрограммы, не влияют на аргумент. Второй способ - вызов по ссылке. При таком подходе в параметр передается ссылка на аргумент(а не его значение). Внутри 
подпрограммы эта ссылка используется для доступа к фактическому аргументу, указанному в вызове, т.е. изменения, вносимые в параметр, повлияют на аргумент, который применялся при вызове подпрограммы. 

Когда методу передается примитивный тип, то происходит передача по 
значению. Таким образом, создается копия аргумента, и все то, что делается 
с параметром, получающим аргумент, не имеет никакого эффекта вне метода. 

[Chapter07/CallByValue - Первый способ - вызов 
по значению](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/CallByValue.java "Посмотреть пример Java")

Как видите, операции, выполняемые внутри meth(), не влияют на значения 
а и b, используемые в вызове; их значения здесь не изменились на 30 и 10. 

Когда методу передается объект, ситуация кардинально меняется, потому 
что объекты передаются посредством того, что фактически называется вызовом по ссылке. Имейте в виду, что при создании переменной типа класса создается только ссылка на объект. Таким образом, когда такая ссылка передается методу, то параметр, который ее получает, будет ссылаться на тот же объект, на который ссылается аргумент. Фактически это означает, что объекты действуют так, будто они передаются методам с помощью вызова по 
ссылке. Изменения объекта внутри метода влияют на объект, указанный в 
качестве аргумента.

[Chapter07/PassObjRef - Второй способ - вызов по ссылке](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/PassObjRef.java "Посмотреть пример Java")

При передаче методу ссылки на объект сама ссылка передается с применением вызова по 
значению. Но поскольку передаваемое значение относится к объекту, копия этого значения 
по-прежнему будет ссылаться на тот же объект, что и соответствующий аргумент. 

</details> 

<details><summary>Возвращение объектов</summary>
  
Метод способен возвращать данные любого типа, включая типы классов, которые вы создаете. Например, в приведенной далее программе метод incrByTen() возвращает объект, в котором значение а на 1О больше, чем в вызывающем объекте. 

[Chapter07/RetOb2 - Возвращение объектов](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/RetOb2.java "Посмотреть пример Java")

Как видите, каждый раз, когда вызывается incrByTen() , создается новый 
объект, а вызывающей процедуре возвращается ссылка на него. 
В предыдущей программе продемонстрирован еще один важный момент: 
поскольку все объекты динамически размещаются с помощью операции new, 
вам не нужно беспокоиться о том, что объект выйдет за пределы области 
видимости, т.к. метод, в котором он был создан, завершается. Объект будет 
продолжать существовать до тех пор, пока в программе где-то есть ссылка на 
него. Когда ссылки на него исчезнут, занимаемая объектом память освободится при очередной сборке мусора.

</details> 

<details><summary>Рекурсия</summary>

В языке Java померживается рекурсия - процесс определения чего-либо в 
терминах самого себя. Что касается программирования на Java, то рекурсия 
является характерной чертой, позволяющей методу вызывать самого себя. 
Метод, который вызывает сам себя, называется рекурсивным. 
Классическим примером рекурсии считается вычисление факториала 
числа. Факториал числа N - это произведение всех целых чисел от 1 до N. 
Например, факториал 3 равен 1 х 2 х 3, или 6. 

[Chapter07/Recursion05 - Простой пример рекурсии (вычисление Факториала)](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/Recursion05.java "Посмотреть пример Java")

Когда метод вызывает сам себя, новые локальные переменные и параметры размещаются в стеке, а код метода выполняется с этими новыми переменными с самого начала. При возврате из каждого рекурсивного вызова старые локальные переменные и параметры удаляются из стека, и выполнение 
возобновляется в точке вызова внутри метода. Можно сказать, что рекурсивные методы работают в стиле "раздвижения" и "складывания" подзорной 
трубы. 
Рекурсивные версии многих подпрограмм могут выполняться немного 
медленнее своих итеративных эквивалентов из-за добавочных накладных 
расходов на дополнительные вызовы методов. Большое количество рекурсивных вызовов метода может привести к переполнению стека. Поскольку 
хранилище для параметров и локальных переменных находится в стеке, и 
каждый новый вызов создает новую копию этих переменных, вполне возможно, что стек исчерпается. В таком случае исполняющая среда Java инициирует 
исключение. Тем не менее, как правило, проблема не возникает, если рекурсивная подпрограмма не выходит из-под контроля. 
Главное преимущество рекурсивных методов связано с тем, что их можно 
использовать для создания более ясных и простых версий ряда алгоритмов, 
чем их итеративные аналоги. Скажем, алгоритм быстрой сортировки довольно сложно реализовать итеративным способом. Кроме того, некоторые типы 
алгоритмов из области искусственного интеллекта проще всего реализовать 
с помощью рекурсивных решений. 
При написании рекурсивных методов вы должны где-то предусмотреть 
оператор if, чтобы заставить метод выполнить воз врат без рекурсивного 
вызова. Если вы этого не сделаете, то после вызова возврат из метода никогда не произойдет. Такая ошибка весьма распространена, когда приходится 
иметь дело с рекурсией. Свободно применяйте операторы println() во время разработки, чтобы вы могли следить за происходящим и прерывать выполнение, если видите, что допустили ошибку. 

[Chapter07/Recursion06 - Еще один пример рекурсии](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/Recursion06.java "Посмотреть пример Java")

</details> 

<details><summary>Введение в управление доступом</summary>

При правильной реализации класс создает "черный ящик", с которым можно взаимодействовать, но нарушить его внутреннюю работу не удастся.

Доступ к члену определяется модификатором доступа, присоединенным 
к ero объявлению. Язык Java предлагает богатый набор модификаторов доступа. Некоторые аспекты управления доступом в основном связаны с наследованием или пакетами. (Пакет по существу представляет собой группу классов)

Модификаторами доступа Java являются public(открытый), private(закрытый) и protected (защищенный). В Java также определен стандартный уровень доступа. Модификатор доступа protected применяется, только когда задействовано наследование. Другие модификаторы доступа описаны далее. 
Давайте начнем с определения pablic и private. Когда член класса изменяется с помощью public, доступ к нему может получать любой другой код. 
Kor да член класса указан как privаte, доступ к нему могут пол учать только 
другие члены этого класса. Теперь вы понимаете, почему объявлению метода 
main() всегда предшествовал модификатор public. Он вызывается кодом, 
находящимся вне программы, т.е. исполняющей средой Java. Если модификатор доступа не задействован, то по умолчанию член класса является открытым в своем пакете, но к нему нельзя получить доступ за пределами пакета. (Пакеты обсуждаются в главе 9.) 

[Chapter07/TestAccess07 - Демонстрация модификаторов доступа](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/TestAccess07.java "Посмотреть пример Java")

Как видите, внутри класса Test применяется стандартный доступ, что в 
данном примере равнозначно указанию public. Член b явно определен как 
puЫic, а член с - как private. Это означает, что доступ к члену с в коде за 
пределами его класса невозможен. Таким образом, внутри класса AccessTest 
член с нельзя использовать напрямую. Доступ к нему должен осуществляться через его открытые методы: setc() и getc().

Чтобы увидеть, как применить управление доступом к более реальному 
примеру, рассмотрим показанную в конце главы 6 усовершенствованную версию класса Stack: 

[Chapter07/StackTest08 - Пример, усовершенствованной версии класса Stack](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/StackTest08.java "Посмотреть пример Java")

</details> 

<details><summary>Ключевое слово static</summary>

Временами вам понадобится определять чл ен класса, который будет применяться независимо от любого объекта данного класса. Обычно доступ 
к члену класса должен осуществляться только в сочетании с объектом его 
класса. Однако можно создать член, который можно использовать сам по 
себе, без привязки к конкретному экземпляру. Чтобы создать такой элемент, 
перед его объявл ением следует указать ключевое слово static(статический). 
Когда член объявляется статическим, к нему можно получать доступ до того, 
как будут созданы какие-либо объекты его класса, и без ссылки на какой-либо объект. Объявить статическими можно как методы, так и переменные. 
Наиболее распространенным примером статического члена является метод 
main(), который объявлен как static, потому что он должен быть вызван до 
того, как будут созданы любые объекты. 
Переменные экземпляра, объявленные как static, по существу являются 
глобальными переменными. При объявлении объектов такого класса копия 
статической переменной не создается. Взамен все экземпляры класса имеют 
дело с одной и той же статической переменной. 

С методами, объявленными как static, связано несколько ограничений. 
• Они могут напрямую вызывать только другие статические методы своего класса. 
• Они могут напрямую получать доступ только к статическим переменным своего класса. 
• Они никоим образом не могут ссылаться на this или super. (Ключевое 
слово super относится к наследованию и описано в следующей главе.) 

Если для инициализации статических переменных нужно выполнять вычисления, тогда можно объявить блок static, который выполняется в точности один раз, когда класс загружается впервые. В примере ниже показан класс со статическим методом, несколькими статическими переменными и статическим блоком инициализации

[Chapter07/UseStatic09 - В этой версии класса Вох один объект допускается инициализировать другим объектом](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/UseStatic09.java "Посмотреть пример Java")

Как только загружается класс UseStatic09, выполняются все статические операторы.
Сначала в переменной а устанавливается значение 3, затем выполняется
статический блок кода, в котором выводится сообщение, а переменная Ь инициализируется
значением а*4, т.е. 12. После этого вызывается метод main(), который, в свою очередь,
вызывает метод meth(),передавая параметру х значение 42.
В трех вызовах метода println () делаются ссылки на две статические переменные, а и Ь,
а также на локальную переменную х. 

За пределами класса, в котором определены статические методы и переменные, ими можно пользоваться независимо от любого объекта. Для этого достаточно указать имя их класса через операцию-точку непосредственно перед их именами. Так, если требуется вызвать статический метод за пределами его класса, это можно сделать, используя следующую общую форму:

```html 
имя_класса.метод()
```

Здесь имя_класса обозначает имя того класса, в котором объявлен статический метод. Как видите, эта форма аналогична той, что применяется для вызова нестатических методов через переменные ссылки на объекты. Аналогично для доступа к статической переменной ее имя следует предварить именем ее класса через операцию-точку. Именно так в Java реализованы управляемые версии глобальных методов и переменных.

Обратимся к конкретному примеру. В теле метода main() обращение к статическому методу callme() и статической переменной "b" осуществляется по имени их класса "UseStatic09":

[Chapter07/StaticByName - В этой версии класса Вох один объект допускается инициализировать другим объектом](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/StaticByName.java "Посмотреть пример Java")

</details> 

<details><summary>Ключевое слово final</summary>
  
Поле может быть объявлено как final(финальное), что предотвращает 
изменение его содержимого, делая его по существу константой. Это означает, что поле final должно быть инициализировано при его объявлении. 
Существуют два способа инициализации такого поля. Во-первых, полю final 
можно присвоить значение при его объявлении. Во-вторых, полю final можно присвоить значение в конструкторе.

```html 
final int FILE_NEW = 1; 
final int FILE_OPEN = 2; 
final int FILE_SAVE = 3; 
final int FILE_SAVEAS = 4 ; 
final int FILE_QUIT = 5;
```

Как показано в примере, общепринятое соглашение при 
написании кода предусматривает выбор для полей final идентификаторов 
со всеми буквами верхнего регистра. 
Помимо полей как final могут быть объявлены и параметры метода, и 
локальные переменные. Объявление параметра как final предотвращает его 
изменение внутри метода. Объявление локальной переменной как final предотвращает присваивание ей значения более одного раза. 
Ключевое слово final также может применяться к методам, но его смысл 
существенно отличается от того, когда оно применяется к переменным. Такое 
дополнительное использование final объясняется в следующей главе при 
описании наследования. 

</details> 

<details><summary>Массивы</summary>

Массивы были представлены ранее в книге, еще до обсуждения классов. 
Теперь, когда вы ознакомились с классами, можно сделать важное замечание 
о массивах: они реализованы в виде объектов.

В частности, размер массива, т.е. количество элементов, которые может содержать массив, находится в его переменной экземпляра length. В частности, размер массива, т.е. количество элементов, которые может содержать массив, находится в его переменной экземпляра length. 

[Chapter07/StackTest10 -Усовершенствованный класс Stack, в котором используется свойство длины массива](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/StackTest10.java "Посмотреть пример Java")

Как видите, в выводе отображается размер каждого массива. Имейте в 
виду, что значение length не имеет ничего общего с количеством фактически 
используемых элементов. Оно отражает только количество элементов, для 
хранения которых проектировался массив. 
Вы можете найти хорошее применение члену length во многих ситуациях. 
Например, далее показана усовершенствованная версия класса Stack. Как вы 
помните, ранние версии класса Stack всегда создавали стек из десяти элементов. Новая версия позволяет создавать стеки любого размера. Переполнение 
стека предотвращается с применением значения stack.length.

</details> 

<details><summary>Вложенные и внутренние классы</summary>

Класс можно определять внутри другого класса; такой класс известен как вложенный класс. Область действия вложенного класса ограничена областью действия его объемлющего класса. Таким образом, если класс B определен внутри класса A, то B не существует независимо от A. Вложенный класс имеет доступ к членам, в том числе закрытым, класса, в который он вложен. Тем не менее, объемлющий класс не имеет доступа к членам вложенного класса. Вложенный класс, объявленный непосредственно в области действия его объемлющего класса, будет членом объемлющего класса. Также можно объявлять вложенный класс, локальный для блока.

Существуют два типа вложенных классов: статические и нестатические. Статический вложенный класс - это класс, к которому применяется модификатор static. Поскольку класс статический, он должен обращаться к нестатическим членам объемлющего класса через объект. То есть статический вложенный класс не может напрямую ссылаться на нестатические члены объемлющего класса.

Вторым типом вложенного класса является внутренний класс. Внутренний класс - это нестатический вложенный класс. Он имеет доступ ко всем переменным и методам своего внешнего класса и может ссылаться на них напрямую, так же как поступают другие нестатические классы.

В следующей программе иллюстрируется определение и использование 
внутреннего класса. Класс по имени Outer имеет одну переменную экземпляра по имени external_x, один метод экземпляра с именем test() и определяет один внутренний класс по имени

[Chapter07/InnerClassDemo11 - Продемонстрировать применение внутреннего класса](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/InnerClassDemo11.java "Посмотреть пример Java")

 В данной программе внутренний класс Inner определен в области действия
класса Outer. Поэтому любой код из класса Inner может непосредственно обращаться
к переменной outer_x. Метод экземпляра display() определен в классе Inner.
Этот метод выводит значение переменной outer_x в стандартный поток вывода.
В методе main() из класса InnerClassDemo создается экземпляр класса Outer и
вызывается его метод test().А в этом методе создается экземпляр класса Inner
и вызывается метод display().
Следует иметь в виду, что экземпляр класса Inner может быть создан только
в контексте класса Outеr.

Хотя мы сосредоточились на внутренних классах, объявленных в виде членов в области действия внешнего класса, внутренние классы можно определять в рамках области действия любого блока. Например, вложенный класс можно определить в блоке, который определен внутри метода, или даже в теле цикла for, как показано в следующем примере программы:

[Chapter07/InnerClassDemo13 - В этой версии класса Вох один объект допускается инициализировать другим объектом](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/InnerClassDemo13.java "Посмотреть пример Java")

Интересно отметить, что вложенные классы не были разрешены в исходной спецификации Java 1.0, а появились в Java 1.1

</details> 

<details><summary>Исследование класса String</summary>

Первое, что нужно понять о строках: каждая создаваемая вами строка на самом деле является объектом типа String. Даже строковые константы фактически представляют собой объекты String. Например, в следующем операторе строка "Это тоже строка" является объектом String:

```html 
System.out.println("Этo тоже строка"); 
```

Объекты типа String неизменяемы; после создания объекта String его содержимое нельзя модифицировать. Хотя это ограничение может показаться серьезным, оно не так важно по двум причинам.

- Если вам необходимо изменить строку, то вы всегда можете создать новую строку, отражающую изменения.
- В Java существуют классы StringBuilder и StringBuffer, которые предоставляют возможность изменять строки, поэтому в Java по-прежнему доступны все обычные операции со строками. (Классы StringBuilder и StringBuffer описаны в части II книги.)

Строки можно конструировать различными способами. Проще всего применять оператор такого вида:

```html 
String myString = "это просто тест";  
```

После создания объекта String, его можно использовать везде, где разрешена строка. 

Для объектов String в Java определена операция конкатенации строк, которая использует оператор "+". Следующий оператор конкатенирует строку "Мне нравится язык Java" с переменной myString:

```html 
myString = myString + "Мне нравится язык Java."; 
```

Класс String содержит нескол ько методов, которыми можно пользоваться. Рассмотрим несколько из них. Две строки можно проверить на предмет 
равенства с применением метода equals() . Вызвав метод length(), можно 
получить длину строки, а вызвав метод charAt() можно извлечь символ по 
указ анному индексу в строке.

[Chapter07/StringDemo14 - Продемонстрировать некоторые методы из класса String](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/StringDemo14.java "Посмотреть пример Java")

[Chapter07/StringDemo15 - Продемонстрировать применение массивов объектов типа String](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/StringDemo15.java "Посмотреть пример Java")

Все аргументы командной строки передаются в строковом виде. Как будет объяснено в 
главе 19, числовые значения придется вручную преобразовывать в их внутренние формы. 

</details> 

<details><summary>Аргументы переменной длины</summary>

В состав современных версий Java входит средство, упрощающее создание методов, которые должны принимать произвольное количество аргументов. Оно называется аргументами переменной длины (variable-length arguments - varargs). Метод, принимающий произвольное число аргументов, называется методом с переменной арностью или методом с аргументами переменной длины.

Ситуации, когда методу требуется передавать произвольное число аргументов, не являются чем-то необычным. Метод, который открывает подключение к Интернету, например, может принимать имя пользователя, пароль, имя файла, протокол и т.д., и предоставлять стандартные значения, если часть этой информации не была указана. В такой ситуации было бы удобно передавать только те аргументы, к которым не применяются стандартные значения. Другим примером может служить метод printf(), который является частью библиотеки ввода-вывода Java. Как вы увидите в главе 22, он принимает произвольное количество аргументов, форматирует их и затем отображает.

В ранних версиях Java аргументы переменной длины можно было поддерживать двумя способами, ни один из которых нельзя считать удобным. Первый способ, подходящий в ситуации, когда максимальное количество аргументов является небольшим и известным, предусматривал создание перегруженных версий метода, по одной для каждого варианта вызова метода. Хотя подобный подход работает и подходит в ряде случаев, он применим только к узкому набору ситуаций.

В тех случаях, когда максимальное количество потенциальных аргументов было большим или неизвестным, использовался второй подход, который заключался в помещении аргументов в массив, который затем передавался методу. Данный подход все еще встречается в унаследованном коде и иллюстрируется ниже:

[Chapter07/UseArrayToPassVariableToMethod16 - Использовать массив для передачи методу переменной количество аргументов](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/UseArrayToPassVariableToMethod16.java "Посмотреть пример Java")

Аргументы передаются методу vaTest() через массив v. Такой подход в старом стиле позволяет vaTest() принимать произвольное количество аргументов. Однако он требует, чтобы перед вызовом метода vaTest() аргументы вручную упаковывались в массив. Создание массива при каждом вызове vaTest() не только утомительно, но и потенциально подвержено ошибкам. Средство аргументов переменной длины предлагает более простой и совершенный вариант.

Аргумент переменной длины определяется с помощью трех точек (...). Например, вот как определить метод vaTest() с применением аргумента переменной длины:

```html 
static void vaтest(int ... v)
```

Этот синтаксис сообщает компилятору, что метод vaTest() можно вызывать с нулем или большим числом аргументов. В результате v неявно объявляется как массив типа int[]. Таким образом, внутри vaTest() доступ к v осуществляется с использованием обычного синтаксиса массива.

[Chapter07/VarArgs17 - Продемонстрировать применение аргументов переменной длины](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/VarArgs17.java "Посмотреть пример Java")

В приведенной выше программе следует отметить два важных момента. Во-первых, переменная v в методе vaTest() обрабатывается как массив. Фактически, v и является массивом. Синтаксис ... просто сообщает компилятору, что будет использоваться переменное число аргументов, причем аргументы будут храниться в массиве, на который ссылается v. Во-вторых, метод vaTest() вызывается внутри main() с разным количеством аргументов, включая вариант вообще без аргументов. Аргументы автоматически помещаются в массив и передаются v. При отсутствии аргументов длина массива равна нулю.

Наряду с параметром переменной длины, метод может иметь и "обычные" параметры. Тем не менее, параметр переменной длины должен объявляться в методе последним. Скажем, следующее объявление метода совершенно допустимо:

```html 
int doit( int а, int Ь, douЫe с, i nt ... val s) { 
```

В этом случае первые три аргумента, указанные в вызове doit(), сопоставляются с первыми тремя параметрами, а все остальные аргументы считаются относящимися к vals

```html 
int doit(int а, int Ь, douЫe с, int ... vals, boolean stopFlag ) { // Ошибка!
```

Существует еще одно ограничение, о котором следует помнить: должен 
быть только один параметр переменной длины. Скажем, приведенное ниже 
объявление тоже будет ошибочным:

```html 
int doit(int а, int Ь, douЫe с, int ... val s , douЬle ... moreval s) { // Ошибка!
```

Объявлять второй параметр переменной длины не разрешено. 
Вот переработанная версия метода vaTest(), которая принимает обычный аргумент и аргумент переменной длины: 

[Chapter07/VarArgs18 - Продемонстрировать применение аргументов переменной длины](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/VarArgs18.java "Посмотреть пример Java")

## Перегрузка методов с аргументами переменной длины
  
Метод, принимающий аргумент переменной длины, можно перегружать. 
Например, в показанной далее программе метод vaTest() перегружается три 
раза:

[Chapter07/VarArgs19 - Аргументы переменной длины и перегрузка](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/VarArgs19.java "Посмотреть пример Java")

Метод с аргументом переменной длины также может быть перегружен за счет определения метода без аргумента переменной длины. В приведенной выше программе, vaTest(int x) является допустимой версией vaTest(). Эта версия вызывается только при наличии одного аргумента типа int. Когда передаются два или более аргумента типа int, используется версия vaTest(int... v) с аргументом переменной длины. Таким образом, метод может иметь несколько перегруженных версий для разных сценариев вызова.

## Аргументы переменной длины и неоднозначность 

При перегрузке метода, принимающего аргумент переменной длины, могут возникать несколько неожиданных ошибок. Такие ошибки связаны с неоднозначностью, поскольку существует возможность создать двусмысленный вызов перегруженного метода с аргументами переменной длины.

[Chapter07/VarArgs20 - Аргументы переменной длины, перегрузка и Неоднозначность](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/VarArgs20.java "Посмотреть пример Java")

В этой программе перегрузка метода vaTest() совершенно корректна, но 
программа не скомпилируется из-за такого вызова: 

```html 
vaTest(); // Ошибка: Неоднозначность! 
```

vaTest(); - вызов метода vaTest без аргументов может вызвать ошибку "Неоднозначность", если есть несколько версий метода, подходящих для вызова. В этом случае компилятор не может определить, какую из перегруженных версий следует вызвать, так как нет явного указания на конкретный метод.

Чтобы избежать неоднозначности, необходимо предоставить дополнительную информацию или явно указать, какую версию метода вы хотите вызвать.

```html 
static void vaTest( int ... v) { 
static void vaTest(int n, int v) { 
```

Несмотря на различие в списках параметров vaTest(), компилятор не 
сможет распознать следующий вызов:

```html 
vaTest(l) 
```

Данный вызов vaTest(); вызывает неоднозначность, и компилятор не сможет определить, в какой метод он должен преобразоваться. Это происходит из-за того, что вызов без аргументов может соответствовать как методу vaTest(int...) с одним аргументом переменной длины, так и методу vaTest(int, int...) без аргументов переменной длины.

Из-за ошибок неоднозначности, подобных показанным, иногда вам придется отказаться от перегрузки методов и просто использовать методы с разными именами. Это избегает конфликта и делает код более явным. Кроме того, в ряде случаев ошибки неоднозначности могут указывать на концептуальные дефекты в коде, которые могут потребовать более тщательной проработки решения.

</details> 

<details><summary>Выведение типов локальных переменных для ссылочных типов</summary>

Как упоминалось в главе 3, начиная с версии JDK 10, в Java поддерживается выведение типов локальных переменных. Вспомните, что при выведении типов локальных переменных тип переменной указывается как var, а переменная должна быть инициализирована. В более ранних примерах выведение типов демонстрировалось с примитивными типами, но его также можно применять со ссылочными типами. Фактически, основное использование выведения типов связано со ссылочными типами. Вот простой пример, в котором объявляется строковая переменная с именем myStr:

```html 
var myStr = "Пример строки";
```

Из-за использования строки в кавычках в качестве инициализатора для переменной myStr, тип String выводится автоматически.

Как объяснялось в главе 3, одно из преимуществ выведения типов локальных переменных связано с его способностью оптимизировать код, и такая оптимизация наиболее очевидна именно со ссылочными типами. Причина в том, что многие классы в Java имеют довольно длинные имена. Например, в главе 13 вы узнаете о классе FileInputStream, который используется для открытия файлов для операций ввода. В прошлом, объект FileInputStream объявлялся и инициализировался с использованием традиционного объявления, подобного приведенному ниже:

```html 
FileInputStream fileInputStream = new FileInputStream("example.txt");
```

С использованием выведения типов, это можно упростить до:

```html 
var fileInputStream = new FileInputStream("example.txt");
```

Тут предполагается, что переменная fin имеет тип FileInputStream, так как это тип её инициализатора. Нет никакой необходимости явно повторять имя типа. В результате, такое объявление fin значительно короче, чем его запись традиционным способом, и потому применение var упрощает объявление.

Это преимущество становится еще более очевидным в более сложных объявлениях, включая объявления с обобщениями. В целом, упрощение выведения типов локальных переменных помогает уменьшить избыточное использование длинных имен типов в программах.

Разумеется, аспект упрощения кода со стороны выведения типов локальных переменных должен использоваться осмотрительно, чтобы не ухудшить читаемость программы и не скрыть её намерения. Например, рассмотрим следующее объявление:

```html 
var х = о.getNext(); 
```

Выведение типов локальных переменных можно также использовать в отношении пользовательских классов, как показано в ниже приведенной программе. В ней создается класс с именем MyClass, а затем с использованием выведения типов локальных переменных объявляется и инициализируется объект этого класса.

[Chapter07/RefVarDemo - Локальные переменные в отношении пользовательских классов](https://github.com/Vladlena2/BookJava/tree/main/Chapter7/RefVarDemo.java "Посмотреть пример Java")

Тип переменной mc будет выводиться как MyClass, потому что это тип 
инициализатора, который является новым объектом MyClass.
</details>

</blockquote>
</details>

<details ГЛАВА 8><summary>ГЛАВА 8. "Наследование"</summary>
<blockquote>

Наследование является одним из краеугольных камней объектно-ориентированного программирования (ООП), поскольку позволяет создавать иерархические классификации. С использованием наследования вы можете создать универсальный класс, который определяет характерные черты, общие для набора связанных элементов. Затем этот класс может быть унаследован 
другими, более специфическими классами, каждый из которых добавляет те 
элементы, которые уникальны для него. В терминологии Java унаследованный 
класс называется суперклассом, а класс, выполняющий наследование - подклассом. Следовательно, подк ласс представляет собой специализированную 
версию суперкласса. Он наследует все члены, определенные суперклассом, и 
добавляет собственные уникальные элементы. 

<details><summary>Основы наследования</summary>

Чтобы наследовать класс, вы просто включаете определение одного класса 
в другой с применением ключевого слова extends.

[Chapter08/SimpleInheritance01 -  Простой пример наследования](https://github.com/Vladlena2/BookJava/tree/main/Chapter8/SimpleInheritance01.java "Посмотреть пример Java")

Как видите, подкласс В включает в себя все члены своего суперкласса А. Вот почему объект subOb может получать доступ к i и j и вызывать 
showij(). Кроме того, внутри sum() на i и j можно ссылаться напрямую, как 
если бы они были частью В. 
Несмотря на то что А выступает в качестве суперкласса для В, он также 
является полностью независимым, автономным классом. Быть суперклассом 
для подкласса не означает, что суперкласс не может использоваться сам по 
себе. Кроме того, подкласс может быть суперклассом для другого подкласса. 

Для любого создаваемого подкласса разрешено указывать только один суперкласс. Наследование нескольких суперклассов при создании одиночного 
подкласса в языке Java не поддерживается. Как было указано, можно создать 
иерархию наследования, в которой подкласс становится суперклассом для 
другого подкласса. Однако ни один класс не может быть суперклассом для 
самого себя.

</details>

<details><summary>Доступ к членам и наследования</summary>

Хотя подкласс включает в себя все члены своего суперкласса, он не может получить доступ к тем членам суперкласса, которые были объявлены как закрытые.

[Chapter08/DemoBoxWeight02 -  Пример, где наследование применяется для расширения класса](https://github.com/Vladlena2/BookJava/tree/main/Chapter8/DemoBoxWeight02.java "Посмотреть пример Java")

Классу BaxWeight вовсе не обязательно воссоздавать все функциональные средства, имеющиеся в Boх. Для достижения своих целей он может просто расширить Вох. 
Основное преимущество наследования связано с тем, что после создания 
суперкласса, который определяет характерные черты, общие для набора объектов, его можно применять для создания любого количества более конкретных подклассов. Каждый подкласс может точно настраивать собственное предназначение. 

</details>

<details><summary>Переменная типа суперкласса может ссылаться на объект подкласса</summary>

Ссылочной переменной типа суперкласса можно присваивать ссылку на объект любого подкласса, производного от данного суперкласса.

[Chapter08/RefDemo - Пример](https://github.com/Vladlena2/BookJava/tree/main/Chapter8/RefDemo.java "Посмотреть пример Java")

Здесь weightbox является ссылкой на объекты BoxWeight, а plainbox -
ссылкой на объекты Вох. Поскольку BoxWeight - подкласс Вох, переменной 
plainЬox разрешено присваивать ссылку на объект weightbox. 
Важно понимать, что именно тип ссылочной переменной, а не тип объекта, на который она ссылается, определяет, к каким членам можно получать 
доступ. Другими словами, когда ссылочной переменной типа суперкласса 
присваивается ссылка на объект подкласса, то доступ имеется только к тем 
частям объекта, которые определены в суперклассе. Вот почему переменная 
plainbox не может получить доступ к weight, даже если она ссылается на 
объект BoxWeight. Если подумать, то в этом есть смысл, потому что суперклассу ничего не известно о том, что к нему добавляет подкласс. Поэтому 
последняя строка кода в предыдущем фрагменте закомментирована. Ссылка Вох не может получить доступ к полю weight, т.к. в классе Вох оно не определено. 

</details>

<details><summary>Использование ключевого слова super</summary>

В предшествующих примерах классы, производные от Вох, не были реализованы настолько эффективно и надежно, насколько могли бы. Скажем, конструктор для BoxWeight явно инициализирует поля width, height и depth класса Вох. Это не только приводит к дублированию кода, уже имеющегося в 
его суперклассе, что неэффективно, но и подразумевает предоставление подклассу доступа к упомянутым членам. Тем не менее, будут возникать ситуации, ко гда желательно создавать суперкласс, который держит детали своей 
реализации при себе (т.е. хранит свои элементы данных закрытыми). В таком 
случае у подкласса не было бы возможности напрямую обращаться к этим 
переменным либо инициализировать их самостоятельно. Поскольку инкапсуляция является основным атрибутом ООП, совершенно не удивительно, что в Java предлагается решение описанной проблемы. Всякий раз, когда подклассу необходимо сослаться на свой непосредственный суперкласс, он может воспользоваться ключевым словом super. 

Подкласс может вызывать конструктор, определенный в его суперклассе, с 
применением следующей формы super:

```html 
suреr(список-аргументов);  
```

Здесь список-аргументов предназначен для указания любых аргументов, необходимых конструктору в суперклассе. Вызов super() всегда должен 
быть первым оператором, выполняемым внутри конструктора подкласса. 
Чтобы увидеть, как используется super(), рассмотрим показанную ниже 
усовершенствованную версию класса BoxWeight:

```html 
//В классе BoxWeight члены его суперкласса Вох теперь инициализируются с применением super. 
class BoxWeight exteпds Вох{ 
douЫe weight; //вес коробки 
//Инициализировать width, height и depth, используя super()
BoxWeight (douЫe w, douЫe h, douЫe d, double m) { 
super(w, h, d); // вызвать конструктор суперкласса 
weight = m;
}
}
```

Таким образом, super() всегда ссылается на суперкласс 
непосредственно над вызывающим классом. Это справедливо даже для многоуровневой иерархии. Кроме того, вызов super() всегда должен быть первым оператором, выполняемым внутри конструктора подкласса. 

Вторая форма ключевого слова super действует примерно так же, за исключением того, что всегда относится к суперклассу подкласса, в котором 
задействована. Вот как она выrлядит: 

```html 
suреr.член 
```

Здесь член может быть либо методом, либо переменной экземпляра. 
Вторая форма super наиболее применима в ситуациях, когда имена членов 
подкласса скрывают члены с тем же именем в суперклассе. Возьмем следующую простую иерархию классов:

[Chapter08/UseSupper - Пример](https://github.com/Vladlena2/BookJava/tree/main/Chapter8/UseSupper.java "Посмотреть пример Java")

Хотя переменная экземпляра i в В скрывает i в А, ключевое слово super 
делает возможным доступ к члену i, определенному в суперклассе. Как вы 
увидите, super можно также использовать для вызова методов, сокрытых 
подклассом.

</details>

<details><summary>Создание многоуровневой иерархии</summary>

При наличии трех классов А, В и С класс С может быть подклассом 
В, который является подклассом А. Когда возникает ситуация такого типа, 
каждый подкласс наследует все характерные черты, обнаруженные во всех 
его суперклассах. В данном случае С наследует все аспекты В и А.

[Chapter08/DemoShipment05 - Пример, создания многоуровневой иерархии](https://github.com/Vladlena2/BookJava/tree/main/Chapter8/DemoShipment05.java "Посмотреть пример Java")

Благодаря наследованию класс Shipment может задействовать определенные 
ранее классы Вох и BoxWeight, добавляя только ту дополнительную информацию, которая необходима для собственного конкретного приложения. Это часть 
ценности наследования; оно позволяет многократно использовать код. 
В примере иллюстрируется еще один важный момент: super() всегда ссылается на конструктор в ближайшем суперклассе. В классе Shipment с помощью super() вызывается конструктор BoxWeight, а в классе BoxWeight -конструктор Вох. В рамках иерархии классов, когда конструктору суперкласса требуются аргументы, то все подклассы должны передавать их "вверх по цепочке наследования'.

</details>

<details><summary>Порядок вызова конструкторов</summary>
  
В иерархии классов конструкторы завершают свое выполнение в порядке наследования от суперкласса к подклассу. 
Кроме того, поскольку вызов super() должен быть первым оператором, выполняемым в конструкторе подкласса, такой порядок остается тем же независимо от того, применяется super() или нет. Если super() не используется, то будет выполнен стандартный конструктор или конструктор без параметров каждого суперкласса. Выполнение конструкторов демонстрируется в следующей программе: 

[Chapter08/CallingConstr06 - Пример](https://github.com/Vladlena2/BookJava/tree/main/Chapter8/CallingConstr06.java "Посмотреть пример Java")

Если хорошо подумать, то имеет смысл, что конструкторы завершают свое 
выполнение в порядке наследования. Поскольку суперклассу ничего не известно о каких-либо подклассах, любая инициализация, которую должен выполнить суперкласс, является отдельной и возможно обязательной для любой инициализации, выполняемой подклассом. Следовательно, она должна быть завершена первой. 

</details>

<details><summary>Переопределение методов</summary>

В иерархии классов, когда метод в подклассе имеет то же имя и сигнатуру типа, что и метод в его суперклассе, то говорят, что метод в подклассе 
переопределяет метод в суперклассе. При вызове переопределенного метода через его подкласс всегда будет вызываться версия метода, определенная в подклассе. Версия метода, определенная в суперклассе будет сокрыта.

При желании получить доступ к версии переопределенного метода из суперкласса можно применить ключевое слово super. Скажем, в приведенном 
далее классе В внутри версии show() из подкласса вызывается версия show( ) 
из суперкласса, что позволяет отобразить все переменные экземпляра.

[Chapter08/OverloadMethod08 - Пример, переопределения методов](https://github.com/Vladlena2/BookJava/tree/main/Chapter8/OverloadMethod08.java "Посмотреть пример Java")

Метод переопределяется только в случае, если и мена и сигнатуры типов 
двух методов идентичны, а иначе два метода будут просто перегруженными.

[Chapter08/Override - Пример, перегрузки методов](https://github.com/Vladlena2/BookJava/tree/main/Chapter8/Override.java "Посмотреть пример Java")

Версия метода show() в классе В принимает строковый параметр, что отличает его сигнатуру типов от сигнатуры метода show() в классе А, который 
не принимает параметров. Поэтому никакого переопределения (или сокрытия имени) не происходит. Взамен версия show() в классе В просто перегружает версию show() из класса А. 

</details>

<details><summary>Динамическая диспетчеризация методов</summary>

Переопределение методов лежит в основе одной из самых мощных 
концепций Java - диспетчеризации динамических методов. Диспетчеризация 
динамических методов представляет собой механизм, с помощью которого 
вызов переопределенного метода распознается во время выполнения, а не на 
этапе компиляции. Динамическая диспетчеризация методов важна, потому 
что именно так в Java обеспечивается полиморфизм во время выполнения. 

Тип объекта, на 
который делается ссылка (а не тип ссылочной переменной), определяет, какая 
версия переопределенного метода будет выполняться. 

[Chapter08/DynamicMethodDispatching09 - Динамическая диспетчеризация методов](https://github.com/Vladlena2/BookJava/tree/main/Chapter8/DynamicMethodDispatching09.java "Посмотреть пример Java")

В программе создается один суперкласс по имени А и два его подкласса, 
в и С. Подклассы В и С переопределяют метод callme(), объявленный в А. 
Внутри метода main() объявляются объекты типов А, В и С. Кроме того, объявляется ссылка типа А по имени r. Затем в программе переменной r по очереди присваивается ссылка на каждый тип объекта и производится вызов 
метода callme(). В выводе видно, что выполняемая версия callme() определяется типом объекта, на который делается ссылка во время вызова. Если 
бы версия определялась типом ссылочной переменной r, то вы бы увидели 
три вызова метода callme() класса А.

</details>

<details><summary>Назначение и применение переопределенных методов</summary>

Полиморфизм важен для 
ООП по одной причине: он позволяет универсальному классу определять 
методы, которые будут общими для всех производных от него классов, одновременно разрешая подклассам определять индивидуальные реализации 
некоторых или всех общих методов. Переопределенные методы - еще один 
способ, которым в Java обеспечивается аспект полиморфизма "один интерфейс, несколько методов".

Одним из ключей к успешному применению полиморфизма является понимание того, что суперклассы и подклассы образуют иерархию с продвижением от меньшей специализации к большей. При правильном использовании 
суперкласс предоставляет все элементы, которые подкласс может задействовать напрямую. Он также определяет те методы, которые производный класс 
должен реализовать самостоятельно. Это позволяет подклассу не только гибко определять собственные методы, но также обеспечивает согласованный 
интерфейс. Таким образом, комбинируя наследование с переопределенными 
методами, суперкласс может определять общую форму методов, которые будут потребляться всеми его подклассами.

Динамический полиморфизм во время выполнения - один из самых 
мощных механизмов, которыми ООП воздействует на многократное использование и надежность кода. Способность существующих библиотек кода 
вызывать методы для экземпляров новых классов без перекомпиляции с одновременным сохранением чистого абстрактного интерфейса является чрезвычайно мощным инструментом

Практический пример, в котором применяется переопределение методов. В приведенной ниже программе создается суперкласс Figure для хранения размеров двумерного объекта, а также определяется метод area() для расчета площади этого объекта. Кроме того, в этой программе создаются два класса, Rectangle и Triangle, производные от класса Figure. Метод area() переопределяется в каждом из этих подклассов, чтобы возвращать площадь четырехугольника и треугольника соответственно.

[Chapter08/FigureFindArea10 - Применение динамического полиморфизма](https://github.com/Vladlena2/BookJava/tree/main/Chapter8/FigureFindArea10.java "Посмотреть пример Java")

С помощью дуальных механизмов наследования и полиморфизма во время выполнения можно определить один согласованный интерфейс, который 
применяется несколькими разными, но связанными типами объектов. В данном случае, если объект является производным от Figure, то его площадь 
можно получить, вызвав метод area(). Интерфейс этой операции одинаков 
вне зависимости от того, какой тип фигуры используется. 

</details>
 
<details><summary>Использование абстрактных классов</summary> 

Бывают ситуации, когда желательно определить суперкласс, который 
объявляет структуру заданной абстракции, не предоставляя полные реализации методов. То есть иногда нужно создать суперкласс, определяющий 
только обобщенную форму, которая будет применяться всеми его подклассами, оставляя каждому подклассу возможность заполнить детали. Такой 
класс определяет природу методов, подлежащих реализации в подклассах. 
Ситуация подобного рода может возникнуть, когда суперкласс не способен 
создать осмысленную реализацию метода. Это относится к классу Figure, 
использованному в предыдущем примере. Определение метода area() является просто заполнителем. Он не будет рассчитывать и отображать площадь 
объекта любого вида. 

Вы можете потребовать, чтобы некоторые методы были переопределены 
в подклассах, указав модификатор abstract. Иногда их называют методами, 
подпадающими под ответственность подкласса, потому что они не имеют 
реализ ации, указанной в суперклассе. Таким образом, подкласс обязан их 
переопределить - он не может просто использовать версию, определенную 
в суперклассе. Для объявления абстрактного метода применяется следующая 
общая форма: 

```html 
abstract тип имя(список-параметров);
```

Любой класс, содержащий один или несколько абстрактных методов, тоже 
должен быть объявлен абстрактным. Чтобы объявить класс абстрактным, 
перед ключевым словом class в начале объявления класса просто используется ключевое слово abstract. Объектов абстрактного класса не бывает, т.е. экземпляр абстрактного класса нельзя создать напрямую с помощью операции new. Подобного рода объекты был и бы бесполезными, т.к. абстрактный класс не определен полностью. Кроме того, не допускается объявлять абстрактные конструкторы или абстрактные статические методы. Любой подкласс абстрактного класса должен либо реализовать все абстрактные методы суперкласса, либо сам быть объявлен абстрактным. 

Хотя абстрактные классы нельзя задействовать для создания объектов, их 
можно применять для создания ссылок на объекты, поскольку подход Java 
к полиморфизму во время выполнения обеспечивается через использование 
ссылок на суперклассы. Таким образом, должна быть возможность создания 
ссылки на абстрактный класс, чтобы ее можно было применять для указания 
на объект подкласса.

[Chapter08/FigureFindArea10 - Применение динамического полиморфизма](https://github.com/Vladlena2/BookJava/tree/main/Chapter8/FigureFindArea10.java "Посмотреть пример Java")

</details>

<details><summary>Предотвращение переопределения с помощью ключевого слова final</summary> 

Наряду с тем, что переопределение методов является одной из самых 
мощных функциональных средств Java, иногда его желательно предотвращать. Чтобы запретить переопределение метода, в начале его объявления понадобится указать ключевое final в качестве модификатора. Методы, объявленные как final, не могут быть переопределены.

```html 
class A {
   final void meth() {
       System.out.println("Этo конечный метод.");
   }   
}
class B extends A {
   void meth() {
       // ОШИБКА!!! Этот метод не может быть переопределен.
   }
}
```

Методы, объявленные как final, иногда могут обеспечить повышение 
производительности: компилятор способен встраивать их вызовы, потому 
что он "знает'; что они не будут переопределяться в подклассе. Когда компилятор Java встречает вызов небольшого метода final, он часто может копировать байт-код для подпрограммы непосредственно в скомпилированный код вызывающего метода, тем самым устраняя накладные расходы по вызову метода. Встраивание возможно только с методами final. Обычно компилятор Java распознает вызовы методов динамически во время выполнения. Это 
называется поздним связыванием. Но поскольку методы final не могут быть 
переопределены, их вызов может распознаваться на этапе компиляции. Это 
называется ранним связыванием.

</details>

<details><summary>Предотвращение наследования с помощью ключевого слова final</summary> 

Иногда нужно предотвратить наследование класса. Для этого перед объявлением класса укажите ключевое слово final. Объявление класса как final также неявно объявляет все его методы как final. Вполне ожидаемо объявлять класс как abstract и final одновременно не разрешено, поскольку абстрактный класс сам по себе неполный и в обеспечении полных реализаций 
полагается на свои подклассы. 

```html 
final class A {
   // ...
}
// Следующий класс недопустим!!!
class B extends A {
  // ОШИБКА!!! Класс А не может иметь подклассы.
}
```

</details>

<details><summary>Выведение типов локальных переменных и наследование</summary> 

Важно иметь четкое представление о том, как работает выведение типов в иерархии наследования. Вспомните, что ссылка на суперкласс может ссылаться на объект производного класса, и такое средство является частью поддержки полиморфизма в Java. Однако важно помнить, что при использовании выведения типов локальных переменных выведенный тип переменной базируется на объявленном типе ее инициализатора. Следовател ьно, если инициализатор относится к типу суперкласса, то он и будет выведенным типом переменной. Не имеет значения, является 
ли фактический объект, на который ссылается инициализатор, экземпляром 
производного класса.

[Chapter08/TypeinferenceAndinheritance - Выведение типов локальных переменных в наследовании](https://github.com/Vladlena2/BookJava/tree/main/Chapter8/TypeinferenceAndinheritance.java "Посмотреть пример Java")

В программе создается иерархия, состоящая из трех классов, на вершине 
которых находится MyClass. Класс FirstDerivedClass определен как подкласс MyClass, а SecondDerivedClass - как подкласс FirstDerivedClass. 
Затем с применением выведения типа создаются три переменные с именами mc, mc2 и mсЗ путем вызова getObj(). Метод getObj() имеет возвращаемый тип MyClass(суперкласс), но в зависимости от передаваемого аргумента возвращает объекты типа MyClass, FirstDeri vedClass или 
SecondDeri vedClass. Как видно в отображенных результатах программы, 
выведенный тип определяется возвращаемым типом getObj(), а не фактическим типом полученного объекта. Таким образом, все три переменные будут 
иметь тип MyClass.

</details>

<details><summary>Класс Object</summary> 

В языке Java определен один специальный класс, называемый Object. Все остальные классы являются подклассами, производными от этого класса. Это означает, что класс Object служит суперклассом для всех остальных классов, и ссылочная переменная из класса Object может ссылаться на объект любого другого класса. А поскольку массивы реализованы в виде классов, то ссылочная переменная типа Object может ссылаться и на любой массив. В классе Object определены методы, перечисленные ниже:

|Метод |Назначение |
|:-----------------------------|:-------------------------------------|
|Object clone() |Создает новый объект, не отличающийся от клонируемго |
|boolean equals(Object object) | Определяет, равен ли один объект другому |
|void finalize() |Вызывается перед удалением неиспользуемого объекта (не рекомендован для применения, начиная с версии JDK 9) |
|Class<?> getClass() |Получает класс объекта во время выполнения |
|int hashCode() |Возвращает хеш-код, связанный с вызывающим объектом |
|void notify() |Возобновляет исполнение потока, ожидающего вызывающего объекта |
|void notifyAll() |Возобновляет исполнение всех потоков, ожидающих вызывающий объект |
|String toString() |Возвращает символьную строку, описывающую объект |
|void wait() |Ожидает другого потока исполнения |
|void wait(long миллисекунд) |Ожидает другого потока исполнения |

Методы getClass(), notify(), notifyAll() и wait() объявлены как final. Остальные методы можно переопределять (они будут описаны в последующих главах данной книги). Обратите, однако, внимание на два метода: equals() и toString(). Метод equals() сравнивает два объекта. Если объекты равны, он возвращает логическое значение true, а иначе - логическое значение false. Точное определение равенства зависит от типа сравниваемых объектов. Метод toString() возвращает символьную строку с описанием объекта, для которого он вызван. Кроме того, метод toString() вызывается автоматически, когда содержимое объекта выводится с помощью метода println(). Этот метод переопределяется во многих классах, чтобы приспосабливать описание к создаваемым в них конкретным типам объектов.

</details>

</blockquote>
</details>

<details ГЛАВА 9><summary>ГЛАВА 9. "История и эволюция языка Java"</summary>
<blockquote>

Пакеты представляют собой контейнеры для классов. Они используются для отделения пространства имен класса. Например, создав класс по имени List и сохранив его в собственном пакете, можно не беспокоиться о том, что он будет конфликтовать с другим классом по имени List, который находится где-то в другом месте. Пакеты хранятся в иерархическом порядке и явно импортируются в определения новых классов.

В предыдущих главах вы видели, что методы определяют интерфейс к данным в классе. Ключевое слово interface позволяет полностью абстрагировать интерфейс от его реализации. С помощью interface указывается набор методов, которые могут быть реализованы одним или несколькими классами. В своей традиционной форме интерфейс сам по себе не определяет никакой реализации.

Хотя интерфейсы похожи на абстрактные классы, они обладают дополнительной возможностью: класс может реализовывать более одного интерфейса. В противоположность этому класс может быть унаследован только от одного суперкласса (абстрактного либо иного).

<details><summary>Пакеты</summary>

В Java предоставляется механизм для разделения пространства имен классов на более управляемые фрагменты - пакеты. Пакет является как механизмом именования, так и механизмом управления видимостью. Вы можете определять классы внутри пакета, которые не доступны коду вне пакета. Вы также можете определять члены класса, которые видны только другим членам классов в том же пакете. Это позволяет вашим классам хорошо знать друг друга, но не раскрывать такие знания остальному миру.

Создать пакет довольно легко: просто поместите в начало файла с исходным кодом Java оператор `package`. Любые классы, объявленные в данном файле, будут принадлежать указанному пакету. Оператор `package` определяет пространство имен, в котором хранятся классы. Если оператор `package` отсутствует, то имена классов помещаются в стандартный пакет, не имеющий имени.

Вот общая форма оператора package: 

```html 
package пакет; 
```

Допускается создавать иерархию пакетов, для чего нужно просто отделять имя каждого пакета от имени пакета над ним с помощью точки. Общая форма оператора многоуровневого пакета выглядит следующим образом:
```html
package пакет1 [ . пакет2 [ . пакет3]] ;
```

Иерархия пакетов должна быть отражена в файловой системе на машине для разработки приложений Java. Например, объявленный ниже пакет должен храниться в папке `а\Ь\с` в среде Windows:
```html
package а.Ь.с ;
```

Имена пакетов должны выбираться крайне аккуратно, так как нельзя переименовать пакет, не переименовав каталог, в котором хранятся классы.

По умолчанию исполняющая среда Java в качестве начальной точки использует текущий рабочий каталог. Таким образом, если ваш пакет расположен в каком-то подкаталоге внутри текущего каталога, то он будет найден. Во-вторых, вы можете указать путь или пути к каталогам, установив переменную среды `CLASSPATH`. В-третьих, вы можете применить параметр `-classpath` при запуске `java` и `javac`, чтобы указать путь к своим классам.

Полезно отметить, что начиная с JDK 9, пакет может быть частью модуля и, следовательно, находиться в пути к модулю. Чтобы программа могла найти пакет `mypack`, ее можно либо запустить из каталога непосредственно над `mypack`, либо переменная среды `CLASSPATH` должна включать путь к `mypack`, либо при запуске программы через `java` в параметре `-classpath` должен быть указан путь к `mypack`.

Когда применяются последние два способа, путь к классу не должен содержать само имя `mypack`. Он должен просто указывать путь к `mypack`. Например, если в среде Windows путем к `mypack` является:

```html
C:\MyPrograms\Java\mypack
```

то путем к классу для `mypack` будет:

```html
C:\MyPrograms\Java
```

Испытать примеры, приведенные в книге, проще всего, создав каталоги пакетов внутри текущего каталога разработки, поместив файлы `.class` в соответствующие каталоги, и затем запустив программы из каталога разработки. Именно такой подход используется в рассматриваемом далее примере.

Классы и пакеты являются средствами инкапсуляции и содержания в 
себе пространства имен, а также области видимости переменных и методов. 
Пакеты действуют в качестве контейнеров для классов и других подчиненных 
пакетов. Классы действуют как контейнеры для данных и кода. Класс - это 
наименьшая единица абстракции Java.

Доступ к членам классов:

|                      | Тот же класс | Подкласс из того же пакета | Не подкласс из того же пакета | Подкласс из другого пакета | Не подкласс из другого пакета |
|----------------------|--------------|-----------------------------|-------------------------------|-----------------------------|-------------------------------|
| `public`             | Да           | Да                          | Да                            | Да                          | Да                            |
| `protected`          | Да           | Да                          | Да                            | Да                          | Нет                           |
| `default` (по умолчанию) | Да           | Да                          | Да                            | Нет                         | Нет                           |
| `private`            | Да           | Нет                         | Нет                           | Нет                         | Нет                           |

Эта таблица иллюстрирует, какие члены класса видны для других классов в зависимости от уровня доступа и отношений между классами (в том же классе, подклассе, из того же пакета, из другого пакета).

Хотя механизм управления доступом в Java может показаться сложным, его можно упростить следующим образом. Ко всему, что объявлено как `public`, можно получать доступ из разных классов и разных пакетов. Все, что объявлено как `private`, не может быть видимым за пределами его класса. Когда у члена нет явной спецификации доступа, он виден подклассам, а также другим классам в том же пакете. Такой доступ принят по умолчанию. Если вы хотите, чтобы элемент был видимым за пределами вашего текущего пакета, но только классам, которые напрямую являются подклассами вашего класса, тогда объявите этот элемент как `protected`.

Правила доступа к членам классов, приведенные в таблице 9.1, применимы только к членам классов. Класс, не являющийся вложенным, имеет только два возможных уровня доступа: стандартный и открытый. Когда класс объявлен как `public`, он доступен за пределами своего пакета. Если класс имеет стандартный доступ, то к нему может получать доступ только другой код в том же пакете. Когда класс является открытым, он должен быть единственным открытым классом, объявленным в файле, а файл должен иметь такое же имя, как у класса.

<details><summary>Пример, использование модификаторов доступа</summary>

В приведенном примере демонстрируются все комбинации модификаторов управления доступом. В примере присутствуют два пакета и пять классов. Не забывайте, что классы для двух разных пакетов должны храниться в каталогах с именами, совпадающими с именами соответствующих пакетов - в данном случае pl и р2.

В файле с исходным кодом для первого пакета определены три класса: `Protection`, `Derived` и `SamePackage`. В первом классе определяются четыре переменные типа int с каждым допустимым уровнем доступа. Переменная `n` объявлена со стандартным доступом, `n_pri` - с доступом `private`, `n_pro` - с доступом `protected`, а `n_pub` - с доступом `public`. Все последующие классы в рассматриваемом примере будут пытаться получить доступ к переменным экземпляра класса `Protection`. Строки, которые не будут компилироваться из-за ограничений доступа, закомментированы. Перед каждой из таких строк находится комментарий с перечислением мест, из которых этот уровень защиты разрешит доступ.

Второй класс, `Derived`, является подклассом `Protection` в том же пакете `pl`, что дает `Derived` доступ ко всем переменным в `Protection` кроме закрытой переменной `n_pri`. Третий класс, `SamePackage`, не является подклассом `Protection`, но находится в том же самом пакете и тоже имеет доступ ко всем переменным кроме `n_pri`.

[Chapter09/MainDemo - получить экземпляры различных классов из пакета pkg01](https://github.com/Vladlena2/BookJava/tree/main/Chapter9/pkg01/MainDemo.java "Посмотреть пример Java")

Ниже представлен исходный код другого пакета, `p2`. Два класса, определенные в `p2`, охватывают остальные два условия, на которые влияет управление доступом. Первый класс, `Protection2`, является подклассом `pl.Protection`, что дает ему доступ ко всем переменным `pl.Protection` кроме `n_pri` (поскольку она является закрытой) и `n` - переменной, объявленной со стандартной защитой.

Вспомните, что по умолчанию разрешен доступ только из класса или пакета, а не из подклассов вне пакета. Наконец, класс `OtherPackage` имеет доступ только к одной переменной `n_pub`, которая была объявлена открытой.

[Chapter09/MainDemo - получить экземпляры различных классов из пакета pkg02](https://github.com/Vladlena2/BookJava/tree/main/Chapter9/pkg02/MainDemo.java "Посмотреть пример Java")

</details>

<details><summary>Импортирование пакетов</summary>

Поскольку классы в пакетах должны полностью уточняться с помощью одного или нескольких имен пакетов, набор длинного пути к пакету, разделенного точками, для каждого используемого класса может стать утомительным. По этой причине в составе Java имеется оператор импортирования import, который позволяет сделать видимыми определенные классы или целые пакеты. После импортирования на класс можно ссылаться напрямую с применением только его названия. Оператор import является удобным инструментом для программиста и формально не нужен для написания законченной программы на Java. Однако, если вы собираетесь ссылаться на несколько десятков классов в своем приложении, то оператор import существенно сократит объем кода.

В файле с исходным кодом на Java операторы импорта располагаются сразу после оператора пакета (если он присутствует) и перед любыми определениями классов. Общая форма оператора импорта выглядит следующим образом:

```html
import пакет [пакет2] имя_класса;
```

В конце оператора импорта указывается либо явное имя класса (name_class), либо звездочка (*), которая сообщает компилятору Java о необходимости импортировать весь пакет. Вот два примера использования:

```html
import java.util.Date;
import java.io.*;
```

Все стандартные классы Java SE, включенные в состав Java, начинаются с имени java. Основные языковые функции содержатся в пакете с именем java.lang. Обычно вам нужно импортировать каждый пакет или класс, который вы планируете использовать, но так как язык Java бесполезен без большей части функциональности пакета java.lang, он неявно импортируется компилятором для всех программ. Это равносильно наличию в начале кода каждой вашей программы следующей строки:

```html
import java.lang.*;
```

Если в двух различных пакетах, импортированных с помощью оператора импорта со звездочкой, имеются классы с одинаковыми именами, компилятор никак не отреагирует на это, пока вы не попытаетесь использовать один из классов. В этом случае возникнет ошибка компиляции.

Например, если вы хотите, чтобы класс Balance из упомянутого ранее пакета mypack был доступен как автономный класс для общего использования вне пакета mypack, вам нужно объявить его как public и поместить в отдельный файл:

[Chapter09/mypack/Balance - Пример самостоятельного класса за пределами пакета mypack](https://github.com/Vladlena2/BookJava/tree/main/Chapter9/mypack/Balance.java "Посмотреть пример Java")

Теперь класс Balance стал открытым, равно как его конструктор и метод show(). Это означает, что к ним можно получить доступ в коде любого 
вида за рамками пакета mypack. Например, класс TestBalance импортирует 
mypack и затем может работать с классом Balance:

[Chapter09/mypack02/TestBalance - Пример пример, класс TestBalance импортирует пакет mypack](https://github.com/Vladlena2/BookJava/tree/main/Chapter9/mypack02/TestBalance.java "Посмотреть пример Java")

</details>

</details>

<details><summary>Почему в Java нет множественного наследования классов</summary>

[Почему в Java нет множественного наследования классов](https://sky.pro/media/chto-takoe-abstraktnye-klassy/#:~:text=%D0%92%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE%2D%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%20%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0%D1%85%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D1%8B%D0%BC,%E2%80%94%20%D0%B8%D0%BB%D0%B8%2C%20%D0%BF%D0%BE%2D%D0%B4%D1%80%D1%83%D0%B3%D0%BE%D0%BC%D1%83%2C%20%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D1%83%20%D0%B0%D0%BB%D0%BC%D0%B0%D0%B7%D0%B0)


</details>

</blockquote>
</details>
